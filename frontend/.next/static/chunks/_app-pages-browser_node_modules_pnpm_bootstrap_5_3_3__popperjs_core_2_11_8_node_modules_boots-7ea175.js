"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_pnpm_bootstrap_5_3_3__popperjs_core_2_11_8_node_modules_boots-7ea175"],{

/***/ "(app-pages-browser)/./node_modules/.pnpm/bootstrap@5.3.3_@popperjs+core@2.11.8/node_modules/bootstrap/dist/js/bootstrap.bundle.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/bootstrap@5.3.3_@popperjs+core@2.11.8/node_modules/bootstrap/dist/js/bootstrap.bundle.js ***!
  \*********************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n/*!\n  * Bootstrap v5.3.3 (https://getbootstrap.com/)\n  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */ (function(global, factory) {\n     true ? module.exports = factory() : 0;\n})(void 0, function() {\n    \"use strict\";\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap dom/data.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const elementMap = new Map();\n    const Data = {\n        set (element, key, instance) {\n            if (!elementMap.has(element)) {\n                elementMap.set(element, new Map());\n            }\n            const instanceMap = elementMap.get(element);\n            // make it clear we only want one instance per element\n            // can be removed later when multiple key/instances are fine to be used\n            if (!instanceMap.has(key) && instanceMap.size !== 0) {\n                // eslint-disable-next-line no-console\n                console.error(\"Bootstrap doesn't allow more than one instance per element. Bound instance: \".concat(Array.from(instanceMap.keys())[0], \".\"));\n                return;\n            }\n            instanceMap.set(key, instance);\n        },\n        get (element, key) {\n            if (elementMap.has(element)) {\n                return elementMap.get(element).get(key) || null;\n            }\n            return null;\n        },\n        remove (element, key) {\n            if (!elementMap.has(element)) {\n                return;\n            }\n            const instanceMap = elementMap.get(element);\n            instanceMap.delete(key);\n            // free up element references if there are no instances left for an element\n            if (instanceMap.size === 0) {\n                elementMap.delete(element);\n            }\n        }\n    };\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/index.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ const MAX_UID = 1000000;\n    const MILLISECONDS_MULTIPLIER = 1000;\n    const TRANSITION_END = \"transitionend\";\n    /**\n   * Properly escape IDs selectors to handle weird IDs\n   * @param {string} selector\n   * @returns {string}\n   */ const parseSelector = (selector)=>{\n        if (selector && window.CSS && window.CSS.escape) {\n            // document.querySelector needs escaping to handle IDs (html5+) containing for instance /\n            selector = selector.replace(/#([^\\s\"#']+)/g, (match, id)=>\"#\".concat(CSS.escape(id)));\n        }\n        return selector;\n    };\n    // Shout-out Angus Croll (https://goo.gl/pxwQGp)\n    const toType = (object)=>{\n        if (object === null || object === undefined) {\n            return \"\".concat(object);\n        }\n        return Object.prototype.toString.call(object).match(/\\s([a-z]+)/i)[1].toLowerCase();\n    };\n    /**\n   * Public Util API\n   */ const getUID = (prefix)=>{\n        do {\n            prefix += Math.floor(Math.random() * MAX_UID);\n        }while (document.getElementById(prefix));\n        return prefix;\n    };\n    const getTransitionDurationFromElement = (element)=>{\n        if (!element) {\n            return 0;\n        }\n        // Get transition-duration of the element\n        let { transitionDuration, transitionDelay } = window.getComputedStyle(element);\n        const floatTransitionDuration = Number.parseFloat(transitionDuration);\n        const floatTransitionDelay = Number.parseFloat(transitionDelay);\n        // Return 0 if element or transition duration is not found\n        if (!floatTransitionDuration && !floatTransitionDelay) {\n            return 0;\n        }\n        // If multiple durations are defined, take the first\n        transitionDuration = transitionDuration.split(\",\")[0];\n        transitionDelay = transitionDelay.split(\",\")[0];\n        return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n    };\n    const triggerTransitionEnd = (element)=>{\n        element.dispatchEvent(new Event(TRANSITION_END));\n    };\n    const isElement$1 = (object)=>{\n        if (!object || typeof object !== \"object\") {\n            return false;\n        }\n        if (typeof object.jquery !== \"undefined\") {\n            object = object[0];\n        }\n        return typeof object.nodeType !== \"undefined\";\n    };\n    const getElement = (object)=>{\n        // it's a jQuery object or a node element\n        if (isElement$1(object)) {\n            return object.jquery ? object[0] : object;\n        }\n        if (typeof object === \"string\" && object.length > 0) {\n            return document.querySelector(parseSelector(object));\n        }\n        return null;\n    };\n    const isVisible = (element)=>{\n        if (!isElement$1(element) || element.getClientRects().length === 0) {\n            return false;\n        }\n        const elementIsVisible = getComputedStyle(element).getPropertyValue(\"visibility\") === \"visible\";\n        // Handle `details` element as its content may falsie appear visible when it is closed\n        const closedDetails = element.closest(\"details:not([open])\");\n        if (!closedDetails) {\n            return elementIsVisible;\n        }\n        if (closedDetails !== element) {\n            const summary = element.closest(\"summary\");\n            if (summary && summary.parentNode !== closedDetails) {\n                return false;\n            }\n            if (summary === null) {\n                return false;\n            }\n        }\n        return elementIsVisible;\n    };\n    const isDisabled = (element)=>{\n        if (!element || element.nodeType !== Node.ELEMENT_NODE) {\n            return true;\n        }\n        if (element.classList.contains(\"disabled\")) {\n            return true;\n        }\n        if (typeof element.disabled !== \"undefined\") {\n            return element.disabled;\n        }\n        return element.hasAttribute(\"disabled\") && element.getAttribute(\"disabled\") !== \"false\";\n    };\n    const findShadowRoot = (element)=>{\n        if (!document.documentElement.attachShadow) {\n            return null;\n        }\n        // Can find the shadow root otherwise it'll return the document\n        if (typeof element.getRootNode === \"function\") {\n            const root = element.getRootNode();\n            return root instanceof ShadowRoot ? root : null;\n        }\n        if (element instanceof ShadowRoot) {\n            return element;\n        }\n        // when we don't find a shadow root\n        if (!element.parentNode) {\n            return null;\n        }\n        return findShadowRoot(element.parentNode);\n    };\n    const noop = ()=>{};\n    /**\n   * Trick to restart an element's animation\n   *\n   * @param {HTMLElement} element\n   * @return void\n   *\n   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation\n   */ const reflow = (element)=>{\n        element.offsetHeight; // eslint-disable-line no-unused-expressions\n    };\n    const getjQuery = ()=>{\n        if (window.jQuery && !document.body.hasAttribute(\"data-bs-no-jquery\")) {\n            return window.jQuery;\n        }\n        return null;\n    };\n    const DOMContentLoadedCallbacks = [];\n    const onDOMContentLoaded = (callback)=>{\n        if (document.readyState === \"loading\") {\n            // add listener on the first call when the document is in loading state\n            if (!DOMContentLoadedCallbacks.length) {\n                document.addEventListener(\"DOMContentLoaded\", ()=>{\n                    for (const callback of DOMContentLoadedCallbacks){\n                        callback();\n                    }\n                });\n            }\n            DOMContentLoadedCallbacks.push(callback);\n        } else {\n            callback();\n        }\n    };\n    const isRTL = ()=>document.documentElement.dir === \"rtl\";\n    const defineJQueryPlugin = (plugin)=>{\n        onDOMContentLoaded(()=>{\n            const $ = getjQuery();\n            /* istanbul ignore if */ if ($) {\n                const name = plugin.NAME;\n                const JQUERY_NO_CONFLICT = $.fn[name];\n                $.fn[name] = plugin.jQueryInterface;\n                $.fn[name].Constructor = plugin;\n                $.fn[name].noConflict = ()=>{\n                    $.fn[name] = JQUERY_NO_CONFLICT;\n                    return plugin.jQueryInterface;\n                };\n            }\n        });\n    };\n    const execute = function(possibleCallback) {\n        let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : possibleCallback;\n        return typeof possibleCallback === \"function\" ? possibleCallback(...args) : defaultValue;\n    };\n    const executeAfterTransition = function(callback, transitionElement) {\n        let waitForTransition = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        if (!waitForTransition) {\n            execute(callback);\n            return;\n        }\n        const durationPadding = 5;\n        const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;\n        let called = false;\n        const handler = (param)=>{\n            let { target } = param;\n            if (target !== transitionElement) {\n                return;\n            }\n            called = true;\n            transitionElement.removeEventListener(TRANSITION_END, handler);\n            execute(callback);\n        };\n        transitionElement.addEventListener(TRANSITION_END, handler);\n        setTimeout(()=>{\n            if (!called) {\n                triggerTransitionEnd(transitionElement);\n            }\n        }, emulatedDuration);\n    };\n    /**\n   * Return the previous/next element of a list.\n   *\n   * @param {array} list    The list of elements\n   * @param activeElement   The active element\n   * @param shouldGetNext   Choose to get next or previous element\n   * @param isCycleAllowed\n   * @return {Element|elem} The proper element\n   */ const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed)=>{\n        const listLength = list.length;\n        let index = list.indexOf(activeElement);\n        // if the element does not exist in the list return an element\n        // depending on the direction and if cycle is allowed\n        if (index === -1) {\n            return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];\n        }\n        index += shouldGetNext ? 1 : -1;\n        if (isCycleAllowed) {\n            index = (index + listLength) % listLength;\n        }\n        return list[Math.max(0, Math.min(index, listLength - 1))];\n    };\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap dom/event-handler.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const namespaceRegex = /[^.]*(?=\\..*)\\.|.*/;\n    const stripNameRegex = /\\..*/;\n    const stripUidRegex = /::\\d+$/;\n    const eventRegistry = {}; // Events storage\n    let uidEvent = 1;\n    const customEvents = {\n        mouseenter: \"mouseover\",\n        mouseleave: \"mouseout\"\n    };\n    const nativeEvents = new Set([\n        \"click\",\n        \"dblclick\",\n        \"mouseup\",\n        \"mousedown\",\n        \"contextmenu\",\n        \"mousewheel\",\n        \"DOMMouseScroll\",\n        \"mouseover\",\n        \"mouseout\",\n        \"mousemove\",\n        \"selectstart\",\n        \"selectend\",\n        \"keydown\",\n        \"keypress\",\n        \"keyup\",\n        \"orientationchange\",\n        \"touchstart\",\n        \"touchmove\",\n        \"touchend\",\n        \"touchcancel\",\n        \"pointerdown\",\n        \"pointermove\",\n        \"pointerup\",\n        \"pointerleave\",\n        \"pointercancel\",\n        \"gesturestart\",\n        \"gesturechange\",\n        \"gestureend\",\n        \"focus\",\n        \"blur\",\n        \"change\",\n        \"reset\",\n        \"select\",\n        \"submit\",\n        \"focusin\",\n        \"focusout\",\n        \"load\",\n        \"unload\",\n        \"beforeunload\",\n        \"resize\",\n        \"move\",\n        \"DOMContentLoaded\",\n        \"readystatechange\",\n        \"error\",\n        \"abort\",\n        \"scroll\"\n    ]);\n    /**\n   * Private methods\n   */ function makeEventUid(element, uid) {\n        return uid && \"\".concat(uid, \"::\").concat(uidEvent++) || element.uidEvent || uidEvent++;\n    }\n    function getElementEvents(element) {\n        const uid = makeEventUid(element);\n        element.uidEvent = uid;\n        eventRegistry[uid] = eventRegistry[uid] || {};\n        return eventRegistry[uid];\n    }\n    function bootstrapHandler(element, fn) {\n        return function handler(event) {\n            hydrateObj(event, {\n                delegateTarget: element\n            });\n            if (handler.oneOff) {\n                EventHandler.off(element, event.type, fn);\n            }\n            return fn.apply(element, [\n                event\n            ]);\n        };\n    }\n    function bootstrapDelegationHandler(element, selector, fn) {\n        return function handler(event) {\n            const domElements = element.querySelectorAll(selector);\n            for(let { target } = event; target && target !== this; target = target.parentNode){\n                for (const domElement of domElements){\n                    if (domElement !== target) {\n                        continue;\n                    }\n                    hydrateObj(event, {\n                        delegateTarget: target\n                    });\n                    if (handler.oneOff) {\n                        EventHandler.off(element, event.type, selector, fn);\n                    }\n                    return fn.apply(target, [\n                        event\n                    ]);\n                }\n            }\n        };\n    }\n    function findHandler(events, callable) {\n        let delegationSelector = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n        return Object.values(events).find((event)=>event.callable === callable && event.delegationSelector === delegationSelector);\n    }\n    function normalizeParameters(originalTypeEvent, handler, delegationFunction) {\n        const isDelegated = typeof handler === \"string\";\n        // TODO: tooltip passes `false` instead of selector, so we need to check\n        const callable = isDelegated ? delegationFunction : handler || delegationFunction;\n        let typeEvent = getTypeEvent(originalTypeEvent);\n        if (!nativeEvents.has(typeEvent)) {\n            typeEvent = originalTypeEvent;\n        }\n        return [\n            isDelegated,\n            callable,\n            typeEvent\n        ];\n    }\n    function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {\n        if (typeof originalTypeEvent !== \"string\" || !element) {\n            return;\n        }\n        let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\n        // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position\n        // this prevents the handler from being dispatched the same way as mouseover or mouseout does\n        if (originalTypeEvent in customEvents) {\n            const wrapFunction = (fn)=>{\n                return function(event) {\n                    if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {\n                        return fn.call(this, event);\n                    }\n                };\n            };\n            callable = wrapFunction(callable);\n        }\n        const events = getElementEvents(element);\n        const handlers = events[typeEvent] || (events[typeEvent] = {});\n        const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);\n        if (previousFunction) {\n            previousFunction.oneOff = previousFunction.oneOff && oneOff;\n            return;\n        }\n        const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, \"\"));\n        const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);\n        fn.delegationSelector = isDelegated ? handler : null;\n        fn.callable = callable;\n        fn.oneOff = oneOff;\n        fn.uidEvent = uid;\n        handlers[uid] = fn;\n        element.addEventListener(typeEvent, fn, isDelegated);\n    }\n    function removeHandler(element, events, typeEvent, handler, delegationSelector) {\n        const fn = findHandler(events[typeEvent], handler, delegationSelector);\n        if (!fn) {\n            return;\n        }\n        element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));\n        delete events[typeEvent][fn.uidEvent];\n    }\n    function removeNamespacedHandlers(element, events, typeEvent, namespace) {\n        const storeElementEvent = events[typeEvent] || {};\n        for (const [handlerKey, event] of Object.entries(storeElementEvent)){\n            if (handlerKey.includes(namespace)) {\n                removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n            }\n        }\n    }\n    function getTypeEvent(event) {\n        // allow to get the native events from namespaced events ('click.bs.button' --> 'click')\n        event = event.replace(stripNameRegex, \"\");\n        return customEvents[event] || event;\n    }\n    const EventHandler = {\n        on (element, event, handler, delegationFunction) {\n            addHandler(element, event, handler, delegationFunction, false);\n        },\n        one (element, event, handler, delegationFunction) {\n            addHandler(element, event, handler, delegationFunction, true);\n        },\n        off (element, originalTypeEvent, handler, delegationFunction) {\n            if (typeof originalTypeEvent !== \"string\" || !element) {\n                return;\n            }\n            const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\n            const inNamespace = typeEvent !== originalTypeEvent;\n            const events = getElementEvents(element);\n            const storeElementEvent = events[typeEvent] || {};\n            const isNamespace = originalTypeEvent.startsWith(\".\");\n            if (typeof callable !== \"undefined\") {\n                // Simplest case: handler is passed, remove that listener ONLY.\n                if (!Object.keys(storeElementEvent).length) {\n                    return;\n                }\n                removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);\n                return;\n            }\n            if (isNamespace) {\n                for (const elementEvent of Object.keys(events)){\n                    removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));\n                }\n            }\n            for (const [keyHandlers, event] of Object.entries(storeElementEvent)){\n                const handlerKey = keyHandlers.replace(stripUidRegex, \"\");\n                if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\n                    removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n                }\n            }\n        },\n        trigger (element, event, args) {\n            if (typeof event !== \"string\" || !element) {\n                return null;\n            }\n            const $ = getjQuery();\n            const typeEvent = getTypeEvent(event);\n            const inNamespace = event !== typeEvent;\n            let jQueryEvent = null;\n            let bubbles = true;\n            let nativeDispatch = true;\n            let defaultPrevented = false;\n            if (inNamespace && $) {\n                jQueryEvent = $.Event(event, args);\n                $(element).trigger(jQueryEvent);\n                bubbles = !jQueryEvent.isPropagationStopped();\n                nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\n                defaultPrevented = jQueryEvent.isDefaultPrevented();\n            }\n            const evt = hydrateObj(new Event(event, {\n                bubbles,\n                cancelable: true\n            }), args);\n            if (defaultPrevented) {\n                evt.preventDefault();\n            }\n            if (nativeDispatch) {\n                element.dispatchEvent(evt);\n            }\n            if (evt.defaultPrevented && jQueryEvent) {\n                jQueryEvent.preventDefault();\n            }\n            return evt;\n        }\n    };\n    function hydrateObj(obj) {\n        let meta = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        for (const [key, value] of Object.entries(meta)){\n            try {\n                obj[key] = value;\n            } catch (_unused) {\n                Object.defineProperty(obj, key, {\n                    configurable: true,\n                    get () {\n                        return value;\n                    }\n                });\n            }\n        }\n        return obj;\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap dom/manipulator.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ function normalizeData(value) {\n        if (value === \"true\") {\n            return true;\n        }\n        if (value === \"false\") {\n            return false;\n        }\n        if (value === Number(value).toString()) {\n            return Number(value);\n        }\n        if (value === \"\" || value === \"null\") {\n            return null;\n        }\n        if (typeof value !== \"string\") {\n            return value;\n        }\n        try {\n            return JSON.parse(decodeURIComponent(value));\n        } catch (_unused) {\n            return value;\n        }\n    }\n    function normalizeDataKey(key) {\n        return key.replace(/[A-Z]/g, (chr)=>\"-\".concat(chr.toLowerCase()));\n    }\n    const Manipulator = {\n        setDataAttribute (element, key, value) {\n            element.setAttribute(\"data-bs-\".concat(normalizeDataKey(key)), value);\n        },\n        removeDataAttribute (element, key) {\n            element.removeAttribute(\"data-bs-\".concat(normalizeDataKey(key)));\n        },\n        getDataAttributes (element) {\n            if (!element) {\n                return {};\n            }\n            const attributes = {};\n            const bsKeys = Object.keys(element.dataset).filter((key)=>key.startsWith(\"bs\") && !key.startsWith(\"bsConfig\"));\n            for (const key of bsKeys){\n                let pureKey = key.replace(/^bs/, \"\");\n                pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);\n                attributes[pureKey] = normalizeData(element.dataset[key]);\n            }\n            return attributes;\n        },\n        getDataAttribute (element, key) {\n            return normalizeData(element.getAttribute(\"data-bs-\".concat(normalizeDataKey(key))));\n        }\n    };\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/config.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Class definition\n   */ class Config {\n        // Getters\n        static get Default() {\n            return {};\n        }\n        static get DefaultType() {\n            return {};\n        }\n        static get NAME() {\n            throw new Error('You have to implement the static method \"NAME\", for each component!');\n        }\n        _getConfig(config) {\n            config = this._mergeConfigObj(config);\n            config = this._configAfterMerge(config);\n            this._typeCheckConfig(config);\n            return config;\n        }\n        _configAfterMerge(config) {\n            return config;\n        }\n        _mergeConfigObj(config, element) {\n            const jsonConfig = isElement$1(element) ? Manipulator.getDataAttribute(element, \"config\") : {}; // try to parse\n            return {\n                ...this.constructor.Default,\n                ...typeof jsonConfig === \"object\" ? jsonConfig : {},\n                ...isElement$1(element) ? Manipulator.getDataAttributes(element) : {},\n                ...typeof config === \"object\" ? config : {}\n            };\n        }\n        _typeCheckConfig(config) {\n            let configTypes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.constructor.DefaultType;\n            for (const [property, expectedTypes] of Object.entries(configTypes)){\n                const value = config[property];\n                const valueType = isElement$1(value) ? \"element\" : toType(value);\n                if (!new RegExp(expectedTypes).test(valueType)) {\n                    throw new TypeError(\"\".concat(this.constructor.NAME.toUpperCase(), ': Option \"').concat(property, '\" provided type \"').concat(valueType, '\" but expected type \"').concat(expectedTypes, '\".'));\n                }\n            }\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap base-component.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const VERSION = \"5.3.3\";\n    /**\n   * Class definition\n   */ class BaseComponent extends Config {\n        // Public\n        dispose() {\n            Data.remove(this._element, this.constructor.DATA_KEY);\n            EventHandler.off(this._element, this.constructor.EVENT_KEY);\n            for (const propertyName of Object.getOwnPropertyNames(this)){\n                this[propertyName] = null;\n            }\n        }\n        _queueCallback(callback, element) {\n            let isAnimated = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n            executeAfterTransition(callback, element, isAnimated);\n        }\n        _getConfig(config) {\n            config = this._mergeConfigObj(config, this._element);\n            config = this._configAfterMerge(config);\n            this._typeCheckConfig(config);\n            return config;\n        }\n        // Static\n        static getInstance(element) {\n            return Data.get(getElement(element), this.DATA_KEY);\n        }\n        static getOrCreateInstance(element) {\n            let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            return this.getInstance(element) || new this(element, typeof config === \"object\" ? config : null);\n        }\n        static get VERSION() {\n            return VERSION;\n        }\n        static get DATA_KEY() {\n            return \"bs.\".concat(this.NAME);\n        }\n        static get EVENT_KEY() {\n            return \".\".concat(this.DATA_KEY);\n        }\n        static eventName(name) {\n            return \"\".concat(name).concat(this.EVENT_KEY);\n        }\n        constructor(element, config){\n            super();\n            element = getElement(element);\n            if (!element) {\n                return;\n            }\n            this._element = element;\n            this._config = this._getConfig(config);\n            Data.set(this._element, this.constructor.DATA_KEY, this);\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap dom/selector-engine.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ const getSelector = (element)=>{\n        let selector = element.getAttribute(\"data-bs-target\");\n        if (!selector || selector === \"#\") {\n            let hrefAttribute = element.getAttribute(\"href\");\n            // The only valid content that could double as a selector are IDs or classes,\n            // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n            // `document.querySelector` will rightfully complain it is invalid.\n            // See https://github.com/twbs/bootstrap/issues/32273\n            if (!hrefAttribute || !hrefAttribute.includes(\"#\") && !hrefAttribute.startsWith(\".\")) {\n                return null;\n            }\n            // Just in case some CMS puts out a full URL with the anchor appended\n            if (hrefAttribute.includes(\"#\") && !hrefAttribute.startsWith(\"#\")) {\n                hrefAttribute = \"#\".concat(hrefAttribute.split(\"#\")[1]);\n            }\n            selector = hrefAttribute && hrefAttribute !== \"#\" ? hrefAttribute.trim() : null;\n        }\n        return selector ? selector.split(\",\").map((sel)=>parseSelector(sel)).join(\",\") : null;\n    };\n    const SelectorEngine = {\n        find (selector) {\n            let element = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : document.documentElement;\n            return [].concat(...Element.prototype.querySelectorAll.call(element, selector));\n        },\n        findOne (selector) {\n            let element = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : document.documentElement;\n            return Element.prototype.querySelector.call(element, selector);\n        },\n        children (element, selector) {\n            return [].concat(...element.children).filter((child)=>child.matches(selector));\n        },\n        parents (element, selector) {\n            const parents = [];\n            let ancestor = element.parentNode.closest(selector);\n            while(ancestor){\n                parents.push(ancestor);\n                ancestor = ancestor.parentNode.closest(selector);\n            }\n            return parents;\n        },\n        prev (element, selector) {\n            let previous = element.previousElementSibling;\n            while(previous){\n                if (previous.matches(selector)) {\n                    return [\n                        previous\n                    ];\n                }\n                previous = previous.previousElementSibling;\n            }\n            return [];\n        },\n        // TODO: this is now unused; remove later along with prev()\n        next (element, selector) {\n            let next = element.nextElementSibling;\n            while(next){\n                if (next.matches(selector)) {\n                    return [\n                        next\n                    ];\n                }\n                next = next.nextElementSibling;\n            }\n            return [];\n        },\n        focusableChildren (element) {\n            const focusables = [\n                \"a\",\n                \"button\",\n                \"input\",\n                \"textarea\",\n                \"select\",\n                \"details\",\n                \"[tabindex]\",\n                '[contenteditable=\"true\"]'\n            ].map((selector)=>\"\".concat(selector, ':not([tabindex^=\"-\"])')).join(\",\");\n            return this.find(focusables, element).filter((el)=>!isDisabled(el) && isVisible(el));\n        },\n        getSelectorFromElement (element) {\n            const selector = getSelector(element);\n            if (selector) {\n                return SelectorEngine.findOne(selector) ? selector : null;\n            }\n            return null;\n        },\n        getElementFromSelector (element) {\n            const selector = getSelector(element);\n            return selector ? SelectorEngine.findOne(selector) : null;\n        },\n        getMultipleElementsFromSelector (element) {\n            const selector = getSelector(element);\n            return selector ? SelectorEngine.find(selector) : [];\n        }\n    };\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/component-functions.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ const enableDismissTrigger = function(component) {\n        let method = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"hide\";\n        const clickEvent = \"click.dismiss\".concat(component.EVENT_KEY);\n        const name = component.NAME;\n        EventHandler.on(document, clickEvent, '[data-bs-dismiss=\"'.concat(name, '\"]'), function(event) {\n            if ([\n                \"A\",\n                \"AREA\"\n            ].includes(this.tagName)) {\n                event.preventDefault();\n            }\n            if (isDisabled(this)) {\n                return;\n            }\n            const target = SelectorEngine.getElementFromSelector(this) || this.closest(\".\".concat(name));\n            const instance = component.getOrCreateInstance(target);\n            // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method\n            instance[method]();\n        });\n    };\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap alert.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$f = \"alert\";\n    const DATA_KEY$a = \"bs.alert\";\n    const EVENT_KEY$b = \".\".concat(DATA_KEY$a);\n    const EVENT_CLOSE = \"close\".concat(EVENT_KEY$b);\n    const EVENT_CLOSED = \"closed\".concat(EVENT_KEY$b);\n    const CLASS_NAME_FADE$5 = \"fade\";\n    const CLASS_NAME_SHOW$8 = \"show\";\n    /**\n   * Class definition\n   */ class Alert extends BaseComponent {\n        // Getters\n        static get NAME() {\n            return NAME$f;\n        }\n        // Public\n        close() {\n            const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);\n            if (closeEvent.defaultPrevented) {\n                return;\n            }\n            this._element.classList.remove(CLASS_NAME_SHOW$8);\n            const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);\n            this._queueCallback(()=>this._destroyElement(), this._element, isAnimated);\n        }\n        // Private\n        _destroyElement() {\n            this._element.remove();\n            EventHandler.trigger(this._element, EVENT_CLOSED);\n            this.dispose();\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Alert.getOrCreateInstance(this);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                    throw new TypeError('No method named \"'.concat(config, '\"'));\n                }\n                data[config](this);\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ enableDismissTrigger(Alert, \"close\");\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Alert);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap button.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$e = \"button\";\n    const DATA_KEY$9 = \"bs.button\";\n    const EVENT_KEY$a = \".\".concat(DATA_KEY$9);\n    const DATA_API_KEY$6 = \".data-api\";\n    const CLASS_NAME_ACTIVE$3 = \"active\";\n    const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle=\"button\"]';\n    const EVENT_CLICK_DATA_API$6 = \"click\".concat(EVENT_KEY$a).concat(DATA_API_KEY$6);\n    /**\n   * Class definition\n   */ class Button extends BaseComponent {\n        // Getters\n        static get NAME() {\n            return NAME$e;\n        }\n        // Public\n        toggle() {\n            // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method\n            this._element.setAttribute(\"aria-pressed\", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Button.getOrCreateInstance(this);\n                if (config === \"toggle\") {\n                    data[config]();\n                }\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event)=>{\n        event.preventDefault();\n        const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);\n        const data = Button.getOrCreateInstance(button);\n        data.toggle();\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Button);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/swipe.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$d = \"swipe\";\n    const EVENT_KEY$9 = \".bs.swipe\";\n    const EVENT_TOUCHSTART = \"touchstart\".concat(EVENT_KEY$9);\n    const EVENT_TOUCHMOVE = \"touchmove\".concat(EVENT_KEY$9);\n    const EVENT_TOUCHEND = \"touchend\".concat(EVENT_KEY$9);\n    const EVENT_POINTERDOWN = \"pointerdown\".concat(EVENT_KEY$9);\n    const EVENT_POINTERUP = \"pointerup\".concat(EVENT_KEY$9);\n    const POINTER_TYPE_TOUCH = \"touch\";\n    const POINTER_TYPE_PEN = \"pen\";\n    const CLASS_NAME_POINTER_EVENT = \"pointer-event\";\n    const SWIPE_THRESHOLD = 40;\n    const Default$c = {\n        endCallback: null,\n        leftCallback: null,\n        rightCallback: null\n    };\n    const DefaultType$c = {\n        endCallback: \"(function|null)\",\n        leftCallback: \"(function|null)\",\n        rightCallback: \"(function|null)\"\n    };\n    /**\n   * Class definition\n   */ class Swipe extends Config {\n        // Getters\n        static get Default() {\n            return Default$c;\n        }\n        static get DefaultType() {\n            return DefaultType$c;\n        }\n        static get NAME() {\n            return NAME$d;\n        }\n        // Public\n        dispose() {\n            EventHandler.off(this._element, EVENT_KEY$9);\n        }\n        // Private\n        _start(event) {\n            if (!this._supportPointerEvents) {\n                this._deltaX = event.touches[0].clientX;\n                return;\n            }\n            if (this._eventIsPointerPenTouch(event)) {\n                this._deltaX = event.clientX;\n            }\n        }\n        _end(event) {\n            if (this._eventIsPointerPenTouch(event)) {\n                this._deltaX = event.clientX - this._deltaX;\n            }\n            this._handleSwipe();\n            execute(this._config.endCallback);\n        }\n        _move(event) {\n            this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;\n        }\n        _handleSwipe() {\n            const absDeltaX = Math.abs(this._deltaX);\n            if (absDeltaX <= SWIPE_THRESHOLD) {\n                return;\n            }\n            const direction = absDeltaX / this._deltaX;\n            this._deltaX = 0;\n            if (!direction) {\n                return;\n            }\n            execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);\n        }\n        _initEvents() {\n            if (this._supportPointerEvents) {\n                EventHandler.on(this._element, EVENT_POINTERDOWN, (event)=>this._start(event));\n                EventHandler.on(this._element, EVENT_POINTERUP, (event)=>this._end(event));\n                this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n            } else {\n                EventHandler.on(this._element, EVENT_TOUCHSTART, (event)=>this._start(event));\n                EventHandler.on(this._element, EVENT_TOUCHMOVE, (event)=>this._move(event));\n                EventHandler.on(this._element, EVENT_TOUCHEND, (event)=>this._end(event));\n            }\n        }\n        _eventIsPointerPenTouch(event) {\n            return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);\n        }\n        // Static\n        static isSupported() {\n            return \"ontouchstart\" in document.documentElement || navigator.maxTouchPoints > 0;\n        }\n        constructor(element, config){\n            super();\n            this._element = element;\n            if (!element || !Swipe.isSupported()) {\n                return;\n            }\n            this._config = this._getConfig(config);\n            this._deltaX = 0;\n            this._supportPointerEvents = Boolean(window.PointerEvent);\n            this._initEvents();\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap carousel.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$c = \"carousel\";\n    const DATA_KEY$8 = \"bs.carousel\";\n    const EVENT_KEY$8 = \".\".concat(DATA_KEY$8);\n    const DATA_API_KEY$5 = \".data-api\";\n    const ARROW_LEFT_KEY$1 = \"ArrowLeft\";\n    const ARROW_RIGHT_KEY$1 = \"ArrowRight\";\n    const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n    const ORDER_NEXT = \"next\";\n    const ORDER_PREV = \"prev\";\n    const DIRECTION_LEFT = \"left\";\n    const DIRECTION_RIGHT = \"right\";\n    const EVENT_SLIDE = \"slide\".concat(EVENT_KEY$8);\n    const EVENT_SLID = \"slid\".concat(EVENT_KEY$8);\n    const EVENT_KEYDOWN$1 = \"keydown\".concat(EVENT_KEY$8);\n    const EVENT_MOUSEENTER$1 = \"mouseenter\".concat(EVENT_KEY$8);\n    const EVENT_MOUSELEAVE$1 = \"mouseleave\".concat(EVENT_KEY$8);\n    const EVENT_DRAG_START = \"dragstart\".concat(EVENT_KEY$8);\n    const EVENT_LOAD_DATA_API$3 = \"load\".concat(EVENT_KEY$8).concat(DATA_API_KEY$5);\n    const EVENT_CLICK_DATA_API$5 = \"click\".concat(EVENT_KEY$8).concat(DATA_API_KEY$5);\n    const CLASS_NAME_CAROUSEL = \"carousel\";\n    const CLASS_NAME_ACTIVE$2 = \"active\";\n    const CLASS_NAME_SLIDE = \"slide\";\n    const CLASS_NAME_END = \"carousel-item-end\";\n    const CLASS_NAME_START = \"carousel-item-start\";\n    const CLASS_NAME_NEXT = \"carousel-item-next\";\n    const CLASS_NAME_PREV = \"carousel-item-prev\";\n    const SELECTOR_ACTIVE = \".active\";\n    const SELECTOR_ITEM = \".carousel-item\";\n    const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;\n    const SELECTOR_ITEM_IMG = \".carousel-item img\";\n    const SELECTOR_INDICATORS = \".carousel-indicators\";\n    const SELECTOR_DATA_SLIDE = \"[data-bs-slide], [data-bs-slide-to]\";\n    const SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]';\n    const KEY_TO_DIRECTION = {\n        [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,\n        [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT\n    };\n    const Default$b = {\n        interval: 5000,\n        keyboard: true,\n        pause: \"hover\",\n        ride: false,\n        touch: true,\n        wrap: true\n    };\n    const DefaultType$b = {\n        interval: \"(number|boolean)\",\n        // TODO:v6 remove boolean support\n        keyboard: \"boolean\",\n        pause: \"(string|boolean)\",\n        ride: \"(boolean|string)\",\n        touch: \"boolean\",\n        wrap: \"boolean\"\n    };\n    /**\n   * Class definition\n   */ class Carousel extends BaseComponent {\n        // Getters\n        static get Default() {\n            return Default$b;\n        }\n        static get DefaultType() {\n            return DefaultType$b;\n        }\n        static get NAME() {\n            return NAME$c;\n        }\n        // Public\n        next() {\n            this._slide(ORDER_NEXT);\n        }\n        nextWhenVisible() {\n            // FIXME TODO use `document.visibilityState`\n            // Don't call next when the page isn't visible\n            // or the carousel or its parent isn't visible\n            if (!document.hidden && isVisible(this._element)) {\n                this.next();\n            }\n        }\n        prev() {\n            this._slide(ORDER_PREV);\n        }\n        pause() {\n            if (this._isSliding) {\n                triggerTransitionEnd(this._element);\n            }\n            this._clearInterval();\n        }\n        cycle() {\n            this._clearInterval();\n            this._updateInterval();\n            this._interval = setInterval(()=>this.nextWhenVisible(), this._config.interval);\n        }\n        _maybeEnableCycle() {\n            if (!this._config.ride) {\n                return;\n            }\n            if (this._isSliding) {\n                EventHandler.one(this._element, EVENT_SLID, ()=>this.cycle());\n                return;\n            }\n            this.cycle();\n        }\n        to(index) {\n            const items = this._getItems();\n            if (index > items.length - 1 || index < 0) {\n                return;\n            }\n            if (this._isSliding) {\n                EventHandler.one(this._element, EVENT_SLID, ()=>this.to(index));\n                return;\n            }\n            const activeIndex = this._getItemIndex(this._getActive());\n            if (activeIndex === index) {\n                return;\n            }\n            const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\n            this._slide(order, items[index]);\n        }\n        dispose() {\n            if (this._swipeHelper) {\n                this._swipeHelper.dispose();\n            }\n            super.dispose();\n        }\n        // Private\n        _configAfterMerge(config) {\n            config.defaultInterval = config.interval;\n            return config;\n        }\n        _addEventListeners() {\n            if (this._config.keyboard) {\n                EventHandler.on(this._element, EVENT_KEYDOWN$1, (event)=>this._keydown(event));\n            }\n            if (this._config.pause === \"hover\") {\n                EventHandler.on(this._element, EVENT_MOUSEENTER$1, ()=>this.pause());\n                EventHandler.on(this._element, EVENT_MOUSELEAVE$1, ()=>this._maybeEnableCycle());\n            }\n            if (this._config.touch && Swipe.isSupported()) {\n                this._addTouchEventListeners();\n            }\n        }\n        _addTouchEventListeners() {\n            for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)){\n                EventHandler.on(img, EVENT_DRAG_START, (event)=>event.preventDefault());\n            }\n            const endCallBack = ()=>{\n                if (this._config.pause !== \"hover\") {\n                    return;\n                }\n                // If it's a touch-enabled device, mouseenter/leave are fired as\n                // part of the mouse compatibility events on first tap - the carousel\n                // would stop cycling until user tapped out of it;\n                // here, we listen for touchend, explicitly pause the carousel\n                // (as if it's the second time we tap on it, mouseenter compat event\n                // is NOT fired) and after a timeout (to allow for mouse compatibility\n                // events to fire) we explicitly restart cycling\n                this.pause();\n                if (this.touchTimeout) {\n                    clearTimeout(this.touchTimeout);\n                }\n                this.touchTimeout = setTimeout(()=>this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);\n            };\n            const swipeConfig = {\n                leftCallback: ()=>this._slide(this._directionToOrder(DIRECTION_LEFT)),\n                rightCallback: ()=>this._slide(this._directionToOrder(DIRECTION_RIGHT)),\n                endCallback: endCallBack\n            };\n            this._swipeHelper = new Swipe(this._element, swipeConfig);\n        }\n        _keydown(event) {\n            if (/input|textarea/i.test(event.target.tagName)) {\n                return;\n            }\n            const direction = KEY_TO_DIRECTION[event.key];\n            if (direction) {\n                event.preventDefault();\n                this._slide(this._directionToOrder(direction));\n            }\n        }\n        _getItemIndex(element) {\n            return this._getItems().indexOf(element);\n        }\n        _setActiveIndicatorElement(index) {\n            if (!this._indicatorsElement) {\n                return;\n            }\n            const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);\n            activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);\n            activeIndicator.removeAttribute(\"aria-current\");\n            const newActiveIndicator = SelectorEngine.findOne('[data-bs-slide-to=\"'.concat(index, '\"]'), this._indicatorsElement);\n            if (newActiveIndicator) {\n                newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);\n                newActiveIndicator.setAttribute(\"aria-current\", \"true\");\n            }\n        }\n        _updateInterval() {\n            const element = this._activeElement || this._getActive();\n            if (!element) {\n                return;\n            }\n            const elementInterval = Number.parseInt(element.getAttribute(\"data-bs-interval\"), 10);\n            this._config.interval = elementInterval || this._config.defaultInterval;\n        }\n        _slide(order) {\n            let element = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n            if (this._isSliding) {\n                return;\n            }\n            const activeElement = this._getActive();\n            const isNext = order === ORDER_NEXT;\n            const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);\n            if (nextElement === activeElement) {\n                return;\n            }\n            const nextElementIndex = this._getItemIndex(nextElement);\n            const triggerEvent = (eventName)=>{\n                return EventHandler.trigger(this._element, eventName, {\n                    relatedTarget: nextElement,\n                    direction: this._orderToDirection(order),\n                    from: this._getItemIndex(activeElement),\n                    to: nextElementIndex\n                });\n            };\n            const slideEvent = triggerEvent(EVENT_SLIDE);\n            if (slideEvent.defaultPrevented) {\n                return;\n            }\n            if (!activeElement || !nextElement) {\n                // Some weirdness is happening, so we bail\n                // TODO: change tests that use empty divs to avoid this check\n                return;\n            }\n            const isCycling = Boolean(this._interval);\n            this.pause();\n            this._isSliding = true;\n            this._setActiveIndicatorElement(nextElementIndex);\n            this._activeElement = nextElement;\n            const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\n            const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\n            nextElement.classList.add(orderClassName);\n            reflow(nextElement);\n            activeElement.classList.add(directionalClassName);\n            nextElement.classList.add(directionalClassName);\n            const completeCallBack = ()=>{\n                nextElement.classList.remove(directionalClassName, orderClassName);\n                nextElement.classList.add(CLASS_NAME_ACTIVE$2);\n                activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);\n                this._isSliding = false;\n                triggerEvent(EVENT_SLID);\n            };\n            this._queueCallback(completeCallBack, activeElement, this._isAnimated());\n            if (isCycling) {\n                this.cycle();\n            }\n        }\n        _isAnimated() {\n            return this._element.classList.contains(CLASS_NAME_SLIDE);\n        }\n        _getActive() {\n            return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n        }\n        _getItems() {\n            return SelectorEngine.find(SELECTOR_ITEM, this._element);\n        }\n        _clearInterval() {\n            if (this._interval) {\n                clearInterval(this._interval);\n                this._interval = null;\n            }\n        }\n        _directionToOrder(direction) {\n            if (isRTL()) {\n                return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\n            }\n            return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\n        }\n        _orderToDirection(order) {\n            if (isRTL()) {\n                return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\n            }\n            return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Carousel.getOrCreateInstance(this, config);\n                if (typeof config === \"number\") {\n                    data.to(config);\n                    return;\n                }\n                if (typeof config === \"string\") {\n                    if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                        throw new TypeError('No method named \"'.concat(config, '\"'));\n                    }\n                    data[config]();\n                }\n            });\n        }\n        constructor(element, config){\n            super(element, config);\n            this._interval = null;\n            this._activeElement = null;\n            this._isSliding = false;\n            this.touchTimeout = null;\n            this._swipeHelper = null;\n            this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);\n            this._addEventListeners();\n            if (this._config.ride === CLASS_NAME_CAROUSEL) {\n                this.cycle();\n            }\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {\n        const target = SelectorEngine.getElementFromSelector(this);\n        if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\n            return;\n        }\n        event.preventDefault();\n        const carousel = Carousel.getOrCreateInstance(target);\n        const slideIndex = this.getAttribute(\"data-bs-slide-to\");\n        if (slideIndex) {\n            carousel.to(slideIndex);\n            carousel._maybeEnableCycle();\n            return;\n        }\n        if (Manipulator.getDataAttribute(this, \"slide\") === \"next\") {\n            carousel.next();\n            carousel._maybeEnableCycle();\n            return;\n        }\n        carousel.prev();\n        carousel._maybeEnableCycle();\n    });\n    EventHandler.on(window, EVENT_LOAD_DATA_API$3, ()=>{\n        const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);\n        for (const carousel of carousels){\n            Carousel.getOrCreateInstance(carousel);\n        }\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Carousel);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap collapse.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$b = \"collapse\";\n    const DATA_KEY$7 = \"bs.collapse\";\n    const EVENT_KEY$7 = \".\".concat(DATA_KEY$7);\n    const DATA_API_KEY$4 = \".data-api\";\n    const EVENT_SHOW$6 = \"show\".concat(EVENT_KEY$7);\n    const EVENT_SHOWN$6 = \"shown\".concat(EVENT_KEY$7);\n    const EVENT_HIDE$6 = \"hide\".concat(EVENT_KEY$7);\n    const EVENT_HIDDEN$6 = \"hidden\".concat(EVENT_KEY$7);\n    const EVENT_CLICK_DATA_API$4 = \"click\".concat(EVENT_KEY$7).concat(DATA_API_KEY$4);\n    const CLASS_NAME_SHOW$7 = \"show\";\n    const CLASS_NAME_COLLAPSE = \"collapse\";\n    const CLASS_NAME_COLLAPSING = \"collapsing\";\n    const CLASS_NAME_COLLAPSED = \"collapsed\";\n    const CLASS_NAME_DEEPER_CHILDREN = \":scope .\".concat(CLASS_NAME_COLLAPSE, \" .\").concat(CLASS_NAME_COLLAPSE);\n    const CLASS_NAME_HORIZONTAL = \"collapse-horizontal\";\n    const WIDTH = \"width\";\n    const HEIGHT = \"height\";\n    const SELECTOR_ACTIVES = \".collapse.show, .collapse.collapsing\";\n    const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle=\"collapse\"]';\n    const Default$a = {\n        parent: null,\n        toggle: true\n    };\n    const DefaultType$a = {\n        parent: \"(null|element)\",\n        toggle: \"boolean\"\n    };\n    /**\n   * Class definition\n   */ class Collapse extends BaseComponent {\n        // Getters\n        static get Default() {\n            return Default$a;\n        }\n        static get DefaultType() {\n            return DefaultType$a;\n        }\n        static get NAME() {\n            return NAME$b;\n        }\n        // Public\n        toggle() {\n            if (this._isShown()) {\n                this.hide();\n            } else {\n                this.show();\n            }\n        }\n        show() {\n            if (this._isTransitioning || this._isShown()) {\n                return;\n            }\n            let activeChildren = [];\n            // find active children\n            if (this._config.parent) {\n                activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element)=>element !== this._element).map((element)=>Collapse.getOrCreateInstance(element, {\n                        toggle: false\n                    }));\n            }\n            if (activeChildren.length && activeChildren[0]._isTransitioning) {\n                return;\n            }\n            const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);\n            if (startEvent.defaultPrevented) {\n                return;\n            }\n            for (const activeInstance of activeChildren){\n                activeInstance.hide();\n            }\n            const dimension = this._getDimension();\n            this._element.classList.remove(CLASS_NAME_COLLAPSE);\n            this._element.classList.add(CLASS_NAME_COLLAPSING);\n            this._element.style[dimension] = 0;\n            this._addAriaAndCollapsedClass(this._triggerArray, true);\n            this._isTransitioning = true;\n            const complete = ()=>{\n                this._isTransitioning = false;\n                this._element.classList.remove(CLASS_NAME_COLLAPSING);\n                this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n                this._element.style[dimension] = \"\";\n                EventHandler.trigger(this._element, EVENT_SHOWN$6);\n            };\n            const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n            const scrollSize = \"scroll\".concat(capitalizedDimension);\n            this._queueCallback(complete, this._element, true);\n            this._element.style[dimension] = \"\".concat(this._element[scrollSize], \"px\");\n        }\n        hide() {\n            if (this._isTransitioning || !this._isShown()) {\n                return;\n            }\n            const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);\n            if (startEvent.defaultPrevented) {\n                return;\n            }\n            const dimension = this._getDimension();\n            this._element.style[dimension] = \"\".concat(this._element.getBoundingClientRect()[dimension], \"px\");\n            reflow(this._element);\n            this._element.classList.add(CLASS_NAME_COLLAPSING);\n            this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n            for (const trigger of this._triggerArray){\n                const element = SelectorEngine.getElementFromSelector(trigger);\n                if (element && !this._isShown(element)) {\n                    this._addAriaAndCollapsedClass([\n                        trigger\n                    ], false);\n                }\n            }\n            this._isTransitioning = true;\n            const complete = ()=>{\n                this._isTransitioning = false;\n                this._element.classList.remove(CLASS_NAME_COLLAPSING);\n                this._element.classList.add(CLASS_NAME_COLLAPSE);\n                EventHandler.trigger(this._element, EVENT_HIDDEN$6);\n            };\n            this._element.style[dimension] = \"\";\n            this._queueCallback(complete, this._element, true);\n        }\n        _isShown() {\n            let element = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this._element;\n            return element.classList.contains(CLASS_NAME_SHOW$7);\n        }\n        // Private\n        _configAfterMerge(config) {\n            config.toggle = Boolean(config.toggle); // Coerce string values\n            config.parent = getElement(config.parent);\n            return config;\n        }\n        _getDimension() {\n            return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;\n        }\n        _initializeChildren() {\n            if (!this._config.parent) {\n                return;\n            }\n            const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);\n            for (const element of children){\n                const selected = SelectorEngine.getElementFromSelector(element);\n                if (selected) {\n                    this._addAriaAndCollapsedClass([\n                        element\n                    ], this._isShown(selected));\n                }\n            }\n        }\n        _getFirstLevelChildren(selector) {\n            const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);\n            // remove children if greater depth\n            return SelectorEngine.find(selector, this._config.parent).filter((element)=>!children.includes(element));\n        }\n        _addAriaAndCollapsedClass(triggerArray, isOpen) {\n            if (!triggerArray.length) {\n                return;\n            }\n            for (const element of triggerArray){\n                element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);\n                element.setAttribute(\"aria-expanded\", isOpen);\n            }\n        }\n        // Static\n        static jQueryInterface(config) {\n            const _config = {};\n            if (typeof config === \"string\" && /show|hide/.test(config)) {\n                _config.toggle = false;\n            }\n            return this.each(function() {\n                const data = Collapse.getOrCreateInstance(this, _config);\n                if (typeof config === \"string\") {\n                    if (typeof data[config] === \"undefined\") {\n                        throw new TypeError('No method named \"'.concat(config, '\"'));\n                    }\n                    data[config]();\n                }\n            });\n        }\n        constructor(element, config){\n            super(element, config);\n            this._isTransitioning = false;\n            this._triggerArray = [];\n            const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);\n            for (const elem of toggleList){\n                const selector = SelectorEngine.getSelectorFromElement(elem);\n                const filterElement = SelectorEngine.find(selector).filter((foundElement)=>foundElement === this._element);\n                if (selector !== null && filterElement.length) {\n                    this._triggerArray.push(elem);\n                }\n            }\n            this._initializeChildren();\n            if (!this._config.parent) {\n                this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());\n            }\n            if (this._config.toggle) {\n                this.toggle();\n            }\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {\n        // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n        if (event.target.tagName === \"A\" || event.delegateTarget && event.delegateTarget.tagName === \"A\") {\n            event.preventDefault();\n        }\n        for (const element of SelectorEngine.getMultipleElementsFromSelector(this)){\n            Collapse.getOrCreateInstance(element, {\n                toggle: false\n            }).toggle();\n        }\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Collapse);\n    var top = \"top\";\n    var bottom = \"bottom\";\n    var right = \"right\";\n    var left = \"left\";\n    var auto = \"auto\";\n    var basePlacements = [\n        top,\n        bottom,\n        right,\n        left\n    ];\n    var start = \"start\";\n    var end = \"end\";\n    var clippingParents = \"clippingParents\";\n    var viewport = \"viewport\";\n    var popper = \"popper\";\n    var reference = \"reference\";\n    var variationPlacements = /*#__PURE__*/ basePlacements.reduce(function(acc, placement) {\n        return acc.concat([\n            placement + \"-\" + start,\n            placement + \"-\" + end\n        ]);\n    }, []);\n    var placements = /*#__PURE__*/ [].concat(basePlacements, [\n        auto\n    ]).reduce(function(acc, placement) {\n        return acc.concat([\n            placement,\n            placement + \"-\" + start,\n            placement + \"-\" + end\n        ]);\n    }, []); // modifiers that need to read the DOM\n    var beforeRead = \"beforeRead\";\n    var read = \"read\";\n    var afterRead = \"afterRead\"; // pure-logic modifiers\n    var beforeMain = \"beforeMain\";\n    var main = \"main\";\n    var afterMain = \"afterMain\"; // modifier with the purpose to write to the DOM (or write into a framework state)\n    var beforeWrite = \"beforeWrite\";\n    var write = \"write\";\n    var afterWrite = \"afterWrite\";\n    var modifierPhases = [\n        beforeRead,\n        read,\n        afterRead,\n        beforeMain,\n        main,\n        afterMain,\n        beforeWrite,\n        write,\n        afterWrite\n    ];\n    function getNodeName(element) {\n        return element ? (element.nodeName || \"\").toLowerCase() : null;\n    }\n    function getWindow(node) {\n        if (node == null) {\n            return window;\n        }\n        if (node.toString() !== \"[object Window]\") {\n            var ownerDocument = node.ownerDocument;\n            return ownerDocument ? ownerDocument.defaultView || window : window;\n        }\n        return node;\n    }\n    function isElement(node) {\n        var OwnElement = getWindow(node).Element;\n        return node instanceof OwnElement || node instanceof Element;\n    }\n    function isHTMLElement(node) {\n        var OwnElement = getWindow(node).HTMLElement;\n        return node instanceof OwnElement || node instanceof HTMLElement;\n    }\n    function isShadowRoot(node) {\n        // IE 11 has no ShadowRoot\n        if (typeof ShadowRoot === \"undefined\") {\n            return false;\n        }\n        var OwnElement = getWindow(node).ShadowRoot;\n        return node instanceof OwnElement || node instanceof ShadowRoot;\n    }\n    // and applies them to the HTMLElements such as popper and arrow\n    function applyStyles(_ref) {\n        var state = _ref.state;\n        Object.keys(state.elements).forEach(function(name) {\n            var style = state.styles[name] || {};\n            var attributes = state.attributes[name] || {};\n            var element = state.elements[name]; // arrow is optional + virtual elements\n            if (!isHTMLElement(element) || !getNodeName(element)) {\n                return;\n            } // Flow doesn't support to extend this property, but it's the most\n            // effective way to apply styles to an HTMLElement\n            // $FlowFixMe[cannot-write]\n            Object.assign(element.style, style);\n            Object.keys(attributes).forEach(function(name) {\n                var value = attributes[name];\n                if (value === false) {\n                    element.removeAttribute(name);\n                } else {\n                    element.setAttribute(name, value === true ? \"\" : value);\n                }\n            });\n        });\n    }\n    function effect$2(_ref2) {\n        var state = _ref2.state;\n        var initialStyles = {\n            popper: {\n                position: state.options.strategy,\n                left: \"0\",\n                top: \"0\",\n                margin: \"0\"\n            },\n            arrow: {\n                position: \"absolute\"\n            },\n            reference: {}\n        };\n        Object.assign(state.elements.popper.style, initialStyles.popper);\n        state.styles = initialStyles;\n        if (state.elements.arrow) {\n            Object.assign(state.elements.arrow.style, initialStyles.arrow);\n        }\n        return function() {\n            Object.keys(state.elements).forEach(function(name) {\n                var element = state.elements[name];\n                var attributes = state.attributes[name] || {};\n                var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n                var style = styleProperties.reduce(function(style, property) {\n                    style[property] = \"\";\n                    return style;\n                }, {}); // arrow is optional + virtual elements\n                if (!isHTMLElement(element) || !getNodeName(element)) {\n                    return;\n                }\n                Object.assign(element.style, style);\n                Object.keys(attributes).forEach(function(attribute) {\n                    element.removeAttribute(attribute);\n                });\n            });\n        };\n    } // eslint-disable-next-line import/no-unused-modules\n    const applyStyles$1 = {\n        name: \"applyStyles\",\n        enabled: true,\n        phase: \"write\",\n        fn: applyStyles,\n        effect: effect$2,\n        requires: [\n            \"computeStyles\"\n        ]\n    };\n    function getBasePlacement(placement) {\n        return placement.split(\"-\")[0];\n    }\n    var max = Math.max;\n    var min = Math.min;\n    var round = Math.round;\n    function getUAString() {\n        var uaData = navigator.userAgentData;\n        if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {\n            return uaData.brands.map(function(item) {\n                return item.brand + \"/\" + item.version;\n            }).join(\" \");\n        }\n        return navigator.userAgent;\n    }\n    function isLayoutViewport() {\n        return !/^((?!chrome|android).)*safari/i.test(getUAString());\n    }\n    function getBoundingClientRect(element, includeScale, isFixedStrategy) {\n        if (includeScale === void 0) {\n            includeScale = false;\n        }\n        if (isFixedStrategy === void 0) {\n            isFixedStrategy = false;\n        }\n        var clientRect = element.getBoundingClientRect();\n        var scaleX = 1;\n        var scaleY = 1;\n        if (includeScale && isHTMLElement(element)) {\n            scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n            scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n        }\n        var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;\n        var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n        var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n        var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n        var width = clientRect.width / scaleX;\n        var height = clientRect.height / scaleY;\n        return {\n            width: width,\n            height: height,\n            top: y,\n            right: x + width,\n            bottom: y + height,\n            left: x,\n            x: x,\n            y: y\n        };\n    }\n    // means it doesn't take into account transforms.\n    function getLayoutRect(element) {\n        var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n        // Fixes https://github.com/popperjs/popper-core/issues/1223\n        var width = element.offsetWidth;\n        var height = element.offsetHeight;\n        if (Math.abs(clientRect.width - width) <= 1) {\n            width = clientRect.width;\n        }\n        if (Math.abs(clientRect.height - height) <= 1) {\n            height = clientRect.height;\n        }\n        return {\n            x: element.offsetLeft,\n            y: element.offsetTop,\n            width: width,\n            height: height\n        };\n    }\n    function contains(parent, child) {\n        var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n        if (parent.contains(child)) {\n            return true;\n        } else if (rootNode && isShadowRoot(rootNode)) {\n            var next = child;\n            do {\n                if (next && parent.isSameNode(next)) {\n                    return true;\n                } // $FlowFixMe[prop-missing]: need a better way to handle this...\n                next = next.parentNode || next.host;\n            }while (next);\n        } // Give up, the result is false\n        return false;\n    }\n    function getComputedStyle$1(element) {\n        return getWindow(element).getComputedStyle(element);\n    }\n    function isTableElement(element) {\n        return [\n            \"table\",\n            \"td\",\n            \"th\"\n        ].indexOf(getNodeName(element)) >= 0;\n    }\n    function getDocumentElement(element) {\n        // $FlowFixMe[incompatible-return]: assume body is always available\n        return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;\n    }\n    function getParentNode(element) {\n        if (getNodeName(element) === \"html\") {\n            return element;\n        }\n        return(// $FlowFixMe[incompatible-return]\n        // $FlowFixMe[prop-missing]\n        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n        element.parentNode || (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n        // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n        getDocumentElement(element) // fallback\n        );\n    }\n    function getTrueOffsetParent(element) {\n        if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n        getComputedStyle$1(element).position === \"fixed\") {\n            return null;\n        }\n        return element.offsetParent;\n    } // `.offsetParent` reports `null` for fixed elements, while absolute elements\n    // return the containing block\n    function getContainingBlock(element) {\n        var isFirefox = /firefox/i.test(getUAString());\n        var isIE = /Trident/i.test(getUAString());\n        if (isIE && isHTMLElement(element)) {\n            // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n            var elementCss = getComputedStyle$1(element);\n            if (elementCss.position === \"fixed\") {\n                return null;\n            }\n        }\n        var currentNode = getParentNode(element);\n        if (isShadowRoot(currentNode)) {\n            currentNode = currentNode.host;\n        }\n        while(isHTMLElement(currentNode) && [\n            \"html\",\n            \"body\"\n        ].indexOf(getNodeName(currentNode)) < 0){\n            var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n            // create a containing block.\n            // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n            if (css.transform !== \"none\" || css.perspective !== \"none\" || css.contain === \"paint\" || [\n                \"transform\",\n                \"perspective\"\n            ].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === \"filter\" || isFirefox && css.filter && css.filter !== \"none\") {\n                return currentNode;\n            } else {\n                currentNode = currentNode.parentNode;\n            }\n        }\n        return null;\n    } // Gets the closest ancestor positioned element. Handles some edge cases,\n    // such as table ancestors and cross browser bugs.\n    function getOffsetParent(element) {\n        var window1 = getWindow(element);\n        var offsetParent = getTrueOffsetParent(element);\n        while(offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === \"static\"){\n            offsetParent = getTrueOffsetParent(offsetParent);\n        }\n        if (offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle$1(offsetParent).position === \"static\")) {\n            return window1;\n        }\n        return offsetParent || getContainingBlock(element) || window1;\n    }\n    function getMainAxisFromPlacement(placement) {\n        return [\n            \"top\",\n            \"bottom\"\n        ].indexOf(placement) >= 0 ? \"x\" : \"y\";\n    }\n    function within(min$1, value, max$1) {\n        return max(min$1, min(value, max$1));\n    }\n    function withinMaxClamp(min, value, max) {\n        var v = within(min, value, max);\n        return v > max ? max : v;\n    }\n    function getFreshSideObject() {\n        return {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n        };\n    }\n    function mergePaddingObject(paddingObject) {\n        return Object.assign({}, getFreshSideObject(), paddingObject);\n    }\n    function expandToHashMap(value, keys) {\n        return keys.reduce(function(hashMap, key) {\n            hashMap[key] = value;\n            return hashMap;\n        }, {});\n    }\n    var toPaddingObject = function toPaddingObject(padding, state) {\n        padding = typeof padding === \"function\" ? padding(Object.assign({}, state.rects, {\n            placement: state.placement\n        })) : padding;\n        return mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n    };\n    function arrow(_ref) {\n        var _state$modifiersData$;\n        var state = _ref.state, name = _ref.name, options = _ref.options;\n        var arrowElement = state.elements.arrow;\n        var popperOffsets = state.modifiersData.popperOffsets;\n        var basePlacement = getBasePlacement(state.placement);\n        var axis = getMainAxisFromPlacement(basePlacement);\n        var isVertical = [\n            left,\n            right\n        ].indexOf(basePlacement) >= 0;\n        var len = isVertical ? \"height\" : \"width\";\n        if (!arrowElement || !popperOffsets) {\n            return;\n        }\n        var paddingObject = toPaddingObject(options.padding, state);\n        var arrowRect = getLayoutRect(arrowElement);\n        var minProp = axis === \"y\" ? top : left;\n        var maxProp = axis === \"y\" ? bottom : right;\n        var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n        var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n        var arrowOffsetParent = getOffsetParent(arrowElement);\n        var clientSize = arrowOffsetParent ? axis === \"y\" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n        var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n        // outside of the popper bounds\n        var min = paddingObject[minProp];\n        var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n        var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n        var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n        var axisProp = axis;\n        state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n    }\n    function effect$1(_ref2) {\n        var state = _ref2.state, options = _ref2.options;\n        var _options$element = options.element, arrowElement = _options$element === void 0 ? \"[data-popper-arrow]\" : _options$element;\n        if (arrowElement == null) {\n            return;\n        } // CSS selector\n        if (typeof arrowElement === \"string\") {\n            arrowElement = state.elements.popper.querySelector(arrowElement);\n            if (!arrowElement) {\n                return;\n            }\n        }\n        if (!contains(state.elements.popper, arrowElement)) {\n            return;\n        }\n        state.elements.arrow = arrowElement;\n    } // eslint-disable-next-line import/no-unused-modules\n    const arrow$1 = {\n        name: \"arrow\",\n        enabled: true,\n        phase: \"main\",\n        fn: arrow,\n        effect: effect$1,\n        requires: [\n            \"popperOffsets\"\n        ],\n        requiresIfExists: [\n            \"preventOverflow\"\n        ]\n    };\n    function getVariation(placement) {\n        return placement.split(\"-\")[1];\n    }\n    var unsetSides = {\n        top: \"auto\",\n        right: \"auto\",\n        bottom: \"auto\",\n        left: \"auto\"\n    }; // Round the offsets to the nearest suitable subpixel based on the DPR.\n    // Zooming can change the DPR, but it seems to report a value that will\n    // cleanly divide the values into the appropriate subpixels.\n    function roundOffsetsByDPR(_ref, win) {\n        var x = _ref.x, y = _ref.y;\n        var dpr = win.devicePixelRatio || 1;\n        return {\n            x: round(x * dpr) / dpr || 0,\n            y: round(y * dpr) / dpr || 0\n        };\n    }\n    function mapToStyles(_ref2) {\n        var _Object$assign2;\n        var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;\n        var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;\n        var _ref3 = typeof roundOffsets === \"function\" ? roundOffsets({\n            x: x,\n            y: y\n        }) : {\n            x: x,\n            y: y\n        };\n        x = _ref3.x;\n        y = _ref3.y;\n        var hasX = offsets.hasOwnProperty(\"x\");\n        var hasY = offsets.hasOwnProperty(\"y\");\n        var sideX = left;\n        var sideY = top;\n        var win = window;\n        if (adaptive) {\n            var offsetParent = getOffsetParent(popper);\n            var heightProp = \"clientHeight\";\n            var widthProp = \"clientWidth\";\n            if (offsetParent === getWindow(popper)) {\n                offsetParent = getDocumentElement(popper);\n                if (getComputedStyle$1(offsetParent).position !== \"static\" && position === \"absolute\") {\n                    heightProp = \"scrollHeight\";\n                    widthProp = \"scrollWidth\";\n                }\n            } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n            offsetParent = offsetParent;\n            if (placement === top || (placement === left || placement === right) && variation === end) {\n                sideY = bottom;\n                var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];\n                y -= offsetY - popperRect.height;\n                y *= gpuAcceleration ? 1 : -1;\n            }\n            if (placement === left || (placement === top || placement === bottom) && variation === end) {\n                sideX = right;\n                var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];\n                x -= offsetX - popperRect.width;\n                x *= gpuAcceleration ? 1 : -1;\n            }\n        }\n        var commonStyles = Object.assign({\n            position: position\n        }, adaptive && unsetSides);\n        var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n            x: x,\n            y: y\n        }, getWindow(popper)) : {\n            x: x,\n            y: y\n        };\n        x = _ref4.x;\n        y = _ref4.y;\n        if (gpuAcceleration) {\n            var _Object$assign;\n            return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? \"0\" : \"\", _Object$assign[sideX] = hasX ? \"0\" : \"\", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n        }\n        return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : \"\", _Object$assign2[sideX] = hasX ? x + \"px\" : \"\", _Object$assign2.transform = \"\", _Object$assign2));\n    }\n    function computeStyles(_ref5) {\n        var state = _ref5.state, options = _ref5.options;\n        var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n        var commonStyles = {\n            placement: getBasePlacement(state.placement),\n            variation: getVariation(state.placement),\n            popper: state.elements.popper,\n            popperRect: state.rects.popper,\n            gpuAcceleration: gpuAcceleration,\n            isFixed: state.options.strategy === \"fixed\"\n        };\n        if (state.modifiersData.popperOffsets != null) {\n            state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n                offsets: state.modifiersData.popperOffsets,\n                position: state.options.strategy,\n                adaptive: adaptive,\n                roundOffsets: roundOffsets\n            })));\n        }\n        if (state.modifiersData.arrow != null) {\n            state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n                offsets: state.modifiersData.arrow,\n                position: \"absolute\",\n                adaptive: false,\n                roundOffsets: roundOffsets\n            })));\n        }\n        state.attributes.popper = Object.assign({}, state.attributes.popper, {\n            \"data-popper-placement\": state.placement\n        });\n    } // eslint-disable-next-line import/no-unused-modules\n    const computeStyles$1 = {\n        name: \"computeStyles\",\n        enabled: true,\n        phase: \"beforeWrite\",\n        fn: computeStyles,\n        data: {}\n    };\n    var passive = {\n        passive: true\n    };\n    function effect(_ref) {\n        var state = _ref.state, instance = _ref.instance, options = _ref.options;\n        var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;\n        var window1 = getWindow(state.elements.popper);\n        var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n        if (scroll) {\n            scrollParents.forEach(function(scrollParent) {\n                scrollParent.addEventListener(\"scroll\", instance.update, passive);\n            });\n        }\n        if (resize) {\n            window1.addEventListener(\"resize\", instance.update, passive);\n        }\n        return function() {\n            if (scroll) {\n                scrollParents.forEach(function(scrollParent) {\n                    scrollParent.removeEventListener(\"scroll\", instance.update, passive);\n                });\n            }\n            if (resize) {\n                window1.removeEventListener(\"resize\", instance.update, passive);\n            }\n        };\n    } // eslint-disable-next-line import/no-unused-modules\n    const eventListeners = {\n        name: \"eventListeners\",\n        enabled: true,\n        phase: \"write\",\n        fn: function fn() {},\n        effect: effect,\n        data: {}\n    };\n    var hash$1 = {\n        left: \"right\",\n        right: \"left\",\n        bottom: \"top\",\n        top: \"bottom\"\n    };\n    function getOppositePlacement(placement) {\n        return placement.replace(/left|right|bottom|top/g, function(matched) {\n            return hash$1[matched];\n        });\n    }\n    var hash = {\n        start: \"end\",\n        end: \"start\"\n    };\n    function getOppositeVariationPlacement(placement) {\n        return placement.replace(/start|end/g, function(matched) {\n            return hash[matched];\n        });\n    }\n    function getWindowScroll(node) {\n        var win = getWindow(node);\n        var scrollLeft = win.pageXOffset;\n        var scrollTop = win.pageYOffset;\n        return {\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop\n        };\n    }\n    function getWindowScrollBarX(element) {\n        // If <html> has a CSS width greater than the viewport, then this will be\n        // incorrect for RTL.\n        // Popper 1 is broken in this case and never had a bug report so let's assume\n        // it's not an issue. I don't think anyone ever specifies width on <html>\n        // anyway.\n        // Browsers where the left scrollbar doesn't cause an issue report `0` for\n        // this (e.g. Edge 2019, IE11, Safari)\n        return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n    }\n    function getViewportRect(element, strategy) {\n        var win = getWindow(element);\n        var html = getDocumentElement(element);\n        var visualViewport = win.visualViewport;\n        var width = html.clientWidth;\n        var height = html.clientHeight;\n        var x = 0;\n        var y = 0;\n        if (visualViewport) {\n            width = visualViewport.width;\n            height = visualViewport.height;\n            var layoutViewport = isLayoutViewport();\n            if (layoutViewport || !layoutViewport && strategy === \"fixed\") {\n                x = visualViewport.offsetLeft;\n                y = visualViewport.offsetTop;\n            }\n        }\n        return {\n            width: width,\n            height: height,\n            x: x + getWindowScrollBarX(element),\n            y: y\n        };\n    }\n    // of the `<html>` and `<body>` rect bounds if horizontally scrollable\n    function getDocumentRect(element) {\n        var _element$ownerDocumen;\n        var html = getDocumentElement(element);\n        var winScroll = getWindowScroll(element);\n        var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n        var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n        var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n        var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n        var y = -winScroll.scrollTop;\n        if (getComputedStyle$1(body || html).direction === \"rtl\") {\n            x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n        }\n        return {\n            width: width,\n            height: height,\n            x: x,\n            y: y\n        };\n    }\n    function isScrollParent(element) {\n        // Firefox wants us to check `-x` and `-y` variations as well\n        var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;\n        return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n    }\n    function getScrollParent(node) {\n        if ([\n            \"html\",\n            \"body\",\n            \"#document\"\n        ].indexOf(getNodeName(node)) >= 0) {\n            // $FlowFixMe[incompatible-return]: assume body is always available\n            return node.ownerDocument.body;\n        }\n        if (isHTMLElement(node) && isScrollParent(node)) {\n            return node;\n        }\n        return getScrollParent(getParentNode(node));\n    }\n    /*\n  given a DOM element, return the list of all scroll parents, up the list of ancesors\n  until we get to the top window object. This list is what we attach scroll listeners\n  to, because if any of these parent elements scroll, we'll need to re-calculate the\n  reference element's position.\n  */ function listScrollParents(element, list) {\n        var _element$ownerDocumen;\n        if (list === void 0) {\n            list = [];\n        }\n        var scrollParent = getScrollParent(element);\n        var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n        var win = getWindow(scrollParent);\n        var target = isBody ? [\n            win\n        ].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n        var updatedList = list.concat(target);\n        return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));\n    }\n    function rectToClientRect(rect) {\n        return Object.assign({}, rect, {\n            left: rect.x,\n            top: rect.y,\n            right: rect.x + rect.width,\n            bottom: rect.y + rect.height\n        });\n    }\n    function getInnerBoundingClientRect(element, strategy) {\n        var rect = getBoundingClientRect(element, false, strategy === \"fixed\");\n        rect.top = rect.top + element.clientTop;\n        rect.left = rect.left + element.clientLeft;\n        rect.bottom = rect.top + element.clientHeight;\n        rect.right = rect.left + element.clientWidth;\n        rect.width = element.clientWidth;\n        rect.height = element.clientHeight;\n        rect.x = rect.left;\n        rect.y = rect.top;\n        return rect;\n    }\n    function getClientRectFromMixedType(element, clippingParent, strategy) {\n        return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n    } // A \"clipping parent\" is an overflowable container with the characteristic of\n    // clipping (or hiding) overflowing elements with a position different from\n    // `initial`\n    function getClippingParents(element) {\n        var clippingParents = listScrollParents(getParentNode(element));\n        var canEscapeClipping = [\n            \"absolute\",\n            \"fixed\"\n        ].indexOf(getComputedStyle$1(element).position) >= 0;\n        var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n        if (!isElement(clipperElement)) {\n            return [];\n        } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n        return clippingParents.filter(function(clippingParent) {\n            return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== \"body\";\n        });\n    } // Gets the maximum area that the element is visible in due to any number of\n    // clipping parents\n    function getClippingRect(element, boundary, rootBoundary, strategy) {\n        var mainClippingParents = boundary === \"clippingParents\" ? getClippingParents(element) : [].concat(boundary);\n        var clippingParents = [].concat(mainClippingParents, [\n            rootBoundary\n        ]);\n        var firstClippingParent = clippingParents[0];\n        var clippingRect = clippingParents.reduce(function(accRect, clippingParent) {\n            var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n            accRect.top = max(rect.top, accRect.top);\n            accRect.right = min(rect.right, accRect.right);\n            accRect.bottom = min(rect.bottom, accRect.bottom);\n            accRect.left = max(rect.left, accRect.left);\n            return accRect;\n        }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n        clippingRect.width = clippingRect.right - clippingRect.left;\n        clippingRect.height = clippingRect.bottom - clippingRect.top;\n        clippingRect.x = clippingRect.left;\n        clippingRect.y = clippingRect.top;\n        return clippingRect;\n    }\n    function computeOffsets(_ref) {\n        var reference = _ref.reference, element = _ref.element, placement = _ref.placement;\n        var basePlacement = placement ? getBasePlacement(placement) : null;\n        var variation = placement ? getVariation(placement) : null;\n        var commonX = reference.x + reference.width / 2 - element.width / 2;\n        var commonY = reference.y + reference.height / 2 - element.height / 2;\n        var offsets;\n        switch(basePlacement){\n            case top:\n                offsets = {\n                    x: commonX,\n                    y: reference.y - element.height\n                };\n                break;\n            case bottom:\n                offsets = {\n                    x: commonX,\n                    y: reference.y + reference.height\n                };\n                break;\n            case right:\n                offsets = {\n                    x: reference.x + reference.width,\n                    y: commonY\n                };\n                break;\n            case left:\n                offsets = {\n                    x: reference.x - element.width,\n                    y: commonY\n                };\n                break;\n            default:\n                offsets = {\n                    x: reference.x,\n                    y: reference.y\n                };\n        }\n        var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n        if (mainAxis != null) {\n            var len = mainAxis === \"y\" ? \"height\" : \"width\";\n            switch(variation){\n                case start:\n                    offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n                    break;\n                case end:\n                    offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n                    break;\n            }\n        }\n        return offsets;\n    }\n    function detectOverflow(state, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;\n        var paddingObject = mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n        var altContext = elementContext === popper ? reference : popper;\n        var popperRect = state.rects.popper;\n        var element = state.elements[altBoundary ? altContext : elementContext];\n        var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\n        var referenceClientRect = getBoundingClientRect(state.elements.reference);\n        var popperOffsets = computeOffsets({\n            reference: referenceClientRect,\n            element: popperRect,\n            strategy: \"absolute\",\n            placement: placement\n        });\n        var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n        var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n        // 0 or negative = within the clipping rect\n        var overflowOffsets = {\n            top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n            bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n            left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n            right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n        };\n        var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n        if (elementContext === popper && offsetData) {\n            var offset = offsetData[placement];\n            Object.keys(overflowOffsets).forEach(function(key) {\n                var multiply = [\n                    right,\n                    bottom\n                ].indexOf(key) >= 0 ? 1 : -1;\n                var axis = [\n                    top,\n                    bottom\n                ].indexOf(key) >= 0 ? \"y\" : \"x\";\n                overflowOffsets[key] += offset[axis] * multiply;\n            });\n        }\n        return overflowOffsets;\n    }\n    function computeAutoPlacement(state, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n        var variation = getVariation(placement);\n        var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement) {\n            return getVariation(placement) === variation;\n        }) : basePlacements;\n        var allowedPlacements = placements$1.filter(function(placement) {\n            return allowedAutoPlacements.indexOf(placement) >= 0;\n        });\n        if (allowedPlacements.length === 0) {\n            allowedPlacements = placements$1;\n        } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n        var overflows = allowedPlacements.reduce(function(acc, placement) {\n            acc[placement] = detectOverflow(state, {\n                placement: placement,\n                boundary: boundary,\n                rootBoundary: rootBoundary,\n                padding: padding\n            })[getBasePlacement(placement)];\n            return acc;\n        }, {});\n        return Object.keys(overflows).sort(function(a, b) {\n            return overflows[a] - overflows[b];\n        });\n    }\n    function getExpandedFallbackPlacements(placement) {\n        if (getBasePlacement(placement) === auto) {\n            return [];\n        }\n        var oppositePlacement = getOppositePlacement(placement);\n        return [\n            getOppositeVariationPlacement(placement),\n            oppositePlacement,\n            getOppositeVariationPlacement(oppositePlacement)\n        ];\n    }\n    function flip(_ref) {\n        var state = _ref.state, options = _ref.options, name = _ref.name;\n        if (state.modifiersData[name]._skip) {\n            return;\n        }\n        var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;\n        var preferredPlacement = state.options.placement;\n        var basePlacement = getBasePlacement(preferredPlacement);\n        var isBasePlacement = basePlacement === preferredPlacement;\n        var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [\n            getOppositePlacement(preferredPlacement)\n        ] : getExpandedFallbackPlacements(preferredPlacement));\n        var placements = [\n            preferredPlacement\n        ].concat(fallbackPlacements).reduce(function(acc, placement) {\n            return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n                placement: placement,\n                boundary: boundary,\n                rootBoundary: rootBoundary,\n                padding: padding,\n                flipVariations: flipVariations,\n                allowedAutoPlacements: allowedAutoPlacements\n            }) : placement);\n        }, []);\n        var referenceRect = state.rects.reference;\n        var popperRect = state.rects.popper;\n        var checksMap = new Map();\n        var makeFallbackChecks = true;\n        var firstFittingPlacement = placements[0];\n        for(var i = 0; i < placements.length; i++){\n            var placement = placements[i];\n            var _basePlacement = getBasePlacement(placement);\n            var isStartVariation = getVariation(placement) === start;\n            var isVertical = [\n                top,\n                bottom\n            ].indexOf(_basePlacement) >= 0;\n            var len = isVertical ? \"width\" : \"height\";\n            var overflow = detectOverflow(state, {\n                placement: placement,\n                boundary: boundary,\n                rootBoundary: rootBoundary,\n                altBoundary: altBoundary,\n                padding: padding\n            });\n            var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n            if (referenceRect[len] > popperRect[len]) {\n                mainVariationSide = getOppositePlacement(mainVariationSide);\n            }\n            var altVariationSide = getOppositePlacement(mainVariationSide);\n            var checks = [];\n            if (checkMainAxis) {\n                checks.push(overflow[_basePlacement] <= 0);\n            }\n            if (checkAltAxis) {\n                checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n            }\n            if (checks.every(function(check) {\n                return check;\n            })) {\n                firstFittingPlacement = placement;\n                makeFallbackChecks = false;\n                break;\n            }\n            checksMap.set(placement, checks);\n        }\n        if (makeFallbackChecks) {\n            // `2` may be desired in some cases  research later\n            var numberOfChecks = flipVariations ? 3 : 1;\n            var _loop = function _loop(_i) {\n                var fittingPlacement = placements.find(function(placement) {\n                    var checks = checksMap.get(placement);\n                    if (checks) {\n                        return checks.slice(0, _i).every(function(check) {\n                            return check;\n                        });\n                    }\n                });\n                if (fittingPlacement) {\n                    firstFittingPlacement = fittingPlacement;\n                    return \"break\";\n                }\n            };\n            for(var _i = numberOfChecks; _i > 0; _i--){\n                var _ret = _loop(_i);\n                if (_ret === \"break\") break;\n            }\n        }\n        if (state.placement !== firstFittingPlacement) {\n            state.modifiersData[name]._skip = true;\n            state.placement = firstFittingPlacement;\n            state.reset = true;\n        }\n    } // eslint-disable-next-line import/no-unused-modules\n    const flip$1 = {\n        name: \"flip\",\n        enabled: true,\n        phase: \"main\",\n        fn: flip,\n        requiresIfExists: [\n            \"offset\"\n        ],\n        data: {\n            _skip: false\n        }\n    };\n    function getSideOffsets(overflow, rect, preventedOffsets) {\n        if (preventedOffsets === void 0) {\n            preventedOffsets = {\n                x: 0,\n                y: 0\n            };\n        }\n        return {\n            top: overflow.top - rect.height - preventedOffsets.y,\n            right: overflow.right - rect.width + preventedOffsets.x,\n            bottom: overflow.bottom - rect.height + preventedOffsets.y,\n            left: overflow.left - rect.width - preventedOffsets.x\n        };\n    }\n    function isAnySideFullyClipped(overflow) {\n        return [\n            top,\n            right,\n            bottom,\n            left\n        ].some(function(side) {\n            return overflow[side] >= 0;\n        });\n    }\n    function hide(_ref) {\n        var state = _ref.state, name = _ref.name;\n        var referenceRect = state.rects.reference;\n        var popperRect = state.rects.popper;\n        var preventedOffsets = state.modifiersData.preventOverflow;\n        var referenceOverflow = detectOverflow(state, {\n            elementContext: \"reference\"\n        });\n        var popperAltOverflow = detectOverflow(state, {\n            altBoundary: true\n        });\n        var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n        var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n        var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n        var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n        state.modifiersData[name] = {\n            referenceClippingOffsets: referenceClippingOffsets,\n            popperEscapeOffsets: popperEscapeOffsets,\n            isReferenceHidden: isReferenceHidden,\n            hasPopperEscaped: hasPopperEscaped\n        };\n        state.attributes.popper = Object.assign({}, state.attributes.popper, {\n            \"data-popper-reference-hidden\": isReferenceHidden,\n            \"data-popper-escaped\": hasPopperEscaped\n        });\n    } // eslint-disable-next-line import/no-unused-modules\n    const hide$1 = {\n        name: \"hide\",\n        enabled: true,\n        phase: \"main\",\n        requiresIfExists: [\n            \"preventOverflow\"\n        ],\n        fn: hide\n    };\n    function distanceAndSkiddingToXY(placement, rects, offset) {\n        var basePlacement = getBasePlacement(placement);\n        var invertDistance = [\n            left,\n            top\n        ].indexOf(basePlacement) >= 0 ? -1 : 1;\n        var _ref = typeof offset === \"function\" ? offset(Object.assign({}, rects, {\n            placement: placement\n        })) : offset, skidding = _ref[0], distance = _ref[1];\n        skidding = skidding || 0;\n        distance = (distance || 0) * invertDistance;\n        return [\n            left,\n            right\n        ].indexOf(basePlacement) >= 0 ? {\n            x: distance,\n            y: skidding\n        } : {\n            x: skidding,\n            y: distance\n        };\n    }\n    function offset(_ref2) {\n        var state = _ref2.state, options = _ref2.options, name = _ref2.name;\n        var _options$offset = options.offset, offset = _options$offset === void 0 ? [\n            0,\n            0\n        ] : _options$offset;\n        var data = placements.reduce(function(acc, placement) {\n            acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n            return acc;\n        }, {});\n        var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;\n        if (state.modifiersData.popperOffsets != null) {\n            state.modifiersData.popperOffsets.x += x;\n            state.modifiersData.popperOffsets.y += y;\n        }\n        state.modifiersData[name] = data;\n    } // eslint-disable-next-line import/no-unused-modules\n    const offset$1 = {\n        name: \"offset\",\n        enabled: true,\n        phase: \"main\",\n        requires: [\n            \"popperOffsets\"\n        ],\n        fn: offset\n    };\n    function popperOffsets(_ref) {\n        var state = _ref.state, name = _ref.name;\n        // Offsets are the actual position the popper needs to have to be\n        // properly positioned near its reference element\n        // This is the most basic placement, and will be adjusted by\n        // the modifiers in the next step\n        state.modifiersData[name] = computeOffsets({\n            reference: state.rects.reference,\n            element: state.rects.popper,\n            strategy: \"absolute\",\n            placement: state.placement\n        });\n    } // eslint-disable-next-line import/no-unused-modules\n    const popperOffsets$1 = {\n        name: \"popperOffsets\",\n        enabled: true,\n        phase: \"read\",\n        fn: popperOffsets,\n        data: {}\n    };\n    function getAltAxis(axis) {\n        return axis === \"x\" ? \"y\" : \"x\";\n    }\n    function preventOverflow(_ref) {\n        var state = _ref.state, options = _ref.options, name = _ref.name;\n        var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n        var overflow = detectOverflow(state, {\n            boundary: boundary,\n            rootBoundary: rootBoundary,\n            padding: padding,\n            altBoundary: altBoundary\n        });\n        var basePlacement = getBasePlacement(state.placement);\n        var variation = getVariation(state.placement);\n        var isBasePlacement = !variation;\n        var mainAxis = getMainAxisFromPlacement(basePlacement);\n        var altAxis = getAltAxis(mainAxis);\n        var popperOffsets = state.modifiersData.popperOffsets;\n        var referenceRect = state.rects.reference;\n        var popperRect = state.rects.popper;\n        var tetherOffsetValue = typeof tetherOffset === \"function\" ? tetherOffset(Object.assign({}, state.rects, {\n            placement: state.placement\n        })) : tetherOffset;\n        var normalizedTetherOffsetValue = typeof tetherOffsetValue === \"number\" ? {\n            mainAxis: tetherOffsetValue,\n            altAxis: tetherOffsetValue\n        } : Object.assign({\n            mainAxis: 0,\n            altAxis: 0\n        }, tetherOffsetValue);\n        var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n        var data = {\n            x: 0,\n            y: 0\n        };\n        if (!popperOffsets) {\n            return;\n        }\n        if (checkMainAxis) {\n            var _offsetModifierState$;\n            var mainSide = mainAxis === \"y\" ? top : left;\n            var altSide = mainAxis === \"y\" ? bottom : right;\n            var len = mainAxis === \"y\" ? \"height\" : \"width\";\n            var offset = popperOffsets[mainAxis];\n            var min$1 = offset + overflow[mainSide];\n            var max$1 = offset - overflow[altSide];\n            var additive = tether ? -popperRect[len] / 2 : 0;\n            var minLen = variation === start ? referenceRect[len] : popperRect[len];\n            var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n            // outside the reference bounds\n            var arrowElement = state.elements.arrow;\n            var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n                width: 0,\n                height: 0\n            };\n            var arrowPaddingObject = state.modifiersData[\"arrow#persistent\"] ? state.modifiersData[\"arrow#persistent\"].padding : getFreshSideObject();\n            var arrowPaddingMin = arrowPaddingObject[mainSide];\n            var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n            // to include its full size in the calculation. If the reference is small\n            // and near the edge of a boundary, the popper can overflow even if the\n            // reference is not overflowing as well (e.g. virtual elements with no\n            // width or height)\n            var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n            var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n            var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n            var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n            var clientOffset = arrowOffsetParent ? mainAxis === \"y\" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n            var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n            var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n            var tetherMax = offset + maxOffset - offsetModifierValue;\n            var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n            popperOffsets[mainAxis] = preventedOffset;\n            data[mainAxis] = preventedOffset - offset;\n        }\n        if (checkAltAxis) {\n            var _offsetModifierState$2;\n            var _mainSide = mainAxis === \"x\" ? top : left;\n            var _altSide = mainAxis === \"x\" ? bottom : right;\n            var _offset = popperOffsets[altAxis];\n            var _len = altAxis === \"y\" ? \"height\" : \"width\";\n            var _min = _offset + overflow[_mainSide];\n            var _max = _offset - overflow[_altSide];\n            var isOriginSide = [\n                top,\n                left\n            ].indexOf(basePlacement) !== -1;\n            var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n            var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n            var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n            var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n            popperOffsets[altAxis] = _preventedOffset;\n            data[altAxis] = _preventedOffset - _offset;\n        }\n        state.modifiersData[name] = data;\n    } // eslint-disable-next-line import/no-unused-modules\n    const preventOverflow$1 = {\n        name: \"preventOverflow\",\n        enabled: true,\n        phase: \"main\",\n        fn: preventOverflow,\n        requiresIfExists: [\n            \"offset\"\n        ]\n    };\n    function getHTMLElementScroll(element) {\n        return {\n            scrollLeft: element.scrollLeft,\n            scrollTop: element.scrollTop\n        };\n    }\n    function getNodeScroll(node) {\n        if (node === getWindow(node) || !isHTMLElement(node)) {\n            return getWindowScroll(node);\n        } else {\n            return getHTMLElementScroll(node);\n        }\n    }\n    function isElementScaled(element) {\n        var rect = element.getBoundingClientRect();\n        var scaleX = round(rect.width) / element.offsetWidth || 1;\n        var scaleY = round(rect.height) / element.offsetHeight || 1;\n        return scaleX !== 1 || scaleY !== 1;\n    } // Returns the composite rect of an element relative to its offsetParent.\n    // Composite means it takes into account transforms as well as layout.\n    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n        if (isFixed === void 0) {\n            isFixed = false;\n        }\n        var isOffsetParentAnElement = isHTMLElement(offsetParent);\n        var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n        var documentElement = getDocumentElement(offsetParent);\n        var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n        var scroll = {\n            scrollLeft: 0,\n            scrollTop: 0\n        };\n        var offsets = {\n            x: 0,\n            y: 0\n        };\n        if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n            if (getNodeName(offsetParent) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n            isScrollParent(documentElement)) {\n                scroll = getNodeScroll(offsetParent);\n            }\n            if (isHTMLElement(offsetParent)) {\n                offsets = getBoundingClientRect(offsetParent, true);\n                offsets.x += offsetParent.clientLeft;\n                offsets.y += offsetParent.clientTop;\n            } else if (documentElement) {\n                offsets.x = getWindowScrollBarX(documentElement);\n            }\n        }\n        return {\n            x: rect.left + scroll.scrollLeft - offsets.x,\n            y: rect.top + scroll.scrollTop - offsets.y,\n            width: rect.width,\n            height: rect.height\n        };\n    }\n    function order(modifiers) {\n        var map = new Map();\n        var visited = new Set();\n        var result = [];\n        modifiers.forEach(function(modifier) {\n            map.set(modifier.name, modifier);\n        }); // On visiting object, check for its dependencies and visit them recursively\n        function sort(modifier) {\n            visited.add(modifier.name);\n            var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n            requires.forEach(function(dep) {\n                if (!visited.has(dep)) {\n                    var depModifier = map.get(dep);\n                    if (depModifier) {\n                        sort(depModifier);\n                    }\n                }\n            });\n            result.push(modifier);\n        }\n        modifiers.forEach(function(modifier) {\n            if (!visited.has(modifier.name)) {\n                // check for visited object\n                sort(modifier);\n            }\n        });\n        return result;\n    }\n    function orderModifiers(modifiers) {\n        // order based on dependencies\n        var orderedModifiers = order(modifiers); // order based on phase\n        return modifierPhases.reduce(function(acc, phase) {\n            return acc.concat(orderedModifiers.filter(function(modifier) {\n                return modifier.phase === phase;\n            }));\n        }, []);\n    }\n    function debounce(fn) {\n        var pending;\n        return function() {\n            if (!pending) {\n                pending = new Promise(function(resolve) {\n                    Promise.resolve().then(function() {\n                        pending = undefined;\n                        resolve(fn());\n                    });\n                });\n            }\n            return pending;\n        };\n    }\n    function mergeByName(modifiers) {\n        var merged = modifiers.reduce(function(merged, current) {\n            var existing = merged[current.name];\n            merged[current.name] = existing ? Object.assign({}, existing, current, {\n                options: Object.assign({}, existing.options, current.options),\n                data: Object.assign({}, existing.data, current.data)\n            }) : current;\n            return merged;\n        }, {}); // IE11 does not support Object.values\n        return Object.keys(merged).map(function(key) {\n            return merged[key];\n        });\n    }\n    var DEFAULT_OPTIONS = {\n        placement: \"bottom\",\n        modifiers: [],\n        strategy: \"absolute\"\n    };\n    function areValidElements() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return !args.some(function(element) {\n            return !(element && typeof element.getBoundingClientRect === \"function\");\n        });\n    }\n    function popperGenerator(generatorOptions) {\n        if (generatorOptions === void 0) {\n            generatorOptions = {};\n        }\n        var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n        return function createPopper(reference, popper, options) {\n            if (options === void 0) {\n                options = defaultOptions;\n            }\n            var state = {\n                placement: \"bottom\",\n                orderedModifiers: [],\n                options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n                modifiersData: {},\n                elements: {\n                    reference: reference,\n                    popper: popper\n                },\n                attributes: {},\n                styles: {}\n            };\n            var effectCleanupFns = [];\n            var isDestroyed = false;\n            var instance = {\n                state: state,\n                setOptions: function setOptions(setOptionsAction) {\n                    var options = typeof setOptionsAction === \"function\" ? setOptionsAction(state.options) : setOptionsAction;\n                    cleanupModifierEffects();\n                    state.options = Object.assign({}, defaultOptions, state.options, options);\n                    state.scrollParents = {\n                        reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n                        popper: listScrollParents(popper)\n                    }; // Orders the modifiers based on their dependencies and `phase`\n                    // properties\n                    var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n                    state.orderedModifiers = orderedModifiers.filter(function(m) {\n                        return m.enabled;\n                    });\n                    runModifierEffects();\n                    return instance.update();\n                },\n                // Sync update  it will always be executed, even if not necessary. This\n                // is useful for low frequency updates where sync behavior simplifies the\n                // logic.\n                // For high frequency updates (e.g. `resize` and `scroll` events), always\n                // prefer the async Popper#update method\n                forceUpdate: function forceUpdate() {\n                    if (isDestroyed) {\n                        return;\n                    }\n                    var _state$elements = state.elements, reference = _state$elements.reference, popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n                    // anymore\n                    if (!areValidElements(reference, popper)) {\n                        return;\n                    } // Store the reference and popper rects to be read by modifiers\n                    state.rects = {\n                        reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === \"fixed\"),\n                        popper: getLayoutRect(popper)\n                    }; // Modifiers have the ability to reset the current update cycle. The\n                    // most common use case for this is the `flip` modifier changing the\n                    // placement, which then needs to re-run all the modifiers, because the\n                    // logic was previously ran for the previous placement and is therefore\n                    // stale/incorrect\n                    state.reset = false;\n                    state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n                    // is filled with the initial data specified by the modifier. This means\n                    // it doesn't persist and is fresh on each update.\n                    // To ensure persistent data, use `${name}#persistent`\n                    state.orderedModifiers.forEach(function(modifier) {\n                        return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n                    });\n                    for(var index = 0; index < state.orderedModifiers.length; index++){\n                        if (state.reset === true) {\n                            state.reset = false;\n                            index = -1;\n                            continue;\n                        }\n                        var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;\n                        if (typeof fn === \"function\") {\n                            state = fn({\n                                state: state,\n                                options: _options,\n                                name: name,\n                                instance: instance\n                            }) || state;\n                        }\n                    }\n                },\n                // Async and optimistically optimized update  it will not be executed if\n                // not necessary (debounced to run at most once-per-tick)\n                update: debounce(function() {\n                    return new Promise(function(resolve) {\n                        instance.forceUpdate();\n                        resolve(state);\n                    });\n                }),\n                destroy: function destroy() {\n                    cleanupModifierEffects();\n                    isDestroyed = true;\n                }\n            };\n            if (!areValidElements(reference, popper)) {\n                return instance;\n            }\n            instance.setOptions(options).then(function(state) {\n                if (!isDestroyed && options.onFirstUpdate) {\n                    options.onFirstUpdate(state);\n                }\n            }); // Modifiers have the ability to execute arbitrary code before the first\n            // update cycle runs. They will be executed in the same order as the update\n            // cycle. This is useful when a modifier adds some persistent data that\n            // other modifiers need to use, but the modifier is run after the dependent\n            // one.\n            function runModifierEffects() {\n                state.orderedModifiers.forEach(function(_ref) {\n                    var name = _ref.name, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, effect = _ref.effect;\n                    if (typeof effect === \"function\") {\n                        var cleanupFn = effect({\n                            state: state,\n                            name: name,\n                            instance: instance,\n                            options: options\n                        });\n                        var noopFn = function noopFn() {};\n                        effectCleanupFns.push(cleanupFn || noopFn);\n                    }\n                });\n            }\n            function cleanupModifierEffects() {\n                effectCleanupFns.forEach(function(fn) {\n                    return fn();\n                });\n                effectCleanupFns = [];\n            }\n            return instance;\n        };\n    }\n    var createPopper$2 = /*#__PURE__*/ popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n    var defaultModifiers$1 = [\n        eventListeners,\n        popperOffsets$1,\n        computeStyles$1,\n        applyStyles$1\n    ];\n    var createPopper$1 = /*#__PURE__*/ popperGenerator({\n        defaultModifiers: defaultModifiers$1\n    }); // eslint-disable-next-line import/no-unused-modules\n    var defaultModifiers = [\n        eventListeners,\n        popperOffsets$1,\n        computeStyles$1,\n        applyStyles$1,\n        offset$1,\n        flip$1,\n        preventOverflow$1,\n        arrow$1,\n        hide$1\n    ];\n    var createPopper = /*#__PURE__*/ popperGenerator({\n        defaultModifiers: defaultModifiers\n    }); // eslint-disable-next-line import/no-unused-modules\n    const Popper = /*#__PURE__*/ Object.freeze(/*#__PURE__*/ Object.defineProperty({\n        __proto__: null,\n        afterMain,\n        afterRead,\n        afterWrite,\n        applyStyles: applyStyles$1,\n        arrow: arrow$1,\n        auto,\n        basePlacements,\n        beforeMain,\n        beforeRead,\n        beforeWrite,\n        bottom,\n        clippingParents,\n        computeStyles: computeStyles$1,\n        createPopper,\n        createPopperBase: createPopper$2,\n        createPopperLite: createPopper$1,\n        detectOverflow,\n        end,\n        eventListeners,\n        flip: flip$1,\n        hide: hide$1,\n        left,\n        main,\n        modifierPhases,\n        offset: offset$1,\n        placements,\n        popper,\n        popperGenerator,\n        popperOffsets: popperOffsets$1,\n        preventOverflow: preventOverflow$1,\n        read,\n        reference,\n        right,\n        start,\n        top,\n        variationPlacements,\n        viewport,\n        write\n    }, Symbol.toStringTag, {\n        value: \"Module\"\n    }));\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap dropdown.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$a = \"dropdown\";\n    const DATA_KEY$6 = \"bs.dropdown\";\n    const EVENT_KEY$6 = \".\".concat(DATA_KEY$6);\n    const DATA_API_KEY$3 = \".data-api\";\n    const ESCAPE_KEY$2 = \"Escape\";\n    const TAB_KEY$1 = \"Tab\";\n    const ARROW_UP_KEY$1 = \"ArrowUp\";\n    const ARROW_DOWN_KEY$1 = \"ArrowDown\";\n    const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\n    const EVENT_HIDE$5 = \"hide\".concat(EVENT_KEY$6);\n    const EVENT_HIDDEN$5 = \"hidden\".concat(EVENT_KEY$6);\n    const EVENT_SHOW$5 = \"show\".concat(EVENT_KEY$6);\n    const EVENT_SHOWN$5 = \"shown\".concat(EVENT_KEY$6);\n    const EVENT_CLICK_DATA_API$3 = \"click\".concat(EVENT_KEY$6).concat(DATA_API_KEY$3);\n    const EVENT_KEYDOWN_DATA_API = \"keydown\".concat(EVENT_KEY$6).concat(DATA_API_KEY$3);\n    const EVENT_KEYUP_DATA_API = \"keyup\".concat(EVENT_KEY$6).concat(DATA_API_KEY$3);\n    const CLASS_NAME_SHOW$6 = \"show\";\n    const CLASS_NAME_DROPUP = \"dropup\";\n    const CLASS_NAME_DROPEND = \"dropend\";\n    const CLASS_NAME_DROPSTART = \"dropstart\";\n    const CLASS_NAME_DROPUP_CENTER = \"dropup-center\";\n    const CLASS_NAME_DROPDOWN_CENTER = \"dropdown-center\";\n    const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle=\"dropdown\"]:not(.disabled):not(:disabled)';\n    const SELECTOR_DATA_TOGGLE_SHOWN = \"\".concat(SELECTOR_DATA_TOGGLE$3, \".\").concat(CLASS_NAME_SHOW$6);\n    const SELECTOR_MENU = \".dropdown-menu\";\n    const SELECTOR_NAVBAR = \".navbar\";\n    const SELECTOR_NAVBAR_NAV = \".navbar-nav\";\n    const SELECTOR_VISIBLE_ITEMS = \".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)\";\n    const PLACEMENT_TOP = isRTL() ? \"top-end\" : \"top-start\";\n    const PLACEMENT_TOPEND = isRTL() ? \"top-start\" : \"top-end\";\n    const PLACEMENT_BOTTOM = isRTL() ? \"bottom-end\" : \"bottom-start\";\n    const PLACEMENT_BOTTOMEND = isRTL() ? \"bottom-start\" : \"bottom-end\";\n    const PLACEMENT_RIGHT = isRTL() ? \"left-start\" : \"right-start\";\n    const PLACEMENT_LEFT = isRTL() ? \"right-start\" : \"left-start\";\n    const PLACEMENT_TOPCENTER = \"top\";\n    const PLACEMENT_BOTTOMCENTER = \"bottom\";\n    const Default$9 = {\n        autoClose: true,\n        boundary: \"clippingParents\",\n        display: \"dynamic\",\n        offset: [\n            0,\n            2\n        ],\n        popperConfig: null,\n        reference: \"toggle\"\n    };\n    const DefaultType$9 = {\n        autoClose: \"(boolean|string)\",\n        boundary: \"(string|element)\",\n        display: \"string\",\n        offset: \"(array|string|function)\",\n        popperConfig: \"(null|object|function)\",\n        reference: \"(string|element|object)\"\n    };\n    /**\n   * Class definition\n   */ class Dropdown extends BaseComponent {\n        // Getters\n        static get Default() {\n            return Default$9;\n        }\n        static get DefaultType() {\n            return DefaultType$9;\n        }\n        static get NAME() {\n            return NAME$a;\n        }\n        // Public\n        toggle() {\n            return this._isShown() ? this.hide() : this.show();\n        }\n        show() {\n            if (isDisabled(this._element) || this._isShown()) {\n                return;\n            }\n            const relatedTarget = {\n                relatedTarget: this._element\n            };\n            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);\n            if (showEvent.defaultPrevented) {\n                return;\n            }\n            this._createPopper();\n            // If this is a touch-enabled device we add extra\n            // empty mouseover listeners to the body's immediate children;\n            // only needed because of broken event delegation on iOS\n            // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n            if (\"ontouchstart\" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {\n                for (const element of [].concat(...document.body.children)){\n                    EventHandler.on(element, \"mouseover\", noop);\n                }\n            }\n            this._element.focus();\n            this._element.setAttribute(\"aria-expanded\", true);\n            this._menu.classList.add(CLASS_NAME_SHOW$6);\n            this._element.classList.add(CLASS_NAME_SHOW$6);\n            EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);\n        }\n        hide() {\n            if (isDisabled(this._element) || !this._isShown()) {\n                return;\n            }\n            const relatedTarget = {\n                relatedTarget: this._element\n            };\n            this._completeHide(relatedTarget);\n        }\n        dispose() {\n            if (this._popper) {\n                this._popper.destroy();\n            }\n            super.dispose();\n        }\n        update() {\n            this._inNavbar = this._detectNavbar();\n            if (this._popper) {\n                this._popper.update();\n            }\n        }\n        // Private\n        _completeHide(relatedTarget) {\n            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            // If this is a touch-enabled device we remove the extra\n            // empty mouseover listeners we added for iOS support\n            if (\"ontouchstart\" in document.documentElement) {\n                for (const element of [].concat(...document.body.children)){\n                    EventHandler.off(element, \"mouseover\", noop);\n                }\n            }\n            if (this._popper) {\n                this._popper.destroy();\n            }\n            this._menu.classList.remove(CLASS_NAME_SHOW$6);\n            this._element.classList.remove(CLASS_NAME_SHOW$6);\n            this._element.setAttribute(\"aria-expanded\", \"false\");\n            Manipulator.removeDataAttribute(this._menu, \"popper\");\n            EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);\n        }\n        _getConfig(config) {\n            config = super._getConfig(config);\n            if (typeof config.reference === \"object\" && !isElement$1(config.reference) && typeof config.reference.getBoundingClientRect !== \"function\") {\n                // Popper virtual elements require a getBoundingClientRect method\n                throw new TypeError(\"\".concat(NAME$a.toUpperCase(), ': Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.'));\n            }\n            return config;\n        }\n        _createPopper() {\n            if (typeof Popper === \"undefined\") {\n                throw new TypeError(\"Bootstrap's dropdowns require Popper (https://popper.js.org)\");\n            }\n            let referenceElement = this._element;\n            if (this._config.reference === \"parent\") {\n                referenceElement = this._parent;\n            } else if (isElement$1(this._config.reference)) {\n                referenceElement = getElement(this._config.reference);\n            } else if (typeof this._config.reference === \"object\") {\n                referenceElement = this._config.reference;\n            }\n            const popperConfig = this._getPopperConfig();\n            this._popper = createPopper(referenceElement, this._menu, popperConfig);\n        }\n        _isShown() {\n            return this._menu.classList.contains(CLASS_NAME_SHOW$6);\n        }\n        _getPlacement() {\n            const parentDropdown = this._parent;\n            if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\n                return PLACEMENT_RIGHT;\n            }\n            if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\n                return PLACEMENT_LEFT;\n            }\n            if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {\n                return PLACEMENT_TOPCENTER;\n            }\n            if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {\n                return PLACEMENT_BOTTOMCENTER;\n            }\n            // We need to trim the value because custom properties can also include spaces\n            const isEnd = getComputedStyle(this._menu).getPropertyValue(\"--bs-position\").trim() === \"end\";\n            if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\n                return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n            }\n            return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\n        }\n        _detectNavbar() {\n            return this._element.closest(SELECTOR_NAVBAR) !== null;\n        }\n        _getOffset() {\n            const { offset } = this._config;\n            if (typeof offset === \"string\") {\n                return offset.split(\",\").map((value)=>Number.parseInt(value, 10));\n            }\n            if (typeof offset === \"function\") {\n                return (popperData)=>offset(popperData, this._element);\n            }\n            return offset;\n        }\n        _getPopperConfig() {\n            const defaultBsPopperConfig = {\n                placement: this._getPlacement(),\n                modifiers: [\n                    {\n                        name: \"preventOverflow\",\n                        options: {\n                            boundary: this._config.boundary\n                        }\n                    },\n                    {\n                        name: \"offset\",\n                        options: {\n                            offset: this._getOffset()\n                        }\n                    }\n                ]\n            };\n            // Disable Popper if we have a static display or Dropdown is in Navbar\n            if (this._inNavbar || this._config.display === \"static\") {\n                Manipulator.setDataAttribute(this._menu, \"popper\", \"static\"); // TODO: v6 remove\n                defaultBsPopperConfig.modifiers = [\n                    {\n                        name: \"applyStyles\",\n                        enabled: false\n                    }\n                ];\n            }\n            return {\n                ...defaultBsPopperConfig,\n                ...execute(this._config.popperConfig, [\n                    defaultBsPopperConfig\n                ])\n            };\n        }\n        _selectMenuItem(param) {\n            let { key, target } = param;\n            const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element)=>isVisible(element));\n            if (!items.length) {\n                return;\n            }\n            // if target isn't included in items (e.g. when expanding the dropdown)\n            // allow cycling to get the last item in case key equals ARROW_UP_KEY\n            getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Dropdown.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (typeof data[config] === \"undefined\") {\n                    throw new TypeError('No method named \"'.concat(config, '\"'));\n                }\n                data[config]();\n            });\n        }\n        static clearMenus(event) {\n            if (event.button === RIGHT_MOUSE_BUTTON || event.type === \"keyup\" && event.key !== TAB_KEY$1) {\n                return;\n            }\n            const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);\n            for (const toggle of openToggles){\n                const context = Dropdown.getInstance(toggle);\n                if (!context || context._config.autoClose === false) {\n                    continue;\n                }\n                const composedPath = event.composedPath();\n                const isMenuTarget = composedPath.includes(context._menu);\n                if (composedPath.includes(context._element) || context._config.autoClose === \"inside\" && !isMenuTarget || context._config.autoClose === \"outside\" && isMenuTarget) {\n                    continue;\n                }\n                // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu\n                if (context._menu.contains(event.target) && (event.type === \"keyup\" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {\n                    continue;\n                }\n                const relatedTarget = {\n                    relatedTarget: context._element\n                };\n                if (event.type === \"click\") {\n                    relatedTarget.clickEvent = event;\n                }\n                context._completeHide(relatedTarget);\n            }\n        }\n        static dataApiKeydownHandler(event) {\n            // If not an UP | DOWN | ESCAPE key => not a dropdown command\n            // If input/textarea && if key is other than ESCAPE => not a dropdown command\n            const isInput = /input|textarea/i.test(event.target.tagName);\n            const isEscapeEvent = event.key === ESCAPE_KEY$2;\n            const isUpOrDownEvent = [\n                ARROW_UP_KEY$1,\n                ARROW_DOWN_KEY$1\n            ].includes(event.key);\n            if (!isUpOrDownEvent && !isEscapeEvent) {\n                return;\n            }\n            if (isInput && !isEscapeEvent) {\n                return;\n            }\n            event.preventDefault();\n            // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/\n            const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);\n            const instance = Dropdown.getOrCreateInstance(getToggleButton);\n            if (isUpOrDownEvent) {\n                event.stopPropagation();\n                instance.show();\n                instance._selectMenuItem(event);\n                return;\n            }\n            if (instance._isShown()) {\n                // else is escape and we check if it is shown\n                event.stopPropagation();\n                instance.hide();\n                getToggleButton.focus();\n            }\n        }\n        constructor(element, config){\n            super(element, config);\n            this._popper = null;\n            this._parent = this._element.parentNode; // dropdown wrapper\n            // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/\n            this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);\n            this._inNavbar = this._detectNavbar();\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);\n    EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);\n    EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);\n    EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);\n    EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {\n        event.preventDefault();\n        Dropdown.getOrCreateInstance(this).toggle();\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Dropdown);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/backdrop.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$9 = \"backdrop\";\n    const CLASS_NAME_FADE$4 = \"fade\";\n    const CLASS_NAME_SHOW$5 = \"show\";\n    const EVENT_MOUSEDOWN = \"mousedown.bs.\".concat(NAME$9);\n    const Default$8 = {\n        className: \"modal-backdrop\",\n        clickCallback: null,\n        isAnimated: false,\n        isVisible: true,\n        // if false, we use the backdrop helper without adding any element to the dom\n        rootElement: \"body\" // give the choice to place backdrop under different elements\n    };\n    const DefaultType$8 = {\n        className: \"string\",\n        clickCallback: \"(function|null)\",\n        isAnimated: \"boolean\",\n        isVisible: \"boolean\",\n        rootElement: \"(element|string)\"\n    };\n    /**\n   * Class definition\n   */ class Backdrop extends Config {\n        // Getters\n        static get Default() {\n            return Default$8;\n        }\n        static get DefaultType() {\n            return DefaultType$8;\n        }\n        static get NAME() {\n            return NAME$9;\n        }\n        // Public\n        show(callback) {\n            if (!this._config.isVisible) {\n                execute(callback);\n                return;\n            }\n            this._append();\n            const element = this._getElement();\n            if (this._config.isAnimated) {\n                reflow(element);\n            }\n            element.classList.add(CLASS_NAME_SHOW$5);\n            this._emulateAnimation(()=>{\n                execute(callback);\n            });\n        }\n        hide(callback) {\n            if (!this._config.isVisible) {\n                execute(callback);\n                return;\n            }\n            this._getElement().classList.remove(CLASS_NAME_SHOW$5);\n            this._emulateAnimation(()=>{\n                this.dispose();\n                execute(callback);\n            });\n        }\n        dispose() {\n            if (!this._isAppended) {\n                return;\n            }\n            EventHandler.off(this._element, EVENT_MOUSEDOWN);\n            this._element.remove();\n            this._isAppended = false;\n        }\n        // Private\n        _getElement() {\n            if (!this._element) {\n                const backdrop = document.createElement(\"div\");\n                backdrop.className = this._config.className;\n                if (this._config.isAnimated) {\n                    backdrop.classList.add(CLASS_NAME_FADE$4);\n                }\n                this._element = backdrop;\n            }\n            return this._element;\n        }\n        _configAfterMerge(config) {\n            // use getElement() with the default \"body\" to get a fresh Element on each instantiation\n            config.rootElement = getElement(config.rootElement);\n            return config;\n        }\n        _append() {\n            if (this._isAppended) {\n                return;\n            }\n            const element = this._getElement();\n            this._config.rootElement.append(element);\n            EventHandler.on(element, EVENT_MOUSEDOWN, ()=>{\n                execute(this._config.clickCallback);\n            });\n            this._isAppended = true;\n        }\n        _emulateAnimation(callback) {\n            executeAfterTransition(callback, this._getElement(), this._config.isAnimated);\n        }\n        constructor(config){\n            super();\n            this._config = this._getConfig(config);\n            this._isAppended = false;\n            this._element = null;\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/focustrap.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$8 = \"focustrap\";\n    const DATA_KEY$5 = \"bs.focustrap\";\n    const EVENT_KEY$5 = \".\".concat(DATA_KEY$5);\n    const EVENT_FOCUSIN$2 = \"focusin\".concat(EVENT_KEY$5);\n    const EVENT_KEYDOWN_TAB = \"keydown.tab\".concat(EVENT_KEY$5);\n    const TAB_KEY = \"Tab\";\n    const TAB_NAV_FORWARD = \"forward\";\n    const TAB_NAV_BACKWARD = \"backward\";\n    const Default$7 = {\n        autofocus: true,\n        trapElement: null // The element to trap focus inside of\n    };\n    const DefaultType$7 = {\n        autofocus: \"boolean\",\n        trapElement: \"element\"\n    };\n    /**\n   * Class definition\n   */ class FocusTrap extends Config {\n        // Getters\n        static get Default() {\n            return Default$7;\n        }\n        static get DefaultType() {\n            return DefaultType$7;\n        }\n        static get NAME() {\n            return NAME$8;\n        }\n        // Public\n        activate() {\n            if (this._isActive) {\n                return;\n            }\n            if (this._config.autofocus) {\n                this._config.trapElement.focus();\n            }\n            EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop\n            EventHandler.on(document, EVENT_FOCUSIN$2, (event)=>this._handleFocusin(event));\n            EventHandler.on(document, EVENT_KEYDOWN_TAB, (event)=>this._handleKeydown(event));\n            this._isActive = true;\n        }\n        deactivate() {\n            if (!this._isActive) {\n                return;\n            }\n            this._isActive = false;\n            EventHandler.off(document, EVENT_KEY$5);\n        }\n        // Private\n        _handleFocusin(event) {\n            const { trapElement } = this._config;\n            if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {\n                return;\n            }\n            const elements = SelectorEngine.focusableChildren(trapElement);\n            if (elements.length === 0) {\n                trapElement.focus();\n            } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {\n                elements[elements.length - 1].focus();\n            } else {\n                elements[0].focus();\n            }\n        }\n        _handleKeydown(event) {\n            if (event.key !== TAB_KEY) {\n                return;\n            }\n            this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;\n        }\n        constructor(config){\n            super();\n            this._config = this._getConfig(config);\n            this._isActive = false;\n            this._lastTabNavDirection = null;\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/scrollBar.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const SELECTOR_FIXED_CONTENT = \".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\";\n    const SELECTOR_STICKY_CONTENT = \".sticky-top\";\n    const PROPERTY_PADDING = \"padding-right\";\n    const PROPERTY_MARGIN = \"margin-right\";\n    /**\n   * Class definition\n   */ class ScrollBarHelper {\n        // Public\n        getWidth() {\n            // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\n            const documentWidth = document.documentElement.clientWidth;\n            return Math.abs(window.innerWidth - documentWidth);\n        }\n        hide() {\n            const width = this.getWidth();\n            this._disableOverFlow();\n            // give padding to element to balance the hidden scrollbar width\n            this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue)=>calculatedValue + width);\n            // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\n            this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue)=>calculatedValue + width);\n            this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue)=>calculatedValue - width);\n        }\n        reset() {\n            this._resetElementAttributes(this._element, \"overflow\");\n            this._resetElementAttributes(this._element, PROPERTY_PADDING);\n            this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);\n            this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);\n        }\n        isOverflowing() {\n            return this.getWidth() > 0;\n        }\n        // Private\n        _disableOverFlow() {\n            this._saveInitialAttribute(this._element, \"overflow\");\n            this._element.style.overflow = \"hidden\";\n        }\n        _setElementAttributes(selector, styleProperty, callback) {\n            const scrollbarWidth = this.getWidth();\n            const manipulationCallBack = (element)=>{\n                if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {\n                    return;\n                }\n                this._saveInitialAttribute(element, styleProperty);\n                const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);\n                element.style.setProperty(styleProperty, \"\".concat(callback(Number.parseFloat(calculatedValue)), \"px\"));\n            };\n            this._applyManipulationCallback(selector, manipulationCallBack);\n        }\n        _saveInitialAttribute(element, styleProperty) {\n            const actualValue = element.style.getPropertyValue(styleProperty);\n            if (actualValue) {\n                Manipulator.setDataAttribute(element, styleProperty, actualValue);\n            }\n        }\n        _resetElementAttributes(selector, styleProperty) {\n            const manipulationCallBack = (element)=>{\n                const value = Manipulator.getDataAttribute(element, styleProperty);\n                // We only want to remove the property if the value is `null`; the value can also be zero\n                if (value === null) {\n                    element.style.removeProperty(styleProperty);\n                    return;\n                }\n                Manipulator.removeDataAttribute(element, styleProperty);\n                element.style.setProperty(styleProperty, value);\n            };\n            this._applyManipulationCallback(selector, manipulationCallBack);\n        }\n        _applyManipulationCallback(selector, callBack) {\n            if (isElement$1(selector)) {\n                callBack(selector);\n                return;\n            }\n            for (const sel of SelectorEngine.find(selector, this._element)){\n                callBack(sel);\n            }\n        }\n        constructor(){\n            this._element = document.body;\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap modal.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$7 = \"modal\";\n    const DATA_KEY$4 = \"bs.modal\";\n    const EVENT_KEY$4 = \".\".concat(DATA_KEY$4);\n    const DATA_API_KEY$2 = \".data-api\";\n    const ESCAPE_KEY$1 = \"Escape\";\n    const EVENT_HIDE$4 = \"hide\".concat(EVENT_KEY$4);\n    const EVENT_HIDE_PREVENTED$1 = \"hidePrevented\".concat(EVENT_KEY$4);\n    const EVENT_HIDDEN$4 = \"hidden\".concat(EVENT_KEY$4);\n    const EVENT_SHOW$4 = \"show\".concat(EVENT_KEY$4);\n    const EVENT_SHOWN$4 = \"shown\".concat(EVENT_KEY$4);\n    const EVENT_RESIZE$1 = \"resize\".concat(EVENT_KEY$4);\n    const EVENT_CLICK_DISMISS = \"click.dismiss\".concat(EVENT_KEY$4);\n    const EVENT_MOUSEDOWN_DISMISS = \"mousedown.dismiss\".concat(EVENT_KEY$4);\n    const EVENT_KEYDOWN_DISMISS$1 = \"keydown.dismiss\".concat(EVENT_KEY$4);\n    const EVENT_CLICK_DATA_API$2 = \"click\".concat(EVENT_KEY$4).concat(DATA_API_KEY$2);\n    const CLASS_NAME_OPEN = \"modal-open\";\n    const CLASS_NAME_FADE$3 = \"fade\";\n    const CLASS_NAME_SHOW$4 = \"show\";\n    const CLASS_NAME_STATIC = \"modal-static\";\n    const OPEN_SELECTOR$1 = \".modal.show\";\n    const SELECTOR_DIALOG = \".modal-dialog\";\n    const SELECTOR_MODAL_BODY = \".modal-body\";\n    const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle=\"modal\"]';\n    const Default$6 = {\n        backdrop: true,\n        focus: true,\n        keyboard: true\n    };\n    const DefaultType$6 = {\n        backdrop: \"(boolean|string)\",\n        focus: \"boolean\",\n        keyboard: \"boolean\"\n    };\n    /**\n   * Class definition\n   */ class Modal extends BaseComponent {\n        // Getters\n        static get Default() {\n            return Default$6;\n        }\n        static get DefaultType() {\n            return DefaultType$6;\n        }\n        static get NAME() {\n            return NAME$7;\n        }\n        // Public\n        toggle(relatedTarget) {\n            return this._isShown ? this.hide() : this.show(relatedTarget);\n        }\n        show(relatedTarget) {\n            if (this._isShown || this._isTransitioning) {\n                return;\n            }\n            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {\n                relatedTarget\n            });\n            if (showEvent.defaultPrevented) {\n                return;\n            }\n            this._isShown = true;\n            this._isTransitioning = true;\n            this._scrollBar.hide();\n            document.body.classList.add(CLASS_NAME_OPEN);\n            this._adjustDialog();\n            this._backdrop.show(()=>this._showElement(relatedTarget));\n        }\n        hide() {\n            if (!this._isShown || this._isTransitioning) {\n                return;\n            }\n            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            this._isShown = false;\n            this._isTransitioning = true;\n            this._focustrap.deactivate();\n            this._element.classList.remove(CLASS_NAME_SHOW$4);\n            this._queueCallback(()=>this._hideModal(), this._element, this._isAnimated());\n        }\n        dispose() {\n            EventHandler.off(window, EVENT_KEY$4);\n            EventHandler.off(this._dialog, EVENT_KEY$4);\n            this._backdrop.dispose();\n            this._focustrap.deactivate();\n            super.dispose();\n        }\n        handleUpdate() {\n            this._adjustDialog();\n        }\n        // Private\n        _initializeBackDrop() {\n            return new Backdrop({\n                isVisible: Boolean(this._config.backdrop),\n                // 'static' option will be translated to true, and booleans will keep their value,\n                isAnimated: this._isAnimated()\n            });\n        }\n        _initializeFocusTrap() {\n            return new FocusTrap({\n                trapElement: this._element\n            });\n        }\n        _showElement(relatedTarget) {\n            // try to append dynamic modal\n            if (!document.body.contains(this._element)) {\n                document.body.append(this._element);\n            }\n            this._element.style.display = \"block\";\n            this._element.removeAttribute(\"aria-hidden\");\n            this._element.setAttribute(\"aria-modal\", true);\n            this._element.setAttribute(\"role\", \"dialog\");\n            this._element.scrollTop = 0;\n            const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\n            if (modalBody) {\n                modalBody.scrollTop = 0;\n            }\n            reflow(this._element);\n            this._element.classList.add(CLASS_NAME_SHOW$4);\n            const transitionComplete = ()=>{\n                if (this._config.focus) {\n                    this._focustrap.activate();\n                }\n                this._isTransitioning = false;\n                EventHandler.trigger(this._element, EVENT_SHOWN$4, {\n                    relatedTarget\n                });\n            };\n            this._queueCallback(transitionComplete, this._dialog, this._isAnimated());\n        }\n        _addEventListeners() {\n            EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event)=>{\n                if (event.key !== ESCAPE_KEY$1) {\n                    return;\n                }\n                if (this._config.keyboard) {\n                    this.hide();\n                    return;\n                }\n                this._triggerBackdropTransition();\n            });\n            EventHandler.on(window, EVENT_RESIZE$1, ()=>{\n                if (this._isShown && !this._isTransitioning) {\n                    this._adjustDialog();\n                }\n            });\n            EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event)=>{\n                // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks\n                EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2)=>{\n                    if (this._element !== event.target || this._element !== event2.target) {\n                        return;\n                    }\n                    if (this._config.backdrop === \"static\") {\n                        this._triggerBackdropTransition();\n                        return;\n                    }\n                    if (this._config.backdrop) {\n                        this.hide();\n                    }\n                });\n            });\n        }\n        _hideModal() {\n            this._element.style.display = \"none\";\n            this._element.setAttribute(\"aria-hidden\", true);\n            this._element.removeAttribute(\"aria-modal\");\n            this._element.removeAttribute(\"role\");\n            this._isTransitioning = false;\n            this._backdrop.hide(()=>{\n                document.body.classList.remove(CLASS_NAME_OPEN);\n                this._resetAdjustments();\n                this._scrollBar.reset();\n                EventHandler.trigger(this._element, EVENT_HIDDEN$4);\n            });\n        }\n        _isAnimated() {\n            return this._element.classList.contains(CLASS_NAME_FADE$3);\n        }\n        _triggerBackdropTransition() {\n            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n            const initialOverflowY = this._element.style.overflowY;\n            // return if the following background transition hasn't yet completed\n            if (initialOverflowY === \"hidden\" || this._element.classList.contains(CLASS_NAME_STATIC)) {\n                return;\n            }\n            if (!isModalOverflowing) {\n                this._element.style.overflowY = \"hidden\";\n            }\n            this._element.classList.add(CLASS_NAME_STATIC);\n            this._queueCallback(()=>{\n                this._element.classList.remove(CLASS_NAME_STATIC);\n                this._queueCallback(()=>{\n                    this._element.style.overflowY = initialOverflowY;\n                }, this._dialog);\n            }, this._dialog);\n            this._element.focus();\n        }\n        /**\n     * The following methods are used to handle overflowing modals\n     */ _adjustDialog() {\n            const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n            const scrollbarWidth = this._scrollBar.getWidth();\n            const isBodyOverflowing = scrollbarWidth > 0;\n            if (isBodyOverflowing && !isModalOverflowing) {\n                const property = isRTL() ? \"paddingLeft\" : \"paddingRight\";\n                this._element.style[property] = \"\".concat(scrollbarWidth, \"px\");\n            }\n            if (!isBodyOverflowing && isModalOverflowing) {\n                const property = isRTL() ? \"paddingRight\" : \"paddingLeft\";\n                this._element.style[property] = \"\".concat(scrollbarWidth, \"px\");\n            }\n        }\n        _resetAdjustments() {\n            this._element.style.paddingLeft = \"\";\n            this._element.style.paddingRight = \"\";\n        }\n        // Static\n        static jQueryInterface(config, relatedTarget) {\n            return this.each(function() {\n                const data = Modal.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (typeof data[config] === \"undefined\") {\n                    throw new TypeError('No method named \"'.concat(config, '\"'));\n                }\n                data[config](relatedTarget);\n            });\n        }\n        constructor(element, config){\n            super(element, config);\n            this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\n            this._backdrop = this._initializeBackDrop();\n            this._focustrap = this._initializeFocusTrap();\n            this._isShown = false;\n            this._isTransitioning = false;\n            this._scrollBar = new ScrollBarHelper();\n            this._addEventListeners();\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {\n        const target = SelectorEngine.getElementFromSelector(this);\n        if ([\n            \"A\",\n            \"AREA\"\n        ].includes(this.tagName)) {\n            event.preventDefault();\n        }\n        EventHandler.one(target, EVENT_SHOW$4, (showEvent)=>{\n            if (showEvent.defaultPrevented) {\n                // only register focus restorer if modal will actually get shown\n                return;\n            }\n            EventHandler.one(target, EVENT_HIDDEN$4, ()=>{\n                if (isVisible(this)) {\n                    this.focus();\n                }\n            });\n        });\n        // avoid conflict when clicking modal toggler while another one is open\n        const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);\n        if (alreadyOpen) {\n            Modal.getInstance(alreadyOpen).hide();\n        }\n        const data = Modal.getOrCreateInstance(target);\n        data.toggle(this);\n    });\n    enableDismissTrigger(Modal);\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Modal);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap offcanvas.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$6 = \"offcanvas\";\n    const DATA_KEY$3 = \"bs.offcanvas\";\n    const EVENT_KEY$3 = \".\".concat(DATA_KEY$3);\n    const DATA_API_KEY$1 = \".data-api\";\n    const EVENT_LOAD_DATA_API$2 = \"load\".concat(EVENT_KEY$3).concat(DATA_API_KEY$1);\n    const ESCAPE_KEY = \"Escape\";\n    const CLASS_NAME_SHOW$3 = \"show\";\n    const CLASS_NAME_SHOWING$1 = \"showing\";\n    const CLASS_NAME_HIDING = \"hiding\";\n    const CLASS_NAME_BACKDROP = \"offcanvas-backdrop\";\n    const OPEN_SELECTOR = \".offcanvas.show\";\n    const EVENT_SHOW$3 = \"show\".concat(EVENT_KEY$3);\n    const EVENT_SHOWN$3 = \"shown\".concat(EVENT_KEY$3);\n    const EVENT_HIDE$3 = \"hide\".concat(EVENT_KEY$3);\n    const EVENT_HIDE_PREVENTED = \"hidePrevented\".concat(EVENT_KEY$3);\n    const EVENT_HIDDEN$3 = \"hidden\".concat(EVENT_KEY$3);\n    const EVENT_RESIZE = \"resize\".concat(EVENT_KEY$3);\n    const EVENT_CLICK_DATA_API$1 = \"click\".concat(EVENT_KEY$3).concat(DATA_API_KEY$1);\n    const EVENT_KEYDOWN_DISMISS = \"keydown.dismiss\".concat(EVENT_KEY$3);\n    const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle=\"offcanvas\"]';\n    const Default$5 = {\n        backdrop: true,\n        keyboard: true,\n        scroll: false\n    };\n    const DefaultType$5 = {\n        backdrop: \"(boolean|string)\",\n        keyboard: \"boolean\",\n        scroll: \"boolean\"\n    };\n    /**\n   * Class definition\n   */ class Offcanvas extends BaseComponent {\n        // Getters\n        static get Default() {\n            return Default$5;\n        }\n        static get DefaultType() {\n            return DefaultType$5;\n        }\n        static get NAME() {\n            return NAME$6;\n        }\n        // Public\n        toggle(relatedTarget) {\n            return this._isShown ? this.hide() : this.show(relatedTarget);\n        }\n        show(relatedTarget) {\n            if (this._isShown) {\n                return;\n            }\n            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {\n                relatedTarget\n            });\n            if (showEvent.defaultPrevented) {\n                return;\n            }\n            this._isShown = true;\n            this._backdrop.show();\n            if (!this._config.scroll) {\n                new ScrollBarHelper().hide();\n            }\n            this._element.setAttribute(\"aria-modal\", true);\n            this._element.setAttribute(\"role\", \"dialog\");\n            this._element.classList.add(CLASS_NAME_SHOWING$1);\n            const completeCallBack = ()=>{\n                if (!this._config.scroll || this._config.backdrop) {\n                    this._focustrap.activate();\n                }\n                this._element.classList.add(CLASS_NAME_SHOW$3);\n                this._element.classList.remove(CLASS_NAME_SHOWING$1);\n                EventHandler.trigger(this._element, EVENT_SHOWN$3, {\n                    relatedTarget\n                });\n            };\n            this._queueCallback(completeCallBack, this._element, true);\n        }\n        hide() {\n            if (!this._isShown) {\n                return;\n            }\n            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            this._focustrap.deactivate();\n            this._element.blur();\n            this._isShown = false;\n            this._element.classList.add(CLASS_NAME_HIDING);\n            this._backdrop.hide();\n            const completeCallback = ()=>{\n                this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);\n                this._element.removeAttribute(\"aria-modal\");\n                this._element.removeAttribute(\"role\");\n                if (!this._config.scroll) {\n                    new ScrollBarHelper().reset();\n                }\n                EventHandler.trigger(this._element, EVENT_HIDDEN$3);\n            };\n            this._queueCallback(completeCallback, this._element, true);\n        }\n        dispose() {\n            this._backdrop.dispose();\n            this._focustrap.deactivate();\n            super.dispose();\n        }\n        // Private\n        _initializeBackDrop() {\n            const clickCallback = ()=>{\n                if (this._config.backdrop === \"static\") {\n                    EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n                    return;\n                }\n                this.hide();\n            };\n            // 'static' option will be translated to true, and booleans will keep their value\n            const isVisible = Boolean(this._config.backdrop);\n            return new Backdrop({\n                className: CLASS_NAME_BACKDROP,\n                isVisible,\n                isAnimated: true,\n                rootElement: this._element.parentNode,\n                clickCallback: isVisible ? clickCallback : null\n            });\n        }\n        _initializeFocusTrap() {\n            return new FocusTrap({\n                trapElement: this._element\n            });\n        }\n        _addEventListeners() {\n            EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event)=>{\n                if (event.key !== ESCAPE_KEY) {\n                    return;\n                }\n                if (this._config.keyboard) {\n                    this.hide();\n                    return;\n                }\n                EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n            });\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Offcanvas.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                    throw new TypeError('No method named \"'.concat(config, '\"'));\n                }\n                data[config](this);\n            });\n        }\n        constructor(element, config){\n            super(element, config);\n            this._isShown = false;\n            this._backdrop = this._initializeBackDrop();\n            this._focustrap = this._initializeFocusTrap();\n            this._addEventListeners();\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {\n        const target = SelectorEngine.getElementFromSelector(this);\n        if ([\n            \"A\",\n            \"AREA\"\n        ].includes(this.tagName)) {\n            event.preventDefault();\n        }\n        if (isDisabled(this)) {\n            return;\n        }\n        EventHandler.one(target, EVENT_HIDDEN$3, ()=>{\n            // focus on trigger when it is closed\n            if (isVisible(this)) {\n                this.focus();\n            }\n        });\n        // avoid conflict when clicking a toggler of an offcanvas, while another is open\n        const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);\n        if (alreadyOpen && alreadyOpen !== target) {\n            Offcanvas.getInstance(alreadyOpen).hide();\n        }\n        const data = Offcanvas.getOrCreateInstance(target);\n        data.toggle(this);\n    });\n    EventHandler.on(window, EVENT_LOAD_DATA_API$2, ()=>{\n        for (const selector of SelectorEngine.find(OPEN_SELECTOR)){\n            Offcanvas.getOrCreateInstance(selector).show();\n        }\n    });\n    EventHandler.on(window, EVENT_RESIZE, ()=>{\n        for (const element of SelectorEngine.find(\"[aria-modal][class*=show][class*=offcanvas-]\")){\n            if (getComputedStyle(element).position !== \"fixed\") {\n                Offcanvas.getOrCreateInstance(element).hide();\n            }\n        }\n    });\n    enableDismissTrigger(Offcanvas);\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Offcanvas);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/sanitizer.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ // js-docs-start allow-list\n    const ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\n    const DefaultAllowlist = {\n        // Global attributes allowed on any supplied element below.\n        \"*\": [\n            \"class\",\n            \"dir\",\n            \"id\",\n            \"lang\",\n            \"role\",\n            ARIA_ATTRIBUTE_PATTERN\n        ],\n        a: [\n            \"target\",\n            \"href\",\n            \"title\",\n            \"rel\"\n        ],\n        area: [],\n        b: [],\n        br: [],\n        col: [],\n        code: [],\n        dd: [],\n        div: [],\n        dl: [],\n        dt: [],\n        em: [],\n        hr: [],\n        h1: [],\n        h2: [],\n        h3: [],\n        h4: [],\n        h5: [],\n        h6: [],\n        i: [],\n        img: [\n            \"src\",\n            \"srcset\",\n            \"alt\",\n            \"title\",\n            \"width\",\n            \"height\"\n        ],\n        li: [],\n        ol: [],\n        p: [],\n        pre: [],\n        s: [],\n        small: [],\n        span: [],\n        sub: [],\n        sup: [],\n        strong: [],\n        u: [],\n        ul: []\n    };\n    // js-docs-end allow-list\n    const uriAttributes = new Set([\n        \"background\",\n        \"cite\",\n        \"href\",\n        \"itemtype\",\n        \"longdesc\",\n        \"poster\",\n        \"src\",\n        \"xlink:href\"\n    ]);\n    /**\n   * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation\n   * contexts.\n   *\n   * Shout-out to Angular https://github.com/angular/angular/blob/15.2.8/packages/core/src/sanitization/url_sanitizer.ts#L38\n   */ // eslint-disable-next-line unicorn/better-regex\n    const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;\n    const allowedAttribute = (attribute, allowedAttributeList)=>{\n        const attributeName = attribute.nodeName.toLowerCase();\n        if (allowedAttributeList.includes(attributeName)) {\n            if (uriAttributes.has(attributeName)) {\n                return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));\n            }\n            return true;\n        }\n        // Check if a regular expression validates the attribute.\n        return allowedAttributeList.filter((attributeRegex)=>attributeRegex instanceof RegExp).some((regex)=>regex.test(attributeName));\n    };\n    function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {\n        if (!unsafeHtml.length) {\n            return unsafeHtml;\n        }\n        if (sanitizeFunction && typeof sanitizeFunction === \"function\") {\n            return sanitizeFunction(unsafeHtml);\n        }\n        const domParser = new window.DOMParser();\n        const createdDocument = domParser.parseFromString(unsafeHtml, \"text/html\");\n        const elements = [].concat(...createdDocument.body.querySelectorAll(\"*\"));\n        for (const element of elements){\n            const elementName = element.nodeName.toLowerCase();\n            if (!Object.keys(allowList).includes(elementName)) {\n                element.remove();\n                continue;\n            }\n            const attributeList = [].concat(...element.attributes);\n            const allowedAttributes = [].concat(allowList[\"*\"] || [], allowList[elementName] || []);\n            for (const attribute of attributeList){\n                if (!allowedAttribute(attribute, allowedAttributes)) {\n                    element.removeAttribute(attribute.nodeName);\n                }\n            }\n        }\n        return createdDocument.body.innerHTML;\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/template-factory.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$5 = \"TemplateFactory\";\n    const Default$4 = {\n        allowList: DefaultAllowlist,\n        content: {},\n        // { selector : text ,  selector2 : text2 , }\n        extraClass: \"\",\n        html: false,\n        sanitize: true,\n        sanitizeFn: null,\n        template: \"<div></div>\"\n    };\n    const DefaultType$4 = {\n        allowList: \"object\",\n        content: \"object\",\n        extraClass: \"(string|function)\",\n        html: \"boolean\",\n        sanitize: \"boolean\",\n        sanitizeFn: \"(null|function)\",\n        template: \"string\"\n    };\n    const DefaultContentType = {\n        entry: \"(string|element|function|null)\",\n        selector: \"(string|element)\"\n    };\n    /**\n   * Class definition\n   */ class TemplateFactory extends Config {\n        // Getters\n        static get Default() {\n            return Default$4;\n        }\n        static get DefaultType() {\n            return DefaultType$4;\n        }\n        static get NAME() {\n            return NAME$5;\n        }\n        // Public\n        getContent() {\n            return Object.values(this._config.content).map((config)=>this._resolvePossibleFunction(config)).filter(Boolean);\n        }\n        hasContent() {\n            return this.getContent().length > 0;\n        }\n        changeContent(content) {\n            this._checkContent(content);\n            this._config.content = {\n                ...this._config.content,\n                ...content\n            };\n            return this;\n        }\n        toHtml() {\n            const templateWrapper = document.createElement(\"div\");\n            templateWrapper.innerHTML = this._maybeSanitize(this._config.template);\n            for (const [selector, text] of Object.entries(this._config.content)){\n                this._setContent(templateWrapper, text, selector);\n            }\n            const template = templateWrapper.children[0];\n            const extraClass = this._resolvePossibleFunction(this._config.extraClass);\n            if (extraClass) {\n                template.classList.add(...extraClass.split(\" \"));\n            }\n            return template;\n        }\n        // Private\n        _typeCheckConfig(config) {\n            super._typeCheckConfig(config);\n            this._checkContent(config.content);\n        }\n        _checkContent(arg) {\n            for (const [selector, content] of Object.entries(arg)){\n                super._typeCheckConfig({\n                    selector,\n                    entry: content\n                }, DefaultContentType);\n            }\n        }\n        _setContent(template, content, selector) {\n            const templateElement = SelectorEngine.findOne(selector, template);\n            if (!templateElement) {\n                return;\n            }\n            content = this._resolvePossibleFunction(content);\n            if (!content) {\n                templateElement.remove();\n                return;\n            }\n            if (isElement$1(content)) {\n                this._putElementInTemplate(getElement(content), templateElement);\n                return;\n            }\n            if (this._config.html) {\n                templateElement.innerHTML = this._maybeSanitize(content);\n                return;\n            }\n            templateElement.textContent = content;\n        }\n        _maybeSanitize(arg) {\n            return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;\n        }\n        _resolvePossibleFunction(arg) {\n            return execute(arg, [\n                this\n            ]);\n        }\n        _putElementInTemplate(element, templateElement) {\n            if (this._config.html) {\n                templateElement.innerHTML = \"\";\n                templateElement.append(element);\n                return;\n            }\n            templateElement.textContent = element.textContent;\n        }\n        constructor(config){\n            super();\n            this._config = this._getConfig(config);\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap tooltip.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$4 = \"tooltip\";\n    const DISALLOWED_ATTRIBUTES = new Set([\n        \"sanitize\",\n        \"allowList\",\n        \"sanitizeFn\"\n    ]);\n    const CLASS_NAME_FADE$2 = \"fade\";\n    const CLASS_NAME_MODAL = \"modal\";\n    const CLASS_NAME_SHOW$2 = \"show\";\n    const SELECTOR_TOOLTIP_INNER = \".tooltip-inner\";\n    const SELECTOR_MODAL = \".\".concat(CLASS_NAME_MODAL);\n    const EVENT_MODAL_HIDE = \"hide.bs.modal\";\n    const TRIGGER_HOVER = \"hover\";\n    const TRIGGER_FOCUS = \"focus\";\n    const TRIGGER_CLICK = \"click\";\n    const TRIGGER_MANUAL = \"manual\";\n    const EVENT_HIDE$2 = \"hide\";\n    const EVENT_HIDDEN$2 = \"hidden\";\n    const EVENT_SHOW$2 = \"show\";\n    const EVENT_SHOWN$2 = \"shown\";\n    const EVENT_INSERTED = \"inserted\";\n    const EVENT_CLICK$1 = \"click\";\n    const EVENT_FOCUSIN$1 = \"focusin\";\n    const EVENT_FOCUSOUT$1 = \"focusout\";\n    const EVENT_MOUSEENTER = \"mouseenter\";\n    const EVENT_MOUSELEAVE = \"mouseleave\";\n    const AttachmentMap = {\n        AUTO: \"auto\",\n        TOP: \"top\",\n        RIGHT: isRTL() ? \"left\" : \"right\",\n        BOTTOM: \"bottom\",\n        LEFT: isRTL() ? \"right\" : \"left\"\n    };\n    const Default$3 = {\n        allowList: DefaultAllowlist,\n        animation: true,\n        boundary: \"clippingParents\",\n        container: false,\n        customClass: \"\",\n        delay: 0,\n        fallbackPlacements: [\n            \"top\",\n            \"right\",\n            \"bottom\",\n            \"left\"\n        ],\n        html: false,\n        offset: [\n            0,\n            6\n        ],\n        placement: \"top\",\n        popperConfig: null,\n        sanitize: true,\n        sanitizeFn: null,\n        selector: false,\n        template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"tooltip-arrow\"></div>' + '<div class=\"tooltip-inner\"></div>' + \"</div>\",\n        title: \"\",\n        trigger: \"hover focus\"\n    };\n    const DefaultType$3 = {\n        allowList: \"object\",\n        animation: \"boolean\",\n        boundary: \"(string|element)\",\n        container: \"(string|element|boolean)\",\n        customClass: \"(string|function)\",\n        delay: \"(number|object)\",\n        fallbackPlacements: \"array\",\n        html: \"boolean\",\n        offset: \"(array|string|function)\",\n        placement: \"(string|function)\",\n        popperConfig: \"(null|object|function)\",\n        sanitize: \"boolean\",\n        sanitizeFn: \"(null|function)\",\n        selector: \"(string|boolean)\",\n        template: \"string\",\n        title: \"(string|element|function)\",\n        trigger: \"string\"\n    };\n    /**\n   * Class definition\n   */ class Tooltip extends BaseComponent {\n        // Getters\n        static get Default() {\n            return Default$3;\n        }\n        static get DefaultType() {\n            return DefaultType$3;\n        }\n        static get NAME() {\n            return NAME$4;\n        }\n        // Public\n        enable() {\n            this._isEnabled = true;\n        }\n        disable() {\n            this._isEnabled = false;\n        }\n        toggleEnabled() {\n            this._isEnabled = !this._isEnabled;\n        }\n        toggle() {\n            if (!this._isEnabled) {\n                return;\n            }\n            this._activeTrigger.click = !this._activeTrigger.click;\n            if (this._isShown()) {\n                this._leave();\n                return;\n            }\n            this._enter();\n        }\n        dispose() {\n            clearTimeout(this._timeout);\n            EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n            if (this._element.getAttribute(\"data-bs-original-title\")) {\n                this._element.setAttribute(\"title\", this._element.getAttribute(\"data-bs-original-title\"));\n            }\n            this._disposePopper();\n            super.dispose();\n        }\n        show() {\n            if (this._element.style.display === \"none\") {\n                throw new Error(\"Please use show on visible elements\");\n            }\n            if (!(this._isWithContent() && this._isEnabled)) {\n                return;\n            }\n            const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));\n            const shadowRoot = findShadowRoot(this._element);\n            const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);\n            if (showEvent.defaultPrevented || !isInTheDom) {\n                return;\n            }\n            // TODO: v6 remove this or make it optional\n            this._disposePopper();\n            const tip = this._getTipElement();\n            this._element.setAttribute(\"aria-describedby\", tip.getAttribute(\"id\"));\n            const { container } = this._config;\n            if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\n                container.append(tip);\n                EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));\n            }\n            this._popper = this._createPopper(tip);\n            tip.classList.add(CLASS_NAME_SHOW$2);\n            // If this is a touch-enabled device we add extra\n            // empty mouseover listeners to the body's immediate children;\n            // only needed because of broken event delegation on iOS\n            // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n            if (\"ontouchstart\" in document.documentElement) {\n                for (const element of [].concat(...document.body.children)){\n                    EventHandler.on(element, \"mouseover\", noop);\n                }\n            }\n            const complete = ()=>{\n                EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));\n                if (this._isHovered === false) {\n                    this._leave();\n                }\n                this._isHovered = false;\n            };\n            this._queueCallback(complete, this.tip, this._isAnimated());\n        }\n        hide() {\n            if (!this._isShown()) {\n                return;\n            }\n            const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            const tip = this._getTipElement();\n            tip.classList.remove(CLASS_NAME_SHOW$2);\n            // If this is a touch-enabled device we remove the extra\n            // empty mouseover listeners we added for iOS support\n            if (\"ontouchstart\" in document.documentElement) {\n                for (const element of [].concat(...document.body.children)){\n                    EventHandler.off(element, \"mouseover\", noop);\n                }\n            }\n            this._activeTrigger[TRIGGER_CLICK] = false;\n            this._activeTrigger[TRIGGER_FOCUS] = false;\n            this._activeTrigger[TRIGGER_HOVER] = false;\n            this._isHovered = null; // it is a trick to support manual triggering\n            const complete = ()=>{\n                if (this._isWithActiveTrigger()) {\n                    return;\n                }\n                if (!this._isHovered) {\n                    this._disposePopper();\n                }\n                this._element.removeAttribute(\"aria-describedby\");\n                EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));\n            };\n            this._queueCallback(complete, this.tip, this._isAnimated());\n        }\n        update() {\n            if (this._popper) {\n                this._popper.update();\n            }\n        }\n        // Protected\n        _isWithContent() {\n            return Boolean(this._getTitle());\n        }\n        _getTipElement() {\n            if (!this.tip) {\n                this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());\n            }\n            return this.tip;\n        }\n        _createTipElement(content) {\n            const tip = this._getTemplateFactory(content).toHtml();\n            // TODO: remove this check in v6\n            if (!tip) {\n                return null;\n            }\n            tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);\n            // TODO: v6 the following can be achieved with CSS only\n            tip.classList.add(\"bs-\".concat(this.constructor.NAME, \"-auto\"));\n            const tipId = getUID(this.constructor.NAME).toString();\n            tip.setAttribute(\"id\", tipId);\n            if (this._isAnimated()) {\n                tip.classList.add(CLASS_NAME_FADE$2);\n            }\n            return tip;\n        }\n        setContent(content) {\n            this._newContent = content;\n            if (this._isShown()) {\n                this._disposePopper();\n                this.show();\n            }\n        }\n        _getTemplateFactory(content) {\n            if (this._templateFactory) {\n                this._templateFactory.changeContent(content);\n            } else {\n                this._templateFactory = new TemplateFactory({\n                    ...this._config,\n                    // the `content` var has to be after `this._config`\n                    // to override config.content in case of popover\n                    content,\n                    extraClass: this._resolvePossibleFunction(this._config.customClass)\n                });\n            }\n            return this._templateFactory;\n        }\n        _getContentForTemplate() {\n            return {\n                [SELECTOR_TOOLTIP_INNER]: this._getTitle()\n            };\n        }\n        _getTitle() {\n            return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute(\"data-bs-original-title\");\n        }\n        // Private\n        _initializeOnDelegatedTarget(event) {\n            return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());\n        }\n        _isAnimated() {\n            return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);\n        }\n        _isShown() {\n            return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);\n        }\n        _createPopper(tip) {\n            const placement = execute(this._config.placement, [\n                this,\n                tip,\n                this._element\n            ]);\n            const attachment = AttachmentMap[placement.toUpperCase()];\n            return createPopper(this._element, tip, this._getPopperConfig(attachment));\n        }\n        _getOffset() {\n            const { offset } = this._config;\n            if (typeof offset === \"string\") {\n                return offset.split(\",\").map((value)=>Number.parseInt(value, 10));\n            }\n            if (typeof offset === \"function\") {\n                return (popperData)=>offset(popperData, this._element);\n            }\n            return offset;\n        }\n        _resolvePossibleFunction(arg) {\n            return execute(arg, [\n                this._element\n            ]);\n        }\n        _getPopperConfig(attachment) {\n            const defaultBsPopperConfig = {\n                placement: attachment,\n                modifiers: [\n                    {\n                        name: \"flip\",\n                        options: {\n                            fallbackPlacements: this._config.fallbackPlacements\n                        }\n                    },\n                    {\n                        name: \"offset\",\n                        options: {\n                            offset: this._getOffset()\n                        }\n                    },\n                    {\n                        name: \"preventOverflow\",\n                        options: {\n                            boundary: this._config.boundary\n                        }\n                    },\n                    {\n                        name: \"arrow\",\n                        options: {\n                            element: \".\".concat(this.constructor.NAME, \"-arrow\")\n                        }\n                    },\n                    {\n                        name: \"preSetPlacement\",\n                        enabled: true,\n                        phase: \"beforeMain\",\n                        fn: (data)=>{\n                            // Pre-set Popper's placement attribute in order to read the arrow sizes properly.\n                            // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement\n                            this._getTipElement().setAttribute(\"data-popper-placement\", data.state.placement);\n                        }\n                    }\n                ]\n            };\n            return {\n                ...defaultBsPopperConfig,\n                ...execute(this._config.popperConfig, [\n                    defaultBsPopperConfig\n                ])\n            };\n        }\n        _setListeners() {\n            const triggers = this._config.trigger.split(\" \");\n            for (const trigger of triggers){\n                if (trigger === \"click\") {\n                    EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event)=>{\n                        const context = this._initializeOnDelegatedTarget(event);\n                        context.toggle();\n                    });\n                } else if (trigger !== TRIGGER_MANUAL) {\n                    const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);\n                    const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);\n                    EventHandler.on(this._element, eventIn, this._config.selector, (event)=>{\n                        const context = this._initializeOnDelegatedTarget(event);\n                        context._activeTrigger[event.type === \"focusin\" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n                        context._enter();\n                    });\n                    EventHandler.on(this._element, eventOut, this._config.selector, (event)=>{\n                        const context = this._initializeOnDelegatedTarget(event);\n                        context._activeTrigger[event.type === \"focusout\" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);\n                        context._leave();\n                    });\n                }\n            }\n            this._hideModalHandler = ()=>{\n                if (this._element) {\n                    this.hide();\n                }\n            };\n            EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n        }\n        _fixTitle() {\n            const title = this._element.getAttribute(\"title\");\n            if (!title) {\n                return;\n            }\n            if (!this._element.getAttribute(\"aria-label\") && !this._element.textContent.trim()) {\n                this._element.setAttribute(\"aria-label\", title);\n            }\n            this._element.setAttribute(\"data-bs-original-title\", title); // DO NOT USE IT. Is only for backwards compatibility\n            this._element.removeAttribute(\"title\");\n        }\n        _enter() {\n            if (this._isShown() || this._isHovered) {\n                this._isHovered = true;\n                return;\n            }\n            this._isHovered = true;\n            this._setTimeout(()=>{\n                if (this._isHovered) {\n                    this.show();\n                }\n            }, this._config.delay.show);\n        }\n        _leave() {\n            if (this._isWithActiveTrigger()) {\n                return;\n            }\n            this._isHovered = false;\n            this._setTimeout(()=>{\n                if (!this._isHovered) {\n                    this.hide();\n                }\n            }, this._config.delay.hide);\n        }\n        _setTimeout(handler, timeout) {\n            clearTimeout(this._timeout);\n            this._timeout = setTimeout(handler, timeout);\n        }\n        _isWithActiveTrigger() {\n            return Object.values(this._activeTrigger).includes(true);\n        }\n        _getConfig(config) {\n            const dataAttributes = Manipulator.getDataAttributes(this._element);\n            for (const dataAttribute of Object.keys(dataAttributes)){\n                if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {\n                    delete dataAttributes[dataAttribute];\n                }\n            }\n            config = {\n                ...dataAttributes,\n                ...typeof config === \"object\" && config ? config : {}\n            };\n            config = this._mergeConfigObj(config);\n            config = this._configAfterMerge(config);\n            this._typeCheckConfig(config);\n            return config;\n        }\n        _configAfterMerge(config) {\n            config.container = config.container === false ? document.body : getElement(config.container);\n            if (typeof config.delay === \"number\") {\n                config.delay = {\n                    show: config.delay,\n                    hide: config.delay\n                };\n            }\n            if (typeof config.title === \"number\") {\n                config.title = config.title.toString();\n            }\n            if (typeof config.content === \"number\") {\n                config.content = config.content.toString();\n            }\n            return config;\n        }\n        _getDelegateConfig() {\n            const config = {};\n            for (const [key, value] of Object.entries(this._config)){\n                if (this.constructor.Default[key] !== value) {\n                    config[key] = value;\n                }\n            }\n            config.selector = false;\n            config.trigger = \"manual\";\n            // In the future can be replaced with:\n            // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])\n            // `Object.fromEntries(keysWithDifferentValues)`\n            return config;\n        }\n        _disposePopper() {\n            if (this._popper) {\n                this._popper.destroy();\n                this._popper = null;\n            }\n            if (this.tip) {\n                this.tip.remove();\n                this.tip = null;\n            }\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Tooltip.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (typeof data[config] === \"undefined\") {\n                    throw new TypeError('No method named \"'.concat(config, '\"'));\n                }\n                data[config]();\n            });\n        }\n        constructor(element, config){\n            if (typeof Popper === \"undefined\") {\n                throw new TypeError(\"Bootstrap's tooltips require Popper (https://popper.js.org)\");\n            }\n            super(element, config);\n            // Private\n            this._isEnabled = true;\n            this._timeout = 0;\n            this._isHovered = null;\n            this._activeTrigger = {};\n            this._popper = null;\n            this._templateFactory = null;\n            this._newContent = null;\n            // Protected\n            this.tip = null;\n            this._setListeners();\n            if (!this._config.selector) {\n                this._fixTitle();\n            }\n        }\n    }\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Tooltip);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap popover.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$3 = \"popover\";\n    const SELECTOR_TITLE = \".popover-header\";\n    const SELECTOR_CONTENT = \".popover-body\";\n    const Default$2 = {\n        ...Tooltip.Default,\n        content: \"\",\n        offset: [\n            0,\n            8\n        ],\n        placement: \"right\",\n        template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"popover-arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div>' + \"</div>\",\n        trigger: \"click\"\n    };\n    const DefaultType$2 = {\n        ...Tooltip.DefaultType,\n        content: \"(null|string|element|function)\"\n    };\n    /**\n   * Class definition\n   */ class Popover extends Tooltip {\n        // Getters\n        static get Default() {\n            return Default$2;\n        }\n        static get DefaultType() {\n            return DefaultType$2;\n        }\n        static get NAME() {\n            return NAME$3;\n        }\n        // Overrides\n        _isWithContent() {\n            return this._getTitle() || this._getContent();\n        }\n        // Private\n        _getContentForTemplate() {\n            return {\n                [SELECTOR_TITLE]: this._getTitle(),\n                [SELECTOR_CONTENT]: this._getContent()\n            };\n        }\n        _getContent() {\n            return this._resolvePossibleFunction(this._config.content);\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Popover.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (typeof data[config] === \"undefined\") {\n                    throw new TypeError('No method named \"'.concat(config, '\"'));\n                }\n                data[config]();\n            });\n        }\n    }\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Popover);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap scrollspy.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$2 = \"scrollspy\";\n    const DATA_KEY$2 = \"bs.scrollspy\";\n    const EVENT_KEY$2 = \".\".concat(DATA_KEY$2);\n    const DATA_API_KEY = \".data-api\";\n    const EVENT_ACTIVATE = \"activate\".concat(EVENT_KEY$2);\n    const EVENT_CLICK = \"click\".concat(EVENT_KEY$2);\n    const EVENT_LOAD_DATA_API$1 = \"load\".concat(EVENT_KEY$2).concat(DATA_API_KEY);\n    const CLASS_NAME_DROPDOWN_ITEM = \"dropdown-item\";\n    const CLASS_NAME_ACTIVE$1 = \"active\";\n    const SELECTOR_DATA_SPY = '[data-bs-spy=\"scroll\"]';\n    const SELECTOR_TARGET_LINKS = \"[href]\";\n    const SELECTOR_NAV_LIST_GROUP = \".nav, .list-group\";\n    const SELECTOR_NAV_LINKS = \".nav-link\";\n    const SELECTOR_NAV_ITEMS = \".nav-item\";\n    const SELECTOR_LIST_ITEMS = \".list-group-item\";\n    const SELECTOR_LINK_ITEMS = \"\".concat(SELECTOR_NAV_LINKS, \", \").concat(SELECTOR_NAV_ITEMS, \" > \").concat(SELECTOR_NAV_LINKS, \", \").concat(SELECTOR_LIST_ITEMS);\n    const SELECTOR_DROPDOWN = \".dropdown\";\n    const SELECTOR_DROPDOWN_TOGGLE$1 = \".dropdown-toggle\";\n    const Default$1 = {\n        offset: null,\n        // TODO: v6 @deprecated, keep it for backwards compatibility reasons\n        rootMargin: \"0px 0px -25%\",\n        smoothScroll: false,\n        target: null,\n        threshold: [\n            0.1,\n            0.5,\n            1\n        ]\n    };\n    const DefaultType$1 = {\n        offset: \"(number|null)\",\n        // TODO v6 @deprecated, keep it for backwards compatibility reasons\n        rootMargin: \"string\",\n        smoothScroll: \"boolean\",\n        target: \"element\",\n        threshold: \"array\"\n    };\n    /**\n   * Class definition\n   */ class ScrollSpy extends BaseComponent {\n        // Getters\n        static get Default() {\n            return Default$1;\n        }\n        static get DefaultType() {\n            return DefaultType$1;\n        }\n        static get NAME() {\n            return NAME$2;\n        }\n        // Public\n        refresh() {\n            this._initializeTargetsAndObservables();\n            this._maybeEnableSmoothScroll();\n            if (this._observer) {\n                this._observer.disconnect();\n            } else {\n                this._observer = this._getNewObserver();\n            }\n            for (const section of this._observableSections.values()){\n                this._observer.observe(section);\n            }\n        }\n        dispose() {\n            this._observer.disconnect();\n            super.dispose();\n        }\n        // Private\n        _configAfterMerge(config) {\n            // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case\n            config.target = getElement(config.target) || document.body;\n            // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only\n            config.rootMargin = config.offset ? \"\".concat(config.offset, \"px 0px -30%\") : config.rootMargin;\n            if (typeof config.threshold === \"string\") {\n                config.threshold = config.threshold.split(\",\").map((value)=>Number.parseFloat(value));\n            }\n            return config;\n        }\n        _maybeEnableSmoothScroll() {\n            if (!this._config.smoothScroll) {\n                return;\n            }\n            // unregister any previous listeners\n            EventHandler.off(this._config.target, EVENT_CLICK);\n            EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event)=>{\n                const observableSection = this._observableSections.get(event.target.hash);\n                if (observableSection) {\n                    event.preventDefault();\n                    const root = this._rootElement || window;\n                    const height = observableSection.offsetTop - this._element.offsetTop;\n                    if (root.scrollTo) {\n                        root.scrollTo({\n                            top: height,\n                            behavior: \"smooth\"\n                        });\n                        return;\n                    }\n                    // Chrome 60 doesn't support `scrollTo`\n                    root.scrollTop = height;\n                }\n            });\n        }\n        _getNewObserver() {\n            const options = {\n                root: this._rootElement,\n                threshold: this._config.threshold,\n                rootMargin: this._config.rootMargin\n            };\n            return new IntersectionObserver((entries)=>this._observerCallback(entries), options);\n        }\n        // The logic of selection\n        _observerCallback(entries) {\n            const targetElement = (entry)=>this._targetLinks.get(\"#\".concat(entry.target.id));\n            const activate = (entry)=>{\n                this._previousScrollData.visibleEntryTop = entry.target.offsetTop;\n                this._process(targetElement(entry));\n            };\n            const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;\n            const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;\n            this._previousScrollData.parentScrollTop = parentScrollTop;\n            for (const entry of entries){\n                if (!entry.isIntersecting) {\n                    this._activeTarget = null;\n                    this._clearActiveClass(targetElement(entry));\n                    continue;\n                }\n                const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;\n                // if we are scrolling down, pick the bigger offsetTop\n                if (userScrollsDown && entryIsLowerThanPrevious) {\n                    activate(entry);\n                    // if parent isn't scrolled, let's keep the first visible item, breaking the iteration\n                    if (!parentScrollTop) {\n                        return;\n                    }\n                    continue;\n                }\n                // if we are scrolling up, pick the smallest offsetTop\n                if (!userScrollsDown && !entryIsLowerThanPrevious) {\n                    activate(entry);\n                }\n            }\n        }\n        _initializeTargetsAndObservables() {\n            this._targetLinks = new Map();\n            this._observableSections = new Map();\n            const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);\n            for (const anchor of targetLinks){\n                // ensure that the anchor has an id and is not disabled\n                if (!anchor.hash || isDisabled(anchor)) {\n                    continue;\n                }\n                const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);\n                // ensure that the observableSection exists & is visible\n                if (isVisible(observableSection)) {\n                    this._targetLinks.set(decodeURI(anchor.hash), anchor);\n                    this._observableSections.set(anchor.hash, observableSection);\n                }\n            }\n        }\n        _process(target) {\n            if (this._activeTarget === target) {\n                return;\n            }\n            this._clearActiveClass(this._config.target);\n            this._activeTarget = target;\n            target.classList.add(CLASS_NAME_ACTIVE$1);\n            this._activateParents(target);\n            EventHandler.trigger(this._element, EVENT_ACTIVATE, {\n                relatedTarget: target\n            });\n        }\n        _activateParents(target) {\n            // Activate dropdown parents\n            if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {\n                SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);\n                return;\n            }\n            for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)){\n                // Set triggered links parents as active\n                // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n                for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)){\n                    item.classList.add(CLASS_NAME_ACTIVE$1);\n                }\n            }\n        }\n        _clearActiveClass(parent) {\n            parent.classList.remove(CLASS_NAME_ACTIVE$1);\n            const activeNodes = SelectorEngine.find(\"\".concat(SELECTOR_TARGET_LINKS, \".\").concat(CLASS_NAME_ACTIVE$1), parent);\n            for (const node of activeNodes){\n                node.classList.remove(CLASS_NAME_ACTIVE$1);\n            }\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = ScrollSpy.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                    throw new TypeError('No method named \"'.concat(config, '\"'));\n                }\n                data[config]();\n            });\n        }\n        constructor(element, config){\n            super(element, config);\n            // this._element is the observablesContainer and config.target the menu links wrapper\n            this._targetLinks = new Map();\n            this._observableSections = new Map();\n            this._rootElement = getComputedStyle(this._element).overflowY === \"visible\" ? null : this._element;\n            this._activeTarget = null;\n            this._observer = null;\n            this._previousScrollData = {\n                visibleEntryTop: 0,\n                parentScrollTop: 0\n            };\n            this.refresh(); // initialize\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(window, EVENT_LOAD_DATA_API$1, ()=>{\n        for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)){\n            ScrollSpy.getOrCreateInstance(spy);\n        }\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(ScrollSpy);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap tab.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$1 = \"tab\";\n    const DATA_KEY$1 = \"bs.tab\";\n    const EVENT_KEY$1 = \".\".concat(DATA_KEY$1);\n    const EVENT_HIDE$1 = \"hide\".concat(EVENT_KEY$1);\n    const EVENT_HIDDEN$1 = \"hidden\".concat(EVENT_KEY$1);\n    const EVENT_SHOW$1 = \"show\".concat(EVENT_KEY$1);\n    const EVENT_SHOWN$1 = \"shown\".concat(EVENT_KEY$1);\n    const EVENT_CLICK_DATA_API = \"click\".concat(EVENT_KEY$1);\n    const EVENT_KEYDOWN = \"keydown\".concat(EVENT_KEY$1);\n    const EVENT_LOAD_DATA_API = \"load\".concat(EVENT_KEY$1);\n    const ARROW_LEFT_KEY = \"ArrowLeft\";\n    const ARROW_RIGHT_KEY = \"ArrowRight\";\n    const ARROW_UP_KEY = \"ArrowUp\";\n    const ARROW_DOWN_KEY = \"ArrowDown\";\n    const HOME_KEY = \"Home\";\n    const END_KEY = \"End\";\n    const CLASS_NAME_ACTIVE = \"active\";\n    const CLASS_NAME_FADE$1 = \"fade\";\n    const CLASS_NAME_SHOW$1 = \"show\";\n    const CLASS_DROPDOWN = \"dropdown\";\n    const SELECTOR_DROPDOWN_TOGGLE = \".dropdown-toggle\";\n    const SELECTOR_DROPDOWN_MENU = \".dropdown-menu\";\n    const NOT_SELECTOR_DROPDOWN_TOGGLE = \":not(\".concat(SELECTOR_DROPDOWN_TOGGLE, \")\");\n    const SELECTOR_TAB_PANEL = '.list-group, .nav, [role=\"tablist\"]';\n    const SELECTOR_OUTER = \".nav-item, .list-group-item\";\n    const SELECTOR_INNER = \".nav-link\".concat(NOT_SELECTOR_DROPDOWN_TOGGLE, \", .list-group-item\").concat(NOT_SELECTOR_DROPDOWN_TOGGLE, ', [role=\"tab\"]').concat(NOT_SELECTOR_DROPDOWN_TOGGLE);\n    const SELECTOR_DATA_TOGGLE = '[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]'; // TODO: could only be `tab` in v6\n    const SELECTOR_INNER_ELEM = \"\".concat(SELECTOR_INNER, \", \").concat(SELECTOR_DATA_TOGGLE);\n    const SELECTOR_DATA_TOGGLE_ACTIVE = \".\".concat(CLASS_NAME_ACTIVE, '[data-bs-toggle=\"tab\"], .').concat(CLASS_NAME_ACTIVE, '[data-bs-toggle=\"pill\"], .').concat(CLASS_NAME_ACTIVE, '[data-bs-toggle=\"list\"]');\n    /**\n   * Class definition\n   */ class Tab extends BaseComponent {\n        // Getters\n        static get NAME() {\n            return NAME$1;\n        }\n        // Public\n        show() {\n            // Shows this elem and deactivate the active sibling if exists\n            const innerElem = this._element;\n            if (this._elemIsActive(innerElem)) {\n                return;\n            }\n            // Search for active tab on same parent to deactivate it\n            const active = this._getActiveElem();\n            const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {\n                relatedTarget: innerElem\n            }) : null;\n            const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {\n                relatedTarget: active\n            });\n            if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {\n                return;\n            }\n            this._deactivate(active, innerElem);\n            this._activate(innerElem, active);\n        }\n        // Private\n        _activate(element, relatedElem) {\n            if (!element) {\n                return;\n            }\n            element.classList.add(CLASS_NAME_ACTIVE);\n            this._activate(SelectorEngine.getElementFromSelector(element)); // Search and activate/show the proper section\n            const complete = ()=>{\n                if (element.getAttribute(\"role\") !== \"tab\") {\n                    element.classList.add(CLASS_NAME_SHOW$1);\n                    return;\n                }\n                element.removeAttribute(\"tabindex\");\n                element.setAttribute(\"aria-selected\", true);\n                this._toggleDropDown(element, true);\n                EventHandler.trigger(element, EVENT_SHOWN$1, {\n                    relatedTarget: relatedElem\n                });\n            };\n            this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n        }\n        _deactivate(element, relatedElem) {\n            if (!element) {\n                return;\n            }\n            element.classList.remove(CLASS_NAME_ACTIVE);\n            element.blur();\n            this._deactivate(SelectorEngine.getElementFromSelector(element)); // Search and deactivate the shown section too\n            const complete = ()=>{\n                if (element.getAttribute(\"role\") !== \"tab\") {\n                    element.classList.remove(CLASS_NAME_SHOW$1);\n                    return;\n                }\n                element.setAttribute(\"aria-selected\", false);\n                element.setAttribute(\"tabindex\", \"-1\");\n                this._toggleDropDown(element, false);\n                EventHandler.trigger(element, EVENT_HIDDEN$1, {\n                    relatedTarget: relatedElem\n                });\n            };\n            this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n        }\n        _keydown(event) {\n            if (![\n                ARROW_LEFT_KEY,\n                ARROW_RIGHT_KEY,\n                ARROW_UP_KEY,\n                ARROW_DOWN_KEY,\n                HOME_KEY,\n                END_KEY\n            ].includes(event.key)) {\n                return;\n            }\n            event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page\n            event.preventDefault();\n            const children = this._getChildren().filter((element)=>!isDisabled(element));\n            let nextActiveElement;\n            if ([\n                HOME_KEY,\n                END_KEY\n            ].includes(event.key)) {\n                nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];\n            } else {\n                const isNext = [\n                    ARROW_RIGHT_KEY,\n                    ARROW_DOWN_KEY\n                ].includes(event.key);\n                nextActiveElement = getNextActiveElement(children, event.target, isNext, true);\n            }\n            if (nextActiveElement) {\n                nextActiveElement.focus({\n                    preventScroll: true\n                });\n                Tab.getOrCreateInstance(nextActiveElement).show();\n            }\n        }\n        _getChildren() {\n            // collection of inner elements\n            return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);\n        }\n        _getActiveElem() {\n            return this._getChildren().find((child)=>this._elemIsActive(child)) || null;\n        }\n        _setInitialAttributes(parent, children) {\n            this._setAttributeIfNotExists(parent, \"role\", \"tablist\");\n            for (const child of children){\n                this._setInitialAttributesOnChild(child);\n            }\n        }\n        _setInitialAttributesOnChild(child) {\n            child = this._getInnerElement(child);\n            const isActive = this._elemIsActive(child);\n            const outerElem = this._getOuterElement(child);\n            child.setAttribute(\"aria-selected\", isActive);\n            if (outerElem !== child) {\n                this._setAttributeIfNotExists(outerElem, \"role\", \"presentation\");\n            }\n            if (!isActive) {\n                child.setAttribute(\"tabindex\", \"-1\");\n            }\n            this._setAttributeIfNotExists(child, \"role\", \"tab\");\n            // set attributes to the related panel too\n            this._setInitialAttributesOnTargetPanel(child);\n        }\n        _setInitialAttributesOnTargetPanel(child) {\n            const target = SelectorEngine.getElementFromSelector(child);\n            if (!target) {\n                return;\n            }\n            this._setAttributeIfNotExists(target, \"role\", \"tabpanel\");\n            if (child.id) {\n                this._setAttributeIfNotExists(target, \"aria-labelledby\", \"\".concat(child.id));\n            }\n        }\n        _toggleDropDown(element, open) {\n            const outerElem = this._getOuterElement(element);\n            if (!outerElem.classList.contains(CLASS_DROPDOWN)) {\n                return;\n            }\n            const toggle = (selector, className)=>{\n                const element = SelectorEngine.findOne(selector, outerElem);\n                if (element) {\n                    element.classList.toggle(className, open);\n                }\n            };\n            toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);\n            toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);\n            outerElem.setAttribute(\"aria-expanded\", open);\n        }\n        _setAttributeIfNotExists(element, attribute, value) {\n            if (!element.hasAttribute(attribute)) {\n                element.setAttribute(attribute, value);\n            }\n        }\n        _elemIsActive(elem) {\n            return elem.classList.contains(CLASS_NAME_ACTIVE);\n        }\n        // Try to get the inner element (usually the .nav-link)\n        _getInnerElement(elem) {\n            return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);\n        }\n        // Try to get the outer element (usually the .nav-item)\n        _getOuterElement(elem) {\n            return elem.closest(SELECTOR_OUTER) || elem;\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Tab.getOrCreateInstance(this);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                    throw new TypeError('No method named \"'.concat(config, '\"'));\n                }\n                data[config]();\n            });\n        }\n        constructor(element){\n            super(element);\n            this._parent = this._element.closest(SELECTOR_TAB_PANEL);\n            if (!this._parent) {\n                return;\n            // TODO: should throw exception in v6\n            // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)\n            }\n            // Set up initial aria attributes\n            this._setInitialAttributes(this._parent, this._getChildren());\n            EventHandler.on(this._element, EVENT_KEYDOWN, (event)=>this._keydown(event));\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {\n        if ([\n            \"A\",\n            \"AREA\"\n        ].includes(this.tagName)) {\n            event.preventDefault();\n        }\n        if (isDisabled(this)) {\n            return;\n        }\n        Tab.getOrCreateInstance(this).show();\n    });\n    /**\n   * Initialize on focus\n   */ EventHandler.on(window, EVENT_LOAD_DATA_API, ()=>{\n        for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)){\n            Tab.getOrCreateInstance(element);\n        }\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Tab);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap toast.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME = \"toast\";\n    const DATA_KEY = \"bs.toast\";\n    const EVENT_KEY = \".\".concat(DATA_KEY);\n    const EVENT_MOUSEOVER = \"mouseover\".concat(EVENT_KEY);\n    const EVENT_MOUSEOUT = \"mouseout\".concat(EVENT_KEY);\n    const EVENT_FOCUSIN = \"focusin\".concat(EVENT_KEY);\n    const EVENT_FOCUSOUT = \"focusout\".concat(EVENT_KEY);\n    const EVENT_HIDE = \"hide\".concat(EVENT_KEY);\n    const EVENT_HIDDEN = \"hidden\".concat(EVENT_KEY);\n    const EVENT_SHOW = \"show\".concat(EVENT_KEY);\n    const EVENT_SHOWN = \"shown\".concat(EVENT_KEY);\n    const CLASS_NAME_FADE = \"fade\";\n    const CLASS_NAME_HIDE = \"hide\"; // @deprecated - kept here only for backwards compatibility\n    const CLASS_NAME_SHOW = \"show\";\n    const CLASS_NAME_SHOWING = \"showing\";\n    const DefaultType = {\n        animation: \"boolean\",\n        autohide: \"boolean\",\n        delay: \"number\"\n    };\n    const Default = {\n        animation: true,\n        autohide: true,\n        delay: 5000\n    };\n    /**\n   * Class definition\n   */ class Toast extends BaseComponent {\n        // Getters\n        static get Default() {\n            return Default;\n        }\n        static get DefaultType() {\n            return DefaultType;\n        }\n        static get NAME() {\n            return NAME;\n        }\n        // Public\n        show() {\n            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);\n            if (showEvent.defaultPrevented) {\n                return;\n            }\n            this._clearTimeout();\n            if (this._config.animation) {\n                this._element.classList.add(CLASS_NAME_FADE);\n            }\n            const complete = ()=>{\n                this._element.classList.remove(CLASS_NAME_SHOWING);\n                EventHandler.trigger(this._element, EVENT_SHOWN);\n                this._maybeScheduleHide();\n            };\n            this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated\n            reflow(this._element);\n            this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);\n            this._queueCallback(complete, this._element, this._config.animation);\n        }\n        hide() {\n            if (!this.isShown()) {\n                return;\n            }\n            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            const complete = ()=>{\n                this._element.classList.add(CLASS_NAME_HIDE); // @deprecated\n                this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);\n                EventHandler.trigger(this._element, EVENT_HIDDEN);\n            };\n            this._element.classList.add(CLASS_NAME_SHOWING);\n            this._queueCallback(complete, this._element, this._config.animation);\n        }\n        dispose() {\n            this._clearTimeout();\n            if (this.isShown()) {\n                this._element.classList.remove(CLASS_NAME_SHOW);\n            }\n            super.dispose();\n        }\n        isShown() {\n            return this._element.classList.contains(CLASS_NAME_SHOW);\n        }\n        // Private\n        _maybeScheduleHide() {\n            if (!this._config.autohide) {\n                return;\n            }\n            if (this._hasMouseInteraction || this._hasKeyboardInteraction) {\n                return;\n            }\n            this._timeout = setTimeout(()=>{\n                this.hide();\n            }, this._config.delay);\n        }\n        _onInteraction(event, isInteracting) {\n            switch(event.type){\n                case \"mouseover\":\n                case \"mouseout\":\n                    {\n                        this._hasMouseInteraction = isInteracting;\n                        break;\n                    }\n                case \"focusin\":\n                case \"focusout\":\n                    {\n                        this._hasKeyboardInteraction = isInteracting;\n                        break;\n                    }\n            }\n            if (isInteracting) {\n                this._clearTimeout();\n                return;\n            }\n            const nextElement = event.relatedTarget;\n            if (this._element === nextElement || this._element.contains(nextElement)) {\n                return;\n            }\n            this._maybeScheduleHide();\n        }\n        _setListeners() {\n            EventHandler.on(this._element, EVENT_MOUSEOVER, (event)=>this._onInteraction(event, true));\n            EventHandler.on(this._element, EVENT_MOUSEOUT, (event)=>this._onInteraction(event, false));\n            EventHandler.on(this._element, EVENT_FOCUSIN, (event)=>this._onInteraction(event, true));\n            EventHandler.on(this._element, EVENT_FOCUSOUT, (event)=>this._onInteraction(event, false));\n        }\n        _clearTimeout() {\n            clearTimeout(this._timeout);\n            this._timeout = null;\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Toast.getOrCreateInstance(this, config);\n                if (typeof config === \"string\") {\n                    if (typeof data[config] === \"undefined\") {\n                        throw new TypeError('No method named \"'.concat(config, '\"'));\n                    }\n                    data[config](this);\n                }\n            });\n        }\n        constructor(element, config){\n            super(element, config);\n            this._timeout = null;\n            this._hasMouseInteraction = false;\n            this._hasKeyboardInteraction = false;\n            this._setListeners();\n        }\n    }\n    /**\n   * Data API implementation\n   */ enableDismissTrigger(Toast);\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Toast);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap index.umd.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ const index_umd = {\n        Alert,\n        Button,\n        Carousel,\n        Collapse,\n        Dropdown,\n        Modal,\n        Offcanvas,\n        Popover,\n        ScrollSpy,\n        Tab,\n        Toast,\n        Tooltip\n    };\n    return index_umd;\n}); //# sourceMappingURL=bootstrap.bundle.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9ib290c3RyYXBANS4zLjNfQHBvcHBlcmpzK2NvcmVAMi4xMS44L25vZGVfbW9kdWxlcy9ib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAuYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7OztFQUlFLEdBQ0QsVUFBVUEsTUFBTSxFQUFFQyxPQUFPO0lBQ3hCLEtBQWlELEdBQWNFLE9BQU9ELE9BQU8sR0FBR0QsWUFDaEYsQ0FDdUc7QUFDekcsR0FBRyxRQUFPO0lBQWM7SUFFdEI7Ozs7O0dBS0MsR0FFRDs7R0FFQyxHQUVELE1BQU1RLGFBQWEsSUFBSUM7SUFDdkIsTUFBTUMsT0FBTztRQUNYQyxLQUFJQyxPQUFPLEVBQUVDLEdBQUcsRUFBRUMsUUFBUTtZQUN4QixJQUFJLENBQUNOLFdBQVdPLEdBQUcsQ0FBQ0gsVUFBVTtnQkFDNUJKLFdBQVdHLEdBQUcsQ0FBQ0MsU0FBUyxJQUFJSDtZQUM5QjtZQUNBLE1BQU1PLGNBQWNSLFdBQVdTLEdBQUcsQ0FBQ0w7WUFFbkMsc0RBQXNEO1lBQ3RELHVFQUF1RTtZQUN2RSxJQUFJLENBQUNJLFlBQVlELEdBQUcsQ0FBQ0YsUUFBUUcsWUFBWUUsSUFBSSxLQUFLLEdBQUc7Z0JBQ25ELHNDQUFzQztnQkFDdENDLFFBQVFDLEtBQUssQ0FBQywrRUFBaUgsT0FBbENDLE1BQU1DLElBQUksQ0FBQ04sWUFBWU8sSUFBSSxHQUFHLENBQUMsRUFBRSxFQUFDO2dCQUMvSDtZQUNGO1lBQ0FQLFlBQVlMLEdBQUcsQ0FBQ0UsS0FBS0M7UUFDdkI7UUFDQUcsS0FBSUwsT0FBTyxFQUFFQyxHQUFHO1lBQ2QsSUFBSUwsV0FBV08sR0FBRyxDQUFDSCxVQUFVO2dCQUMzQixPQUFPSixXQUFXUyxHQUFHLENBQUNMLFNBQVNLLEdBQUcsQ0FBQ0osUUFBUTtZQUM3QztZQUNBLE9BQU87UUFDVDtRQUNBVyxRQUFPWixPQUFPLEVBQUVDLEdBQUc7WUFDakIsSUFBSSxD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SSxDQUFDd3VDLGNBQWMsQ0FBQ3h1QyxPQUFPO1FBQ3JGO1FBQ0FtdUMsZ0JBQWdCO1lBQ2RuOUIsYUFBYSxJQUFJLENBQUNxekIsUUFBUTtZQUMxQixJQUFJLENBQUNBLFFBQVEsR0FBRztRQUNsQjtRQUVBLFNBQVM7UUFDVCxPQUFPOW1DLGdCQUFnQitILE1BQU0sRUFBRTtZQUM3QixPQUFPLElBQUksQ0FBQ3NFLElBQUksQ0FBQztnQkFDZixNQUFNQyxPQUFPcWtDLE1BQU1ubkMsbUJBQW1CLENBQUMsSUFBSSxFQUFFekI7Z0JBQzdDLElBQUksT0FBT0EsV0FBVyxVQUFVO29CQUM5QixJQUFJLE9BQU91RSxJQUFJLENBQUN2RSxPQUFPLEtBQUssYUFBYTt3QkFDdkMsTUFBTSxJQUFJWSxVQUFVLG9CQUEyQixPQUFQWixRQUFPO29CQUNqRDtvQkFDQXVFLElBQUksQ0FBQ3ZFLE9BQU8sQ0FBQyxJQUFJO2dCQUNuQjtZQUNGO1FBQ0Y7UUE5SEFLLFlBQVl6TyxPQUFPLEVBQUVvTyxNQUFNLENBQUU7WUFDM0IsS0FBSyxDQUFDcE8sU0FBU29PO1lBQ2YsSUFBSSxDQUFDKytCLFFBQVEsR0FBRztZQUNoQixJQUFJLENBQUNpSyxvQkFBb0IsR0FBRztZQUM1QixJQUFJLENBQUNDLHVCQUF1QixHQUFHO1lBQy9CLElBQUksQ0FBQzdJLGFBQWE7UUFDcEI7SUF5SEY7SUFFQTs7R0FFQyxHQUVEOThCLHFCQUFxQnNsQztJQUVyQjs7R0FFQyxHQUVEbHhDLG1CQUFtQmt4QztJQUVuQjs7Ozs7R0FLQyxHQUVELE1BQU1RLFlBQVk7UUFDaEJsbEM7UUFDQWE7UUFDQWlGO1FBQ0F5RTtRQUNBNmU7UUFDQW1IO1FBQ0E0QztRQUNBNko7UUFDQXlCO1FBQ0ErRDtRQUNBa0M7UUFDQXRLO0lBQ0Y7SUFFQSxPQUFPOEs7QUFFVCxJQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vYm9vdHN0cmFwQDUuMy4zX0Bwb3BwZXJqcytjb3JlQDIuMTEuOC9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmJ1bmRsZS5qcz9hYTI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICAqIEJvb3RzdHJhcCB2NS4zLjMgKGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS8pXG4gICogQ29weXJpZ2h0IDIwMTEtMjAyNCBUaGUgQm9vdHN0cmFwIEF1dGhvcnMgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ncmFwaHMvY29udHJpYnV0b3JzKVxuICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuYm9vdHN0cmFwID0gZmFjdG9yeSgpKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIGRvbS9kYXRhLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IGVsZW1lbnRNYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IERhdGEgPSB7XG4gICAgc2V0KGVsZW1lbnQsIGtleSwgaW5zdGFuY2UpIHtcbiAgICAgIGlmICghZWxlbWVudE1hcC5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgZWxlbWVudE1hcC5zZXQoZWxlbWVudCwgbmV3IE1hcCgpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluc3RhbmNlTWFwID0gZWxlbWVudE1hcC5nZXQoZWxlbWVudCk7XG5cbiAgICAgIC8vIG1ha2UgaXQgY2xlYXIgd2Ugb25seSB3YW50IG9uZSBpbnN0YW5jZSBwZXIgZWxlbWVudFxuICAgICAgLy8gY2FuIGJlIHJlbW92ZWQgbGF0ZXIgd2hlbiBtdWx0aXBsZSBrZXkvaW5zdGFuY2VzIGFyZSBmaW5lIHRvIGJlIHVzZWRcbiAgICAgIGlmICghaW5zdGFuY2VNYXAuaGFzKGtleSkgJiYgaW5zdGFuY2VNYXAuc2l6ZSAhPT0gMCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmVycm9yKGBCb290c3RyYXAgZG9lc24ndCBhbGxvdyBtb3JlIHRoYW4gb25lIGluc3RhbmNlIHBlciBlbGVtZW50LiBCb3VuZCBpbnN0YW5jZTogJHtBcnJheS5mcm9tKGluc3RhbmNlTWFwLmtleXMoKSlbMF19LmApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpbnN0YW5jZU1hcC5zZXQoa2V5LCBpbnN0YW5jZSk7XG4gICAgfSxcbiAgICBnZXQoZWxlbWVudCwga2V5KSB7XG4gICAgICBpZiAoZWxlbWVudE1hcC5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnQpLmdldChrZXkpIHx8IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHJlbW92ZShlbGVtZW50LCBrZXkpIHtcbiAgICAgIGlmICghZWxlbWVudE1hcC5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5zdGFuY2VNYXAgPSBlbGVtZW50TWFwLmdldChlbGVtZW50KTtcbiAgICAgIGluc3RhbmNlTWFwLmRlbGV0ZShrZXkpO1xuXG4gICAgICAvLyBmcmVlIHVwIGVsZW1lbnQgcmVmZXJlbmNlcyBpZiB0aGVyZSBhcmUgbm8gaW5zdGFuY2VzIGxlZnQgZm9yIGFuIGVsZW1lbnRcbiAgICAgIGlmIChpbnN0YW5jZU1hcC5zaXplID09PSAwKSB7XG4gICAgICAgIGVsZW1lbnRNYXAuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIHV0aWwvaW5kZXguanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIGNvbnN0IE1BWF9VSUQgPSAxMDAwMDAwO1xuICBjb25zdCBNSUxMSVNFQ09ORFNfTVVMVElQTElFUiA9IDEwMDA7XG4gIGNvbnN0IFRSQU5TSVRJT05fRU5EID0gJ3RyYW5zaXRpb25lbmQnO1xuXG4gIC8qKlxuICAgKiBQcm9wZXJseSBlc2NhcGUgSURzIHNlbGVjdG9ycyB0byBoYW5kbGUgd2VpcmQgSURzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgY29uc3QgcGFyc2VTZWxlY3RvciA9IHNlbGVjdG9yID0+IHtcbiAgICBpZiAoc2VsZWN0b3IgJiYgd2luZG93LkNTUyAmJiB3aW5kb3cuQ1NTLmVzY2FwZSkge1xuICAgICAgLy8gZG9jdW1lbnQucXVlcnlTZWxlY3RvciBuZWVkcyBlc2NhcGluZyB0byBoYW5kbGUgSURzIChodG1sNSspIGNvbnRhaW5pbmcgZm9yIGluc3RhbmNlIC9cbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvIyhbXlxcc1wiIyddKykvZywgKG1hdGNoLCBpZCkgPT4gYCMke0NTUy5lc2NhcGUoaWQpfWApO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3I7XG4gIH07XG5cbiAgLy8gU2hvdXQtb3V0IEFuZ3VzIENyb2xsIChodHRwczovL2dvby5nbC9weHdRR3ApXG4gIGNvbnN0IHRvVHlwZSA9IG9iamVjdCA9PiB7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGAke29iamVjdH1gO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkubWF0Y2goL1xccyhbYS16XSspL2kpWzFdLnRvTG93ZXJDYXNlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBVdGlsIEFQSVxuICAgKi9cblxuICBjb25zdCBnZXRVSUQgPSBwcmVmaXggPT4ge1xuICAgIGRvIHtcbiAgICAgIHByZWZpeCArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBNQVhfVUlEKTtcbiAgICB9IHdoaWxlIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwcmVmaXgpKTtcbiAgICByZXR1cm4gcHJlZml4O1xuICB9O1xuICBjb25zdCBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCA9IGVsZW1lbnQgPT4ge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRyYW5zaXRpb24tZHVyYXRpb24gb2YgdGhlIGVsZW1lbnRcbiAgICBsZXQge1xuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uLFxuICAgICAgdHJhbnNpdGlvbkRlbGF5XG4gICAgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIGNvbnN0IGZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uID0gTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICBjb25zdCBmbG9hdFRyYW5zaXRpb25EZWxheSA9IE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EZWxheSk7XG5cbiAgICAvLyBSZXR1cm4gMCBpZiBlbGVtZW50IG9yIHRyYW5zaXRpb24gZHVyYXRpb24gaXMgbm90IGZvdW5kXG4gICAgaWYgKCFmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiAmJiAhZmxvYXRUcmFuc2l0aW9uRGVsYXkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIElmIG11bHRpcGxlIGR1cmF0aW9ucyBhcmUgZGVmaW5lZCwgdGFrZSB0aGUgZmlyc3RcbiAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb24uc3BsaXQoJywnKVswXTtcbiAgICB0cmFuc2l0aW9uRGVsYXkgPSB0cmFuc2l0aW9uRGVsYXkuc3BsaXQoJywnKVswXTtcbiAgICByZXR1cm4gKE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbikgKyBOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRGVsYXkpKSAqIE1JTExJU0VDT05EU19NVUxUSVBMSUVSO1xuICB9O1xuICBjb25zdCB0cmlnZ2VyVHJhbnNpdGlvbkVuZCA9IGVsZW1lbnQgPT4ge1xuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoVFJBTlNJVElPTl9FTkQpKTtcbiAgfTtcbiAgY29uc3QgaXNFbGVtZW50JDEgPSBvYmplY3QgPT4ge1xuICAgIGlmICghb2JqZWN0IHx8IHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqZWN0LmpxdWVyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdFswXTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgIT09ICd1bmRlZmluZWQnO1xuICB9O1xuICBjb25zdCBnZXRFbGVtZW50ID0gb2JqZWN0ID0+IHtcbiAgICAvLyBpdCdzIGEgalF1ZXJ5IG9iamVjdCBvciBhIG5vZGUgZWxlbWVudFxuICAgIGlmIChpc0VsZW1lbnQkMShvYmplY3QpKSB7XG4gICAgICByZXR1cm4gb2JqZWN0LmpxdWVyeSA/IG9iamVjdFswXSA6IG9iamVjdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnICYmIG9iamVjdC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihwYXJzZVNlbGVjdG9yKG9iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgY29uc3QgaXNWaXNpYmxlID0gZWxlbWVudCA9PiB7XG4gICAgaWYgKCFpc0VsZW1lbnQkMShlbGVtZW50KSB8fCBlbGVtZW50LmdldENsaWVudFJlY3RzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRJc1Zpc2libGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Zpc2liaWxpdHknKSA9PT0gJ3Zpc2libGUnO1xuICAgIC8vIEhhbmRsZSBgZGV0YWlsc2AgZWxlbWVudCBhcyBpdHMgY29udGVudCBtYXkgZmFsc2llIGFwcGVhciB2aXNpYmxlIHdoZW4gaXQgaXMgY2xvc2VkXG4gICAgY29uc3QgY2xvc2VkRGV0YWlscyA9IGVsZW1lbnQuY2xvc2VzdCgnZGV0YWlsczpub3QoW29wZW5dKScpO1xuICAgIGlmICghY2xvc2VkRGV0YWlscykge1xuICAgICAgcmV0dXJuIGVsZW1lbnRJc1Zpc2libGU7XG4gICAgfVxuICAgIGlmIChjbG9zZWREZXRhaWxzICE9PSBlbGVtZW50KSB7XG4gICAgICBjb25zdCBzdW1tYXJ5ID0gZWxlbWVudC5jbG9zZXN0KCdzdW1tYXJ5Jyk7XG4gICAgICBpZiAoc3VtbWFyeSAmJiBzdW1tYXJ5LnBhcmVudE5vZGUgIT09IGNsb3NlZERldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHN1bW1hcnkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudElzVmlzaWJsZTtcbiAgfTtcbiAgY29uc3QgaXNEaXNhYmxlZCA9IGVsZW1lbnQgPT4ge1xuICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50Lm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZWxlbWVudC5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmRpc2FibGVkO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgIT09ICdmYWxzZSc7XG4gIH07XG4gIGNvbnN0IGZpbmRTaGFkb3dSb290ID0gZWxlbWVudCA9PiB7XG4gICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoU2hhZG93KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBDYW4gZmluZCB0aGUgc2hhZG93IHJvb3Qgb3RoZXJ3aXNlIGl0J2xsIHJldHVybiB0aGUgZG9jdW1lbnRcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQuZ2V0Um9vdE5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IHJvb3QgPSBlbGVtZW50LmdldFJvb3ROb2RlKCk7XG4gICAgICByZXR1cm4gcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyByb290IDogbnVsbDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyB3aGVuIHdlIGRvbid0IGZpbmQgYSBzaGFkb3cgcm9vdFxuICAgIGlmICghZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmRTaGFkb3dSb290KGVsZW1lbnQucGFyZW50Tm9kZSk7XG4gIH07XG4gIGNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcblxuICAvKipcbiAgICogVHJpY2sgdG8gcmVzdGFydCBhbiBlbGVtZW50J3MgYW5pbWF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybiB2b2lkXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuY2hhcmlzdGhlby5pby9ibG9nLzIwMjEvMDIvcmVzdGFydC1hLWNzcy1hbmltYXRpb24td2l0aC1qYXZhc2NyaXB0LyNyZXN0YXJ0aW5nLWEtY3NzLWFuaW1hdGlvblxuICAgKi9cbiAgY29uc3QgcmVmbG93ID0gZWxlbWVudCA9PiB7XG4gICAgZWxlbWVudC5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gIH07XG4gIGNvbnN0IGdldGpRdWVyeSA9ICgpID0+IHtcbiAgICBpZiAod2luZG93LmpRdWVyeSAmJiAhZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoJ2RhdGEtYnMtbm8tanF1ZXJ5JykpIHtcbiAgICAgIHJldHVybiB3aW5kb3cualF1ZXJ5O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgY29uc3QgRE9NQ29udGVudExvYWRlZENhbGxiYWNrcyA9IFtdO1xuICBjb25zdCBvbkRPTUNvbnRlbnRMb2FkZWQgPSBjYWxsYmFjayA9PiB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgLy8gYWRkIGxpc3RlbmVyIG9uIHRoZSBmaXJzdCBjYWxsIHdoZW4gdGhlIGRvY3VtZW50IGlzIGluIGxvYWRpbmcgc3RhdGVcbiAgICAgIGlmICghRE9NQ29udGVudExvYWRlZENhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIERPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIERPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBpc1JUTCA9ICgpID0+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kaXIgPT09ICdydGwnO1xuICBjb25zdCBkZWZpbmVKUXVlcnlQbHVnaW4gPSBwbHVnaW4gPT4ge1xuICAgIG9uRE9NQ29udGVudExvYWRlZCgoKSA9PiB7XG4gICAgICBjb25zdCAkID0gZ2V0alF1ZXJ5KCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgkKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBwbHVnaW4uTkFNRTtcbiAgICAgICAgY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltuYW1lXTtcbiAgICAgICAgJC5mbltuYW1lXSA9IHBsdWdpbi5qUXVlcnlJbnRlcmZhY2U7XG4gICAgICAgICQuZm5bbmFtZV0uQ29uc3RydWN0b3IgPSBwbHVnaW47XG4gICAgICAgICQuZm5bbmFtZV0ubm9Db25mbGljdCA9ICgpID0+IHtcbiAgICAgICAgICAkLmZuW25hbWVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgICAgICAgIHJldHVybiBwbHVnaW4ualF1ZXJ5SW50ZXJmYWNlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCBleGVjdXRlID0gKHBvc3NpYmxlQ2FsbGJhY2ssIGFyZ3MgPSBbXSwgZGVmYXVsdFZhbHVlID0gcG9zc2libGVDYWxsYmFjaykgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgcG9zc2libGVDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IHBvc3NpYmxlQ2FsbGJhY2soLi4uYXJncykgOiBkZWZhdWx0VmFsdWU7XG4gIH07XG4gIGNvbnN0IGV4ZWN1dGVBZnRlclRyYW5zaXRpb24gPSAoY2FsbGJhY2ssIHRyYW5zaXRpb25FbGVtZW50LCB3YWl0Rm9yVHJhbnNpdGlvbiA9IHRydWUpID0+IHtcbiAgICBpZiAoIXdhaXRGb3JUcmFuc2l0aW9uKSB7XG4gICAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZHVyYXRpb25QYWRkaW5nID0gNTtcbiAgICBjb25zdCBlbXVsYXRlZER1cmF0aW9uID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodHJhbnNpdGlvbkVsZW1lbnQpICsgZHVyYXRpb25QYWRkaW5nO1xuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICBjb25zdCBoYW5kbGVyID0gKHtcbiAgICAgIHRhcmdldFxuICAgIH0pID0+IHtcbiAgICAgIGlmICh0YXJnZXQgIT09IHRyYW5zaXRpb25FbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICB0cmFuc2l0aW9uRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFRSQU5TSVRJT05fRU5ELCBoYW5kbGVyKTtcbiAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xuICAgIH07XG4gICAgdHJhbnNpdGlvbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9OX0VORCwgaGFuZGxlcik7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICB0cmlnZ2VyVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRWxlbWVudCk7XG4gICAgICB9XG4gICAgfSwgZW11bGF0ZWREdXJhdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcHJldmlvdXMvbmV4dCBlbGVtZW50IG9mIGEgbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheX0gbGlzdCAgICBUaGUgbGlzdCBvZiBlbGVtZW50c1xuICAgKiBAcGFyYW0gYWN0aXZlRWxlbWVudCAgIFRoZSBhY3RpdmUgZWxlbWVudFxuICAgKiBAcGFyYW0gc2hvdWxkR2V0TmV4dCAgIENob29zZSB0byBnZXQgbmV4dCBvciBwcmV2aW91cyBlbGVtZW50XG4gICAqIEBwYXJhbSBpc0N5Y2xlQWxsb3dlZFxuICAgKiBAcmV0dXJuIHtFbGVtZW50fGVsZW19IFRoZSBwcm9wZXIgZWxlbWVudFxuICAgKi9cbiAgY29uc3QgZ2V0TmV4dEFjdGl2ZUVsZW1lbnQgPSAobGlzdCwgYWN0aXZlRWxlbWVudCwgc2hvdWxkR2V0TmV4dCwgaXNDeWNsZUFsbG93ZWQpID0+IHtcbiAgICBjb25zdCBsaXN0TGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgbGV0IGluZGV4ID0gbGlzdC5pbmRleE9mKGFjdGl2ZUVsZW1lbnQpO1xuXG4gICAgLy8gaWYgdGhlIGVsZW1lbnQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3QgcmV0dXJuIGFuIGVsZW1lbnRcbiAgICAvLyBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBhbmQgaWYgY3ljbGUgaXMgYWxsb3dlZFxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAhc2hvdWxkR2V0TmV4dCAmJiBpc0N5Y2xlQWxsb3dlZCA/IGxpc3RbbGlzdExlbmd0aCAtIDFdIDogbGlzdFswXTtcbiAgICB9XG4gICAgaW5kZXggKz0gc2hvdWxkR2V0TmV4dCA/IDEgOiAtMTtcbiAgICBpZiAoaXNDeWNsZUFsbG93ZWQpIHtcbiAgICAgIGluZGV4ID0gKGluZGV4ICsgbGlzdExlbmd0aCkgJSBsaXN0TGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdFtNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgbGlzdExlbmd0aCAtIDEpKV07XG4gIH07XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCBkb20vZXZlbnQtaGFuZGxlci5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IG5hbWVzcGFjZVJlZ2V4ID0gL1teLl0qKD89XFwuLiopXFwufC4qLztcbiAgY29uc3Qgc3RyaXBOYW1lUmVnZXggPSAvXFwuLiovO1xuICBjb25zdCBzdHJpcFVpZFJlZ2V4ID0gLzo6XFxkKyQvO1xuICBjb25zdCBldmVudFJlZ2lzdHJ5ID0ge307IC8vIEV2ZW50cyBzdG9yYWdlXG4gIGxldCB1aWRFdmVudCA9IDE7XG4gIGNvbnN0IGN1c3RvbUV2ZW50cyA9IHtcbiAgICBtb3VzZWVudGVyOiAnbW91c2VvdmVyJyxcbiAgICBtb3VzZWxlYXZlOiAnbW91c2VvdXQnXG4gIH07XG4gIGNvbnN0IG5hdGl2ZUV2ZW50cyA9IG5ldyBTZXQoWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZXVwJywgJ21vdXNlZG93bicsICdjb250ZXh0bWVudScsICdtb3VzZXdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdtb3VzZW1vdmUnLCAnc2VsZWN0c3RhcnQnLCAnc2VsZWN0ZW5kJywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnb3JpZW50YXRpb25jaGFuZ2UnLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnLCAncG9pbnRlcmRvd24nLCAncG9pbnRlcm1vdmUnLCAncG9pbnRlcnVwJywgJ3BvaW50ZXJsZWF2ZScsICdwb2ludGVyY2FuY2VsJywgJ2dlc3R1cmVzdGFydCcsICdnZXN0dXJlY2hhbmdlJywgJ2dlc3R1cmVlbmQnLCAnZm9jdXMnLCAnYmx1cicsICdjaGFuZ2UnLCAncmVzZXQnLCAnc2VsZWN0JywgJ3N1Ym1pdCcsICdmb2N1c2luJywgJ2ZvY3Vzb3V0JywgJ2xvYWQnLCAndW5sb2FkJywgJ2JlZm9yZXVubG9hZCcsICdyZXNpemUnLCAnbW92ZScsICdET01Db250ZW50TG9hZGVkJywgJ3JlYWR5c3RhdGVjaGFuZ2UnLCAnZXJyb3InLCAnYWJvcnQnLCAnc2Nyb2xsJ10pO1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIG1ldGhvZHNcbiAgICovXG5cbiAgZnVuY3Rpb24gbWFrZUV2ZW50VWlkKGVsZW1lbnQsIHVpZCkge1xuICAgIHJldHVybiB1aWQgJiYgYCR7dWlkfTo6JHt1aWRFdmVudCsrfWAgfHwgZWxlbWVudC51aWRFdmVudCB8fCB1aWRFdmVudCsrO1xuICB9XG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRFdmVudHMoZWxlbWVudCkge1xuICAgIGNvbnN0IHVpZCA9IG1ha2VFdmVudFVpZChlbGVtZW50KTtcbiAgICBlbGVtZW50LnVpZEV2ZW50ID0gdWlkO1xuICAgIGV2ZW50UmVnaXN0cnlbdWlkXSA9IGV2ZW50UmVnaXN0cnlbdWlkXSB8fCB7fTtcbiAgICByZXR1cm4gZXZlbnRSZWdpc3RyeVt1aWRdO1xuICB9XG4gIGZ1bmN0aW9uIGJvb3RzdHJhcEhhbmRsZXIoZWxlbWVudCwgZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgICAgaHlkcmF0ZU9iaihldmVudCwge1xuICAgICAgICBkZWxlZ2F0ZVRhcmdldDogZWxlbWVudFxuICAgICAgfSk7XG4gICAgICBpZiAoaGFuZGxlci5vbmVPZmYpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCBldmVudC50eXBlLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm4uYXBwbHkoZWxlbWVudCwgW2V2ZW50XSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBib290c3RyYXBEZWxlZ2F0aW9uSGFuZGxlcihlbGVtZW50LCBzZWxlY3RvciwgZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgICAgY29uc3QgZG9tRWxlbWVudHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgZm9yIChsZXQge1xuICAgICAgICB0YXJnZXRcbiAgICAgIH0gPSBldmVudDsgdGFyZ2V0ICYmIHRhcmdldCAhPT0gdGhpczsgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBkb21FbGVtZW50IG9mIGRvbUVsZW1lbnRzKSB7XG4gICAgICAgICAgaWYgKGRvbUVsZW1lbnQgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh5ZHJhdGVPYmooZXZlbnQsIHtcbiAgICAgICAgICAgIGRlbGVnYXRlVGFyZ2V0OiB0YXJnZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoaGFuZGxlci5vbmVPZmYpIHtcbiAgICAgICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgZXZlbnQudHlwZSwgc2VsZWN0b3IsIGZuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRhcmdldCwgW2V2ZW50XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGZpbmRIYW5kbGVyKGV2ZW50cywgY2FsbGFibGUsIGRlbGVnYXRpb25TZWxlY3RvciA9IG51bGwpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhldmVudHMpLmZpbmQoZXZlbnQgPT4gZXZlbnQuY2FsbGFibGUgPT09IGNhbGxhYmxlICYmIGV2ZW50LmRlbGVnYXRpb25TZWxlY3RvciA9PT0gZGVsZWdhdGlvblNlbGVjdG9yKTtcbiAgfVxuICBmdW5jdGlvbiBub3JtYWxpemVQYXJhbWV0ZXJzKG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pIHtcbiAgICBjb25zdCBpc0RlbGVnYXRlZCA9IHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJztcbiAgICAvLyBUT0RPOiB0b29sdGlwIHBhc3NlcyBgZmFsc2VgIGluc3RlYWQgb2Ygc2VsZWN0b3IsIHNvIHdlIG5lZWQgdG8gY2hlY2tcbiAgICBjb25zdCBjYWxsYWJsZSA9IGlzRGVsZWdhdGVkID8gZGVsZWdhdGlvbkZ1bmN0aW9uIDogaGFuZGxlciB8fCBkZWxlZ2F0aW9uRnVuY3Rpb247XG4gICAgbGV0IHR5cGVFdmVudCA9IGdldFR5cGVFdmVudChvcmlnaW5hbFR5cGVFdmVudCk7XG4gICAgaWYgKCFuYXRpdmVFdmVudHMuaGFzKHR5cGVFdmVudCkpIHtcbiAgICAgIHR5cGVFdmVudCA9IG9yaWdpbmFsVHlwZUV2ZW50O1xuICAgIH1cbiAgICByZXR1cm4gW2lzRGVsZWdhdGVkLCBjYWxsYWJsZSwgdHlwZUV2ZW50XTtcbiAgfVxuICBmdW5jdGlvbiBhZGRIYW5kbGVyKGVsZW1lbnQsIG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24sIG9uZU9mZikge1xuICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUeXBlRXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdID0gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKTtcblxuICAgIC8vIGluIGNhc2Ugb2YgbW91c2VlbnRlciBvciBtb3VzZWxlYXZlIHdyYXAgdGhlIGhhbmRsZXIgd2l0aGluIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgZm9yIGl0cyBET00gcG9zaXRpb25cbiAgICAvLyB0aGlzIHByZXZlbnRzIHRoZSBoYW5kbGVyIGZyb20gYmVpbmcgZGlzcGF0Y2hlZCB0aGUgc2FtZSB3YXkgYXMgbW91c2VvdmVyIG9yIG1vdXNlb3V0IGRvZXNcbiAgICBpZiAob3JpZ2luYWxUeXBlRXZlbnQgaW4gY3VzdG9tRXZlbnRzKSB7XG4gICAgICBjb25zdCB3cmFwRnVuY3Rpb24gPSBmbiA9PiB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoIWV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQucmVsYXRlZFRhcmdldCAhPT0gZXZlbnQuZGVsZWdhdGVUYXJnZXQgJiYgIWV2ZW50LmRlbGVnYXRlVGFyZ2V0LmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGNhbGxhYmxlID0gd3JhcEZ1bmN0aW9uKGNhbGxhYmxlKTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRzID0gZ2V0RWxlbWVudEV2ZW50cyhlbGVtZW50KTtcbiAgICBjb25zdCBoYW5kbGVycyA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IChldmVudHNbdHlwZUV2ZW50XSA9IHt9KTtcbiAgICBjb25zdCBwcmV2aW91c0Z1bmN0aW9uID0gZmluZEhhbmRsZXIoaGFuZGxlcnMsIGNhbGxhYmxlLCBpc0RlbGVnYXRlZCA/IGhhbmRsZXIgOiBudWxsKTtcbiAgICBpZiAocHJldmlvdXNGdW5jdGlvbikge1xuICAgICAgcHJldmlvdXNGdW5jdGlvbi5vbmVPZmYgPSBwcmV2aW91c0Z1bmN0aW9uLm9uZU9mZiAmJiBvbmVPZmY7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVpZCA9IG1ha2VFdmVudFVpZChjYWxsYWJsZSwgb3JpZ2luYWxUeXBlRXZlbnQucmVwbGFjZShuYW1lc3BhY2VSZWdleCwgJycpKTtcbiAgICBjb25zdCBmbiA9IGlzRGVsZWdhdGVkID8gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgaGFuZGxlciwgY2FsbGFibGUpIDogYm9vdHN0cmFwSGFuZGxlcihlbGVtZW50LCBjYWxsYWJsZSk7XG4gICAgZm4uZGVsZWdhdGlvblNlbGVjdG9yID0gaXNEZWxlZ2F0ZWQgPyBoYW5kbGVyIDogbnVsbDtcbiAgICBmbi5jYWxsYWJsZSA9IGNhbGxhYmxlO1xuICAgIGZuLm9uZU9mZiA9IG9uZU9mZjtcbiAgICBmbi51aWRFdmVudCA9IHVpZDtcbiAgICBoYW5kbGVyc1t1aWRdID0gZm47XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGVFdmVudCwgZm4sIGlzRGVsZWdhdGVkKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uU2VsZWN0b3IpIHtcbiAgICBjb25zdCBmbiA9IGZpbmRIYW5kbGVyKGV2ZW50c1t0eXBlRXZlbnRdLCBoYW5kbGVyLCBkZWxlZ2F0aW9uU2VsZWN0b3IpO1xuICAgIGlmICghZm4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGVFdmVudCwgZm4sIEJvb2xlYW4oZGVsZWdhdGlvblNlbGVjdG9yKSk7XG4gICAgZGVsZXRlIGV2ZW50c1t0eXBlRXZlbnRdW2ZuLnVpZEV2ZW50XTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIG5hbWVzcGFjZSkge1xuICAgIGNvbnN0IHN0b3JlRWxlbWVudEV2ZW50ID0gZXZlbnRzW3R5cGVFdmVudF0gfHwge307XG4gICAgZm9yIChjb25zdCBbaGFuZGxlcktleSwgZXZlbnRdIG9mIE9iamVjdC5lbnRyaWVzKHN0b3JlRWxlbWVudEV2ZW50KSkge1xuICAgICAgaWYgKGhhbmRsZXJLZXkuaW5jbHVkZXMobmFtZXNwYWNlKSkge1xuICAgICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBldmVudC5jYWxsYWJsZSwgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VHlwZUV2ZW50KGV2ZW50KSB7XG4gICAgLy8gYWxsb3cgdG8gZ2V0IHRoZSBuYXRpdmUgZXZlbnRzIGZyb20gbmFtZXNwYWNlZCBldmVudHMgKCdjbGljay5icy5idXR0b24nIC0tPiAnY2xpY2snKVxuICAgIGV2ZW50ID0gZXZlbnQucmVwbGFjZShzdHJpcE5hbWVSZWdleCwgJycpO1xuICAgIHJldHVybiBjdXN0b21FdmVudHNbZXZlbnRdIHx8IGV2ZW50O1xuICB9XG4gIGNvbnN0IEV2ZW50SGFuZGxlciA9IHtcbiAgICBvbihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XG4gICAgICBhZGRIYW5kbGVyKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24sIGZhbHNlKTtcbiAgICB9LFxuICAgIG9uZShlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XG4gICAgICBhZGRIYW5kbGVyKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24sIHRydWUpO1xuICAgIH0sXG4gICAgb2ZmKGVsZW1lbnQsIG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pIHtcbiAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUeXBlRXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtpc0RlbGVnYXRlZCwgY2FsbGFibGUsIHR5cGVFdmVudF0gPSBub3JtYWxpemVQYXJhbWV0ZXJzKG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pO1xuICAgICAgY29uc3QgaW5OYW1lc3BhY2UgPSB0eXBlRXZlbnQgIT09IG9yaWdpbmFsVHlwZUV2ZW50O1xuICAgICAgY29uc3QgZXZlbnRzID0gZ2V0RWxlbWVudEV2ZW50cyhlbGVtZW50KTtcbiAgICAgIGNvbnN0IHN0b3JlRWxlbWVudEV2ZW50ID0gZXZlbnRzW3R5cGVFdmVudF0gfHwge307XG4gICAgICBjb25zdCBpc05hbWVzcGFjZSA9IG9yaWdpbmFsVHlwZUV2ZW50LnN0YXJ0c1dpdGgoJy4nKTtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGFibGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIFNpbXBsZXN0IGNhc2U6IGhhbmRsZXIgaXMgcGFzc2VkLCByZW1vdmUgdGhhdCBsaXN0ZW5lciBPTkxZLlxuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHN0b3JlRWxlbWVudEV2ZW50KS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgY2FsbGFibGUsIGlzRGVsZWdhdGVkID8gaGFuZGxlciA6IG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNOYW1lc3BhY2UpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50RXZlbnQgb2YgT2JqZWN0LmtleXMoZXZlbnRzKSkge1xuICAgICAgICAgIHJlbW92ZU5hbWVzcGFjZWRIYW5kbGVycyhlbGVtZW50LCBldmVudHMsIGVsZW1lbnRFdmVudCwgb3JpZ2luYWxUeXBlRXZlbnQuc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFtrZXlIYW5kbGVycywgZXZlbnRdIG9mIE9iamVjdC5lbnRyaWVzKHN0b3JlRWxlbWVudEV2ZW50KSkge1xuICAgICAgICBjb25zdCBoYW5kbGVyS2V5ID0ga2V5SGFuZGxlcnMucmVwbGFjZShzdHJpcFVpZFJlZ2V4LCAnJyk7XG4gICAgICAgIGlmICghaW5OYW1lc3BhY2UgfHwgb3JpZ2luYWxUeXBlRXZlbnQuaW5jbHVkZXMoaGFuZGxlcktleSkpIHtcbiAgICAgICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBldmVudC5jYWxsYWJsZSwgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgdHJpZ2dlcihlbGVtZW50LCBldmVudCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBldmVudCAhPT0gJ3N0cmluZycgfHwgIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCAkID0gZ2V0alF1ZXJ5KCk7XG4gICAgICBjb25zdCB0eXBlRXZlbnQgPSBnZXRUeXBlRXZlbnQoZXZlbnQpO1xuICAgICAgY29uc3QgaW5OYW1lc3BhY2UgPSBldmVudCAhPT0gdHlwZUV2ZW50O1xuICAgICAgbGV0IGpRdWVyeUV2ZW50ID0gbnVsbDtcbiAgICAgIGxldCBidWJibGVzID0gdHJ1ZTtcbiAgICAgIGxldCBuYXRpdmVEaXNwYXRjaCA9IHRydWU7XG4gICAgICBsZXQgZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuICAgICAgaWYgKGluTmFtZXNwYWNlICYmICQpIHtcbiAgICAgICAgalF1ZXJ5RXZlbnQgPSAkLkV2ZW50KGV2ZW50LCBhcmdzKTtcbiAgICAgICAgJChlbGVtZW50KS50cmlnZ2VyKGpRdWVyeUV2ZW50KTtcbiAgICAgICAgYnViYmxlcyA9ICFqUXVlcnlFdmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpO1xuICAgICAgICBuYXRpdmVEaXNwYXRjaCA9ICFqUXVlcnlFdmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpO1xuICAgICAgICBkZWZhdWx0UHJldmVudGVkID0galF1ZXJ5RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBldnQgPSBoeWRyYXRlT2JqKG5ldyBFdmVudChldmVudCwge1xuICAgICAgICBidWJibGVzLFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICB9KSwgYXJncyk7XG4gICAgICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChuYXRpdmVEaXNwYXRjaCkge1xuICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChldnQuZGVmYXVsdFByZXZlbnRlZCAmJiBqUXVlcnlFdmVudCkge1xuICAgICAgICBqUXVlcnlFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV2dDtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGh5ZHJhdGVPYmoob2JqLCBtZXRhID0ge30pIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtZXRhKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCBkb20vbWFuaXB1bGF0b3IuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZURhdGEodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09ICd0cnVlJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IE51bWJlcih2YWx1ZSkudG9TdHJpbmcoKSkge1xuICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09ICdudWxsJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZURhdGFLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5yZXBsYWNlKC9bQS1aXS9nLCBjaHIgPT4gYC0ke2Noci50b0xvd2VyQ2FzZSgpfWApO1xuICB9XG4gIGNvbnN0IE1hbmlwdWxhdG9yID0ge1xuICAgIHNldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5LCB2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCwgdmFsdWUpO1xuICAgIH0sXG4gICAgcmVtb3ZlRGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXkpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGBkYXRhLWJzLSR7bm9ybWFsaXplRGF0YUtleShrZXkpfWApO1xuICAgIH0sXG4gICAgZ2V0RGF0YUF0dHJpYnV0ZXMoZWxlbWVudCkge1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgIGNvbnN0IGJzS2V5cyA9IE9iamVjdC5rZXlzKGVsZW1lbnQuZGF0YXNldCkuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aCgnYnMnKSAmJiAha2V5LnN0YXJ0c1dpdGgoJ2JzQ29uZmlnJykpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgYnNLZXlzKSB7XG4gICAgICAgIGxldCBwdXJlS2V5ID0ga2V5LnJlcGxhY2UoL15icy8sICcnKTtcbiAgICAgICAgcHVyZUtleSA9IHB1cmVLZXkuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBwdXJlS2V5LnNsaWNlKDEsIHB1cmVLZXkubGVuZ3RoKTtcbiAgICAgICAgYXR0cmlidXRlc1twdXJlS2V5XSA9IG5vcm1hbGl6ZURhdGEoZWxlbWVudC5kYXRhc2V0W2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfSxcbiAgICBnZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIGtleSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZURhdGEoZWxlbWVudC5nZXRBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIHV0aWwvY29uZmlnLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIENvbmZpZyB7XG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgaGF2ZSB0byBpbXBsZW1lbnQgdGhlIHN0YXRpYyBtZXRob2QgXCJOQU1FXCIsIGZvciBlYWNoIGNvbXBvbmVudCEnKTtcbiAgICB9XG4gICAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9IHRoaXMuX21lcmdlQ29uZmlnT2JqKGNvbmZpZyk7XG4gICAgICBjb25maWcgPSB0aGlzLl9jb25maWdBZnRlck1lcmdlKGNvbmZpZyk7XG4gICAgICB0aGlzLl90eXBlQ2hlY2tDb25maWcoY29uZmlnKTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gICAgX21lcmdlQ29uZmlnT2JqKGNvbmZpZywgZWxlbWVudCkge1xuICAgICAgY29uc3QganNvbkNvbmZpZyA9IGlzRWxlbWVudCQxKGVsZW1lbnQpID8gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCAnY29uZmlnJykgOiB7fTsgLy8gdHJ5IHRvIHBhcnNlXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxcbiAgICAgICAgLi4uKHR5cGVvZiBqc29uQ29uZmlnID09PSAnb2JqZWN0JyA/IGpzb25Db25maWcgOiB7fSksXG4gICAgICAgIC4uLihpc0VsZW1lbnQkMShlbGVtZW50KSA/IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKGVsZW1lbnQpIDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiB7fSlcbiAgICAgIH07XG4gICAgfVxuICAgIF90eXBlQ2hlY2tDb25maWcoY29uZmlnLCBjb25maWdUeXBlcyA9IHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpIHtcbiAgICAgIGZvciAoY29uc3QgW3Byb3BlcnR5LCBleHBlY3RlZFR5cGVzXSBvZiBPYmplY3QuZW50cmllcyhjb25maWdUeXBlcykpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb25maWdbcHJvcGVydHldO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSBpc0VsZW1lbnQkMSh2YWx1ZSkgPyAnZWxlbWVudCcgOiB0b1R5cGUodmFsdWUpO1xuICAgICAgICBpZiAoIW5ldyBSZWdFeHAoZXhwZWN0ZWRUeXBlcykudGVzdCh2YWx1ZVR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUUudG9VcHBlckNhc2UoKX06IE9wdGlvbiBcIiR7cHJvcGVydHl9XCIgcHJvdmlkZWQgdHlwZSBcIiR7dmFsdWVUeXBlfVwiIGJ1dCBleHBlY3RlZCB0eXBlIFwiJHtleHBlY3RlZFR5cGVzfVwiLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCBiYXNlLWNvbXBvbmVudC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IFZFUlNJT04gPSAnNS4zLjMnO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIEJhc2VDb21wb25lbnQgZXh0ZW5kcyBDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIGVsZW1lbnQgPSBnZXRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgICBEYXRhLnNldCh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICBkaXNwb3NlKCkge1xuICAgICAgRGF0YS5yZW1vdmUodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSk7XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRVZFTlRfS0VZKTtcbiAgICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIF9xdWV1ZUNhbGxiYWNrKGNhbGxiYWNrLCBlbGVtZW50LCBpc0FuaW1hdGVkID0gdHJ1ZSkge1xuICAgICAgZXhlY3V0ZUFmdGVyVHJhbnNpdGlvbihjYWxsYmFjaywgZWxlbWVudCwgaXNBbmltYXRlZCk7XG4gICAgfVxuICAgIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgICBjb25maWcgPSB0aGlzLl9tZXJnZUNvbmZpZ09iaihjb25maWcsIHRoaXMuX2VsZW1lbnQpO1xuICAgICAgY29uZmlnID0gdGhpcy5fY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpO1xuICAgICAgdGhpcy5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIC8vIFN0YXRpY1xuICAgIHN0YXRpYyBnZXRJbnN0YW5jZShlbGVtZW50KSB7XG4gICAgICByZXR1cm4gRGF0YS5nZXQoZ2V0RWxlbWVudChlbGVtZW50KSwgdGhpcy5EQVRBX0tFWSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIGNvbmZpZyA9IHt9KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZShlbGVtZW50KSB8fCBuZXcgdGhpcyhlbGVtZW50LCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IG51bGwpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgICByZXR1cm4gVkVSU0lPTjtcbiAgICB9XG4gICAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICAgIHJldHVybiBgYnMuJHt0aGlzLk5BTUV9YDtcbiAgICB9XG4gICAgc3RhdGljIGdldCBFVkVOVF9LRVkoKSB7XG4gICAgICByZXR1cm4gYC4ke3RoaXMuREFUQV9LRVl9YDtcbiAgICB9XG4gICAgc3RhdGljIGV2ZW50TmFtZShuYW1lKSB7XG4gICAgICByZXR1cm4gYCR7bmFtZX0ke3RoaXMuRVZFTlRfS0VZfWA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCBkb20vc2VsZWN0b3ItZW5naW5lLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICBjb25zdCBnZXRTZWxlY3RvciA9IGVsZW1lbnQgPT4ge1xuICAgIGxldCBzZWxlY3RvciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLXRhcmdldCcpO1xuICAgIGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09ICcjJykge1xuICAgICAgbGV0IGhyZWZBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXG4gICAgICAvLyBUaGUgb25seSB2YWxpZCBjb250ZW50IHRoYXQgY291bGQgZG91YmxlIGFzIGEgc2VsZWN0b3IgYXJlIElEcyBvciBjbGFzc2VzLFxuICAgICAgLy8gc28gZXZlcnl0aGluZyBzdGFydGluZyB3aXRoIGAjYCBvciBgLmAuIElmIGEgXCJyZWFsXCIgVVJMIGlzIHVzZWQgYXMgdGhlIHNlbGVjdG9yLFxuICAgICAgLy8gYGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JgIHdpbGwgcmlnaHRmdWxseSBjb21wbGFpbiBpdCBpcyBpbnZhbGlkLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9pc3N1ZXMvMzIyNzNcbiAgICAgIGlmICghaHJlZkF0dHJpYnV0ZSB8fCAhaHJlZkF0dHJpYnV0ZS5pbmNsdWRlcygnIycpICYmICFocmVmQXR0cmlidXRlLnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gSnVzdCBpbiBjYXNlIHNvbWUgQ01TIHB1dHMgb3V0IGEgZnVsbCBVUkwgd2l0aCB0aGUgYW5jaG9yIGFwcGVuZGVkXG4gICAgICBpZiAoaHJlZkF0dHJpYnV0ZS5pbmNsdWRlcygnIycpICYmICFocmVmQXR0cmlidXRlLnN0YXJ0c1dpdGgoJyMnKSkge1xuICAgICAgICBocmVmQXR0cmlidXRlID0gYCMke2hyZWZBdHRyaWJ1dGUuc3BsaXQoJyMnKVsxXX1gO1xuICAgICAgfVxuICAgICAgc2VsZWN0b3IgPSBocmVmQXR0cmlidXRlICYmIGhyZWZBdHRyaWJ1dGUgIT09ICcjJyA/IGhyZWZBdHRyaWJ1dGUudHJpbSgpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdG9yID8gc2VsZWN0b3Iuc3BsaXQoJywnKS5tYXAoc2VsID0+IHBhcnNlU2VsZWN0b3Ioc2VsKSkuam9pbignLCcpIDogbnVsbDtcbiAgfTtcbiAgY29uc3QgU2VsZWN0b3JFbmdpbmUgPSB7XG4gICAgZmluZChzZWxlY3RvciwgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdCguLi5FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpKTtcbiAgICB9LFxuICAgIGZpbmRPbmUoc2VsZWN0b3IsIGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBFbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH0sXG4gICAgY2hpbGRyZW4oZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoLi4uZWxlbWVudC5jaGlsZHJlbikuZmlsdGVyKGNoaWxkID0+IGNoaWxkLm1hdGNoZXMoc2VsZWN0b3IpKTtcbiAgICB9LFxuICAgIHBhcmVudHMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgIGxldCBhbmNlc3RvciA9IGVsZW1lbnQucGFyZW50Tm9kZS5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICBwYXJlbnRzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGUuY2xvc2VzdChzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9LFxuICAgIHByZXYoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIGxldCBwcmV2aW91cyA9IGVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICAgIHdoaWxlIChwcmV2aW91cykge1xuICAgICAgICBpZiAocHJldmlvdXMubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gW3ByZXZpb3VzXTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IHByZXZpb3VzLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICAvLyBUT0RPOiB0aGlzIGlzIG5vdyB1bnVzZWQ7IHJlbW92ZSBsYXRlciBhbG9uZyB3aXRoIHByZXYoKVxuICAgIG5leHQoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIGxldCBuZXh0ID0gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICBpZiAobmV4dC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICAgIHJldHVybiBbbmV4dF07XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCA9IG5leHQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgZm9jdXNhYmxlQ2hpbGRyZW4oZWxlbWVudCkge1xuICAgICAgY29uc3QgZm9jdXNhYmxlcyA9IFsnYScsICdidXR0b24nLCAnaW5wdXQnLCAndGV4dGFyZWEnLCAnc2VsZWN0JywgJ2RldGFpbHMnLCAnW3RhYmluZGV4XScsICdbY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiXSddLm1hcChzZWxlY3RvciA9PiBgJHtzZWxlY3Rvcn06bm90KFt0YWJpbmRleF49XCItXCJdKWApLmpvaW4oJywnKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmQoZm9jdXNhYmxlcywgZWxlbWVudCkuZmlsdGVyKGVsID0+ICFpc0Rpc2FibGVkKGVsKSAmJiBpc1Zpc2libGUoZWwpKTtcbiAgICB9LFxuICAgIGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihlbGVtZW50KTtcbiAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShzZWxlY3RvcikgPyBzZWxlY3RvciA6IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCkge1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihlbGVtZW50KTtcbiAgICAgIHJldHVybiBzZWxlY3RvciA/IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoc2VsZWN0b3IpIDogbnVsbDtcbiAgICB9LFxuICAgIGdldE11bHRpcGxlRWxlbWVudHNGcm9tU2VsZWN0b3IoZWxlbWVudCkge1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihlbGVtZW50KTtcbiAgICAgIHJldHVybiBzZWxlY3RvciA/IFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpIDogW107XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgdXRpbC9jb21wb25lbnQtZnVuY3Rpb25zLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICBjb25zdCBlbmFibGVEaXNtaXNzVHJpZ2dlciA9IChjb21wb25lbnQsIG1ldGhvZCA9ICdoaWRlJykgPT4ge1xuICAgIGNvbnN0IGNsaWNrRXZlbnQgPSBgY2xpY2suZGlzbWlzcyR7Y29tcG9uZW50LkVWRU5UX0tFWX1gO1xuICAgIGNvbnN0IG5hbWUgPSBjb21wb25lbnQuTkFNRTtcbiAgICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIGNsaWNrRXZlbnQsIGBbZGF0YS1icy1kaXNtaXNzPVwiJHtuYW1lfVwiXWAsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGlzYWJsZWQodGhpcykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0ID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKSB8fCB0aGlzLmNsb3Nlc3QoYC4ke25hbWV9YCk7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGNvbXBvbmVudC5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XG5cbiAgICAgIC8vIE1ldGhvZCBhcmd1bWVudCBpcyBsZWZ0LCBmb3IgQWxlcnQgYW5kIG9ubHksIGFzIGl0IGRvZXNuJ3QgaW1wbGVtZW50IHRoZSAnaGlkZScgbWV0aG9kXG4gICAgICBpbnN0YW5jZVttZXRob2RdKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCBhbGVydC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkZiA9ICdhbGVydCc7XG4gIGNvbnN0IERBVEFfS0VZJGEgPSAnYnMuYWxlcnQnO1xuICBjb25zdCBFVkVOVF9LRVkkYiA9IGAuJHtEQVRBX0tFWSRhfWA7XG4gIGNvbnN0IEVWRU5UX0NMT1NFID0gYGNsb3NlJHtFVkVOVF9LRVkkYn1gO1xuICBjb25zdCBFVkVOVF9DTE9TRUQgPSBgY2xvc2VkJHtFVkVOVF9LRVkkYn1gO1xuICBjb25zdCBDTEFTU19OQU1FX0ZBREUkNSA9ICdmYWRlJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDggPSAnc2hvdyc7XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgQWxlcnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkZjtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICBjbG9zZSgpIHtcbiAgICAgIGNvbnN0IGNsb3NlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTE9TRSk7XG4gICAgICBpZiAoY2xvc2VFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckOCk7XG4gICAgICBjb25zdCBpc0FuaW1hdGVkID0gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDUpO1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9kZXN0cm95RWxlbWVudCgpLCB0aGlzLl9lbGVtZW50LCBpc0FuaW1hdGVkKTtcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlXG4gICAgX2Rlc3Ryb3lFbGVtZW50KCkge1xuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMT1NFRCk7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBBbGVydC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAgICovXG5cbiAgZW5hYmxlRGlzbWlzc1RyaWdnZXIoQWxlcnQsICdjbG9zZScpO1xuXG4gIC8qKlxuICAgKiBqUXVlcnlcbiAgICovXG5cbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKEFsZXJ0KTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIGJ1dHRvbi5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkZSA9ICdidXR0b24nO1xuICBjb25zdCBEQVRBX0tFWSQ5ID0gJ2JzLmJ1dHRvbic7XG4gIGNvbnN0IEVWRU5UX0tFWSRhID0gYC4ke0RBVEFfS0VZJDl9YDtcbiAgY29uc3QgREFUQV9BUElfS0VZJDYgPSAnLmRhdGEtYXBpJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUkMyA9ICdhY3RpdmUnO1xuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1ID0gJ1tkYXRhLWJzLXRvZ2dsZT1cImJ1dHRvblwiXSc7XG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDYgPSBgY2xpY2ske0VWRU5UX0tFWSRhfSR7REFUQV9BUElfS0VZJDZ9YDtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBCdXR0b24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkZTtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICB0b2dnbGUoKSB7XG4gICAgICAvLyBUb2dnbGUgY2xhc3MgYW5kIHN5bmMgdGhlIGBhcmlhLXByZXNzZWRgIGF0dHJpYnV0ZSB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGAudG9nZ2xlKClgIG1ldGhvZFxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtcHJlc3NlZCcsIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShDTEFTU19OQU1FX0FDVElWRSQzKSk7XG4gICAgfVxuXG4gICAgLy8gU3RhdGljXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gQnV0dG9uLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gICAgICAgIGlmIChjb25maWcgPT09ICd0b2dnbGUnKSB7XG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICAgKi9cblxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDYsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUsIGV2ZW50ID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IGJ1dHRvbiA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUpO1xuICAgIGNvbnN0IGRhdGEgPSBCdXR0b24uZ2V0T3JDcmVhdGVJbnN0YW5jZShidXR0b24pO1xuICAgIGRhdGEudG9nZ2xlKCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBqUXVlcnlcbiAgICovXG5cbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKEJ1dHRvbik7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCB1dGlsL3N3aXBlLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgTkFNRSRkID0gJ3N3aXBlJztcbiAgY29uc3QgRVZFTlRfS0VZJDkgPSAnLmJzLnN3aXBlJztcbiAgY29uc3QgRVZFTlRfVE9VQ0hTVEFSVCA9IGB0b3VjaHN0YXJ0JHtFVkVOVF9LRVkkOX1gO1xuICBjb25zdCBFVkVOVF9UT1VDSE1PVkUgPSBgdG91Y2htb3ZlJHtFVkVOVF9LRVkkOX1gO1xuICBjb25zdCBFVkVOVF9UT1VDSEVORCA9IGB0b3VjaGVuZCR7RVZFTlRfS0VZJDl9YDtcbiAgY29uc3QgRVZFTlRfUE9JTlRFUkRPV04gPSBgcG9pbnRlcmRvd24ke0VWRU5UX0tFWSQ5fWA7XG4gIGNvbnN0IEVWRU5UX1BPSU5URVJVUCA9IGBwb2ludGVydXAke0VWRU5UX0tFWSQ5fWA7XG4gIGNvbnN0IFBPSU5URVJfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XG4gIGNvbnN0IFBPSU5URVJfVFlQRV9QRU4gPSAncGVuJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9QT0lOVEVSX0VWRU5UID0gJ3BvaW50ZXItZXZlbnQnO1xuICBjb25zdCBTV0lQRV9USFJFU0hPTEQgPSA0MDtcbiAgY29uc3QgRGVmYXVsdCRjID0ge1xuICAgIGVuZENhbGxiYWNrOiBudWxsLFxuICAgIGxlZnRDYWxsYmFjazogbnVsbCxcbiAgICByaWdodENhbGxiYWNrOiBudWxsXG4gIH07XG4gIGNvbnN0IERlZmF1bHRUeXBlJGMgPSB7XG4gICAgZW5kQ2FsbGJhY2s6ICcoZnVuY3Rpb258bnVsbCknLFxuICAgIGxlZnRDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKScsXG4gICAgcmlnaHRDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKSdcbiAgfTtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBTd2lwZSBleHRlbmRzIENvbmZpZyB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICBpZiAoIWVsZW1lbnQgfHwgIVN3aXBlLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgICB0aGlzLl9kZWx0YVggPSAwO1xuICAgICAgdGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMgPSBCb29sZWFuKHdpbmRvdy5Qb2ludGVyRXZlbnQpO1xuICAgICAgdGhpcy5faW5pdEV2ZW50cygpO1xuICAgIH1cblxuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCRjO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJGM7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJGQ7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZJDkpO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfc3RhcnQoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZXZlbnRJc1BvaW50ZXJQZW5Ub3VjaChldmVudCkpIHtcbiAgICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgIH1cbiAgICB9XG4gICAgX2VuZChldmVudCkge1xuICAgICAgaWYgKHRoaXMuX2V2ZW50SXNQb2ludGVyUGVuVG91Y2goZXZlbnQpKSB7XG4gICAgICAgIHRoaXMuX2RlbHRhWCA9IGV2ZW50LmNsaWVudFggLSB0aGlzLl9kZWx0YVg7XG4gICAgICB9XG4gICAgICB0aGlzLl9oYW5kbGVTd2lwZSgpO1xuICAgICAgZXhlY3V0ZSh0aGlzLl9jb25maWcuZW5kQ2FsbGJhY2spO1xuICAgIH1cbiAgICBfbW92ZShldmVudCkge1xuICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEgPyAwIDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYIC0gdGhpcy5fZGVsdGFYO1xuICAgIH1cbiAgICBfaGFuZGxlU3dpcGUoKSB7XG4gICAgICBjb25zdCBhYnNEZWx0YVggPSBNYXRoLmFicyh0aGlzLl9kZWx0YVgpO1xuICAgICAgaWYgKGFic0RlbHRhWCA8PSBTV0lQRV9USFJFU0hPTEQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlyZWN0aW9uID0gYWJzRGVsdGFYIC8gdGhpcy5fZGVsdGFYO1xuICAgICAgdGhpcy5fZGVsdGFYID0gMDtcbiAgICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV4ZWN1dGUoZGlyZWN0aW9uID4gMCA/IHRoaXMuX2NvbmZpZy5yaWdodENhbGxiYWNrIDogdGhpcy5fY29uZmlnLmxlZnRDYWxsYmFjayk7XG4gICAgfVxuICAgIF9pbml0RXZlbnRzKCkge1xuICAgICAgaWYgKHRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9QT0lOVEVSRE9XTiwgZXZlbnQgPT4gdGhpcy5fc3RhcnQoZXZlbnQpKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1BPSU5URVJVUCwgZXZlbnQgPT4gdGhpcy5fZW5kKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNIU1RBUlQsIGV2ZW50ID0+IHRoaXMuX3N0YXJ0KGV2ZW50KSk7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9UT1VDSE1PVkUsIGV2ZW50ID0+IHRoaXMuX21vdmUoZXZlbnQpKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNIRU5ELCBldmVudCA9PiB0aGlzLl9lbmQoZXZlbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX2V2ZW50SXNQb2ludGVyUGVuVG91Y2goZXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdXBwb3J0UG9pbnRlckV2ZW50cyAmJiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9QRU4gfHwgZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9UT1VDSCk7XG4gICAgfVxuXG4gICAgLy8gU3RhdGljXG4gICAgc3RhdGljIGlzU3VwcG9ydGVkKCkge1xuICAgICAgcmV0dXJuICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgY2Fyb3VzZWwuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBOQU1FJGMgPSAnY2Fyb3VzZWwnO1xuICBjb25zdCBEQVRBX0tFWSQ4ID0gJ2JzLmNhcm91c2VsJztcbiAgY29uc3QgRVZFTlRfS0VZJDggPSBgLiR7REFUQV9LRVkkOH1gO1xuICBjb25zdCBEQVRBX0FQSV9LRVkkNSA9ICcuZGF0YS1hcGknO1xuICBjb25zdCBBUlJPV19MRUZUX0tFWSQxID0gJ0Fycm93TGVmdCc7XG4gIGNvbnN0IEFSUk9XX1JJR0hUX0tFWSQxID0gJ0Fycm93UmlnaHQnO1xuICBjb25zdCBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUID0gNTAwOyAvLyBUaW1lIGZvciBtb3VzZSBjb21wYXQgZXZlbnRzIHRvIGZpcmUgYWZ0ZXIgdG91Y2hcblxuICBjb25zdCBPUkRFUl9ORVhUID0gJ25leHQnO1xuICBjb25zdCBPUkRFUl9QUkVWID0gJ3ByZXYnO1xuICBjb25zdCBESVJFQ1RJT05fTEVGVCA9ICdsZWZ0JztcbiAgY29uc3QgRElSRUNUSU9OX1JJR0hUID0gJ3JpZ2h0JztcbiAgY29uc3QgRVZFTlRfU0xJREUgPSBgc2xpZGUke0VWRU5UX0tFWSQ4fWA7XG4gIGNvbnN0IEVWRU5UX1NMSUQgPSBgc2xpZCR7RVZFTlRfS0VZJDh9YDtcbiAgY29uc3QgRVZFTlRfS0VZRE9XTiQxID0gYGtleWRvd24ke0VWRU5UX0tFWSQ4fWA7XG4gIGNvbnN0IEVWRU5UX01PVVNFRU5URVIkMSA9IGBtb3VzZWVudGVyJHtFVkVOVF9LRVkkOH1gO1xuICBjb25zdCBFVkVOVF9NT1VTRUxFQVZFJDEgPSBgbW91c2VsZWF2ZSR7RVZFTlRfS0VZJDh9YDtcbiAgY29uc3QgRVZFTlRfRFJBR19TVEFSVCA9IGBkcmFnc3RhcnQke0VWRU5UX0tFWSQ4fWA7XG4gIGNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkkMyA9IGBsb2FkJHtFVkVOVF9LRVkkOH0ke0RBVEFfQVBJX0tFWSQ1fWA7XG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDUgPSBgY2xpY2ske0VWRU5UX0tFWSQ4fSR7REFUQV9BUElfS0VZJDV9YDtcbiAgY29uc3QgQ0xBU1NfTkFNRV9DQVJPVVNFTCA9ICdjYXJvdXNlbCc7XG4gIGNvbnN0IENMQVNTX05BTUVfQUNUSVZFJDIgPSAnYWN0aXZlJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9TTElERSA9ICdzbGlkZSc7XG4gIGNvbnN0IENMQVNTX05BTUVfRU5EID0gJ2Nhcm91c2VsLWl0ZW0tZW5kJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9TVEFSVCA9ICdjYXJvdXNlbC1pdGVtLXN0YXJ0JztcbiAgY29uc3QgQ0xBU1NfTkFNRV9ORVhUID0gJ2Nhcm91c2VsLWl0ZW0tbmV4dCc7XG4gIGNvbnN0IENMQVNTX05BTUVfUFJFViA9ICdjYXJvdXNlbC1pdGVtLXByZXYnO1xuICBjb25zdCBTRUxFQ1RPUl9BQ1RJVkUgPSAnLmFjdGl2ZSc7XG4gIGNvbnN0IFNFTEVDVE9SX0lURU0gPSAnLmNhcm91c2VsLWl0ZW0nO1xuICBjb25zdCBTRUxFQ1RPUl9BQ1RJVkVfSVRFTSA9IFNFTEVDVE9SX0FDVElWRSArIFNFTEVDVE9SX0lURU07XG4gIGNvbnN0IFNFTEVDVE9SX0lURU1fSU1HID0gJy5jYXJvdXNlbC1pdGVtIGltZyc7XG4gIGNvbnN0IFNFTEVDVE9SX0lORElDQVRPUlMgPSAnLmNhcm91c2VsLWluZGljYXRvcnMnO1xuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1NMSURFID0gJ1tkYXRhLWJzLXNsaWRlXSwgW2RhdGEtYnMtc2xpZGUtdG9dJztcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9SSURFID0gJ1tkYXRhLWJzLXJpZGU9XCJjYXJvdXNlbFwiXSc7XG4gIGNvbnN0IEtFWV9UT19ESVJFQ1RJT04gPSB7XG4gICAgW0FSUk9XX0xFRlRfS0VZJDFdOiBESVJFQ1RJT05fUklHSFQsXG4gICAgW0FSUk9XX1JJR0hUX0tFWSQxXTogRElSRUNUSU9OX0xFRlRcbiAgfTtcbiAgY29uc3QgRGVmYXVsdCRiID0ge1xuICAgIGludGVydmFsOiA1MDAwLFxuICAgIGtleWJvYXJkOiB0cnVlLFxuICAgIHBhdXNlOiAnaG92ZXInLFxuICAgIHJpZGU6IGZhbHNlLFxuICAgIHRvdWNoOiB0cnVlLFxuICAgIHdyYXA6IHRydWVcbiAgfTtcbiAgY29uc3QgRGVmYXVsdFR5cGUkYiA9IHtcbiAgICBpbnRlcnZhbDogJyhudW1iZXJ8Ym9vbGVhbiknLFxuICAgIC8vIFRPRE86djYgcmVtb3ZlIGJvb2xlYW4gc3VwcG9ydFxuICAgIGtleWJvYXJkOiAnYm9vbGVhbicsXG4gICAgcGF1c2U6ICcoc3RyaW5nfGJvb2xlYW4pJyxcbiAgICByaWRlOiAnKGJvb2xlYW58c3RyaW5nKScsXG4gICAgdG91Y2g6ICdib29sZWFuJyxcbiAgICB3cmFwOiAnYm9vbGVhbidcbiAgfTtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBDYXJvdXNlbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnRvdWNoVGltZW91dCA9IG51bGw7XG4gICAgICB0aGlzLl9zd2lwZUhlbHBlciA9IG51bGw7XG4gICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfSU5ESUNBVE9SUywgdGhpcy5fZWxlbWVudCk7XG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5yaWRlID09PSBDTEFTU19OQU1FX0NBUk9VU0VMKSB7XG4gICAgICAgIHRoaXMuY3ljbGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHQkYjtcbiAgICB9XG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSRiO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gTkFNRSRjO1xuICAgIH1cblxuICAgIC8vIFB1YmxpY1xuICAgIG5leHQoKSB7XG4gICAgICB0aGlzLl9zbGlkZShPUkRFUl9ORVhUKTtcbiAgICB9XG4gICAgbmV4dFdoZW5WaXNpYmxlKCkge1xuICAgICAgLy8gRklYTUUgVE9ETyB1c2UgYGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZWBcbiAgICAgIC8vIERvbid0IGNhbGwgbmV4dCB3aGVuIHRoZSBwYWdlIGlzbid0IHZpc2libGVcbiAgICAgIC8vIG9yIHRoZSBjYXJvdXNlbCBvciBpdHMgcGFyZW50IGlzbid0IHZpc2libGVcbiAgICAgIGlmICghZG9jdW1lbnQuaGlkZGVuICYmIGlzVmlzaWJsZSh0aGlzLl9lbGVtZW50KSkge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJldigpIHtcbiAgICAgIHRoaXMuX3NsaWRlKE9SREVSX1BSRVYpO1xuICAgIH1cbiAgICBwYXVzZSgpIHtcbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgICAgdHJpZ2dlclRyYW5zaXRpb25FbmQodGhpcy5fZWxlbWVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jbGVhckludGVydmFsKCk7XG4gICAgfVxuICAgIGN5Y2xlKCkge1xuICAgICAgdGhpcy5fY2xlYXJJbnRlcnZhbCgpO1xuICAgICAgdGhpcy5fdXBkYXRlSW50ZXJ2YWwoKTtcbiAgICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5uZXh0V2hlblZpc2libGUoKSwgdGhpcy5fY29uZmlnLmludGVydmFsKTtcbiAgICB9XG4gICAgX21heWJlRW5hYmxlQ3ljbGUoKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5yaWRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9TTElELCAoKSA9PiB0aGlzLmN5Y2xlKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmN5Y2xlKCk7XG4gICAgfVxuICAgIHRvKGluZGV4KSB7XG4gICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zKCk7XG4gICAgICBpZiAoaW5kZXggPiBpdGVtcy5sZW5ndGggLSAxIHx8IGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgRVZFTlRfU0xJRCwgKCkgPT4gdGhpcy50byhpbmRleCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhY3RpdmVJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9nZXRBY3RpdmUoKSk7XG4gICAgICBpZiAoYWN0aXZlSW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9yZGVyID0gaW5kZXggPiBhY3RpdmVJbmRleCA/IE9SREVSX05FWFQgOiBPUkRFUl9QUkVWO1xuICAgICAgdGhpcy5fc2xpZGUob3JkZXIsIGl0ZW1zW2luZGV4XSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICBpZiAodGhpcy5fc3dpcGVIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5fc3dpcGVIZWxwZXIuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcbiAgICAgIGNvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgPSBjb25maWcuaW50ZXJ2YWw7XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOJDEsIGV2ZW50ID0+IHRoaXMuX2tleWRvd24oZXZlbnQpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgPT09ICdob3ZlcicpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFRU5URVIkMSwgKCkgPT4gdGhpcy5wYXVzZSgpKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFTEVBVkUkMSwgKCkgPT4gdGhpcy5fbWF5YmVFbmFibGVDeWNsZSgpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jb25maWcudG91Y2ggJiYgU3dpcGUuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICB0aGlzLl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIF9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgZm9yIChjb25zdCBpbWcgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNX0lNRywgdGhpcy5fZWxlbWVudCkpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKGltZywgRVZFTlRfRFJBR19TVEFSVCwgZXZlbnQgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBlbmRDYWxsQmFjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSAhPT0gJ2hvdmVyJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0J3MgYSB0b3VjaC1lbmFibGVkIGRldmljZSwgbW91c2VlbnRlci9sZWF2ZSBhcmUgZmlyZWQgYXNcbiAgICAgICAgLy8gcGFydCBvZiB0aGUgbW91c2UgY29tcGF0aWJpbGl0eSBldmVudHMgb24gZmlyc3QgdGFwIC0gdGhlIGNhcm91c2VsXG4gICAgICAgIC8vIHdvdWxkIHN0b3AgY3ljbGluZyB1bnRpbCB1c2VyIHRhcHBlZCBvdXQgb2YgaXQ7XG4gICAgICAgIC8vIGhlcmUsIHdlIGxpc3RlbiBmb3IgdG91Y2hlbmQsIGV4cGxpY2l0bHkgcGF1c2UgdGhlIGNhcm91c2VsXG4gICAgICAgIC8vIChhcyBpZiBpdCdzIHRoZSBzZWNvbmQgdGltZSB3ZSB0YXAgb24gaXQsIG1vdXNlZW50ZXIgY29tcGF0IGV2ZW50XG4gICAgICAgIC8vIGlzIE5PVCBmaXJlZCkgYW5kIGFmdGVyIGEgdGltZW91dCAodG8gYWxsb3cgZm9yIG1vdXNlIGNvbXBhdGliaWxpdHlcbiAgICAgICAgLy8gZXZlbnRzIHRvIGZpcmUpIHdlIGV4cGxpY2l0bHkgcmVzdGFydCBjeWNsaW5nXG5cbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICBpZiAodGhpcy50b3VjaFRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50b3VjaFRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9tYXliZUVuYWJsZUN5Y2xlKCksIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHN3aXBlQ29uZmlnID0ge1xuICAgICAgICBsZWZ0Q2FsbGJhY2s6ICgpID0+IHRoaXMuX3NsaWRlKHRoaXMuX2RpcmVjdGlvblRvT3JkZXIoRElSRUNUSU9OX0xFRlQpKSxcbiAgICAgICAgcmlnaHRDYWxsYmFjazogKCkgPT4gdGhpcy5fc2xpZGUodGhpcy5fZGlyZWN0aW9uVG9PcmRlcihESVJFQ1RJT05fUklHSFQpKSxcbiAgICAgICAgZW5kQ2FsbGJhY2s6IGVuZENhbGxCYWNrXG4gICAgICB9O1xuICAgICAgdGhpcy5fc3dpcGVIZWxwZXIgPSBuZXcgU3dpcGUodGhpcy5fZWxlbWVudCwgc3dpcGVDb25maWcpO1xuICAgIH1cbiAgICBfa2V5ZG93bihldmVudCkge1xuICAgICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IEtFWV9UT19ESVJFQ1RJT05bZXZlbnQua2V5XTtcbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5fc2xpZGUodGhpcy5fZGlyZWN0aW9uVG9PcmRlcihkaXJlY3Rpb24pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX2dldEl0ZW1JbmRleChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0SXRlbXMoKS5pbmRleE9mKGVsZW1lbnQpO1xuICAgIH1cbiAgICBfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChpbmRleCkge1xuICAgICAgaWYgKCF0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhY3RpdmVJbmRpY2F0b3IgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0FDVElWRSwgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpO1xuICAgICAgYWN0aXZlSW5kaWNhdG9yLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XG4gICAgICBhY3RpdmVJbmRpY2F0b3IucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnKTtcbiAgICAgIGNvbnN0IG5ld0FjdGl2ZUluZGljYXRvciA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoYFtkYXRhLWJzLXNsaWRlLXRvPVwiJHtpbmRleH1cIl1gLCB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCk7XG4gICAgICBpZiAobmV3QWN0aXZlSW5kaWNhdG9yKSB7XG4gICAgICAgIG5ld0FjdGl2ZUluZGljYXRvci5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDIpO1xuICAgICAgICBuZXdBY3RpdmVJbmRpY2F0b3Iuc2V0QXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnLCAndHJ1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICBfdXBkYXRlSW50ZXJ2YWwoKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fYWN0aXZlRWxlbWVudCB8fCB0aGlzLl9nZXRBY3RpdmUoKTtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBlbGVtZW50SW50ZXJ2YWwgPSBOdW1iZXIucGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtaW50ZXJ2YWwnKSwgMTApO1xuICAgICAgdGhpcy5fY29uZmlnLmludGVydmFsID0gZWxlbWVudEludGVydmFsIHx8IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWw7XG4gICAgfVxuICAgIF9zbGlkZShvcmRlciwgZWxlbWVudCA9IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IHRoaXMuX2dldEFjdGl2ZSgpO1xuICAgICAgY29uc3QgaXNOZXh0ID0gb3JkZXIgPT09IE9SREVSX05FWFQ7XG4gICAgICBjb25zdCBuZXh0RWxlbWVudCA9IGVsZW1lbnQgfHwgZ2V0TmV4dEFjdGl2ZUVsZW1lbnQodGhpcy5fZ2V0SXRlbXMoKSwgYWN0aXZlRWxlbWVudCwgaXNOZXh0LCB0aGlzLl9jb25maWcud3JhcCk7XG4gICAgICBpZiAobmV4dEVsZW1lbnQgPT09IGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV4dEVsZW1lbnRJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChuZXh0RWxlbWVudCk7XG4gICAgICBjb25zdCB0cmlnZ2VyRXZlbnQgPSBldmVudE5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgZXZlbnROYW1lLCB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogbmV4dEVsZW1lbnQsXG4gICAgICAgICAgZGlyZWN0aW9uOiB0aGlzLl9vcmRlclRvRGlyZWN0aW9uKG9yZGVyKSxcbiAgICAgICAgICBmcm9tOiB0aGlzLl9nZXRJdGVtSW5kZXgoYWN0aXZlRWxlbWVudCksXG4gICAgICAgICAgdG86IG5leHRFbGVtZW50SW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2xpZGVFdmVudCA9IHRyaWdnZXJFdmVudChFVkVOVF9TTElERSk7XG4gICAgICBpZiAoc2xpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghYWN0aXZlRWxlbWVudCB8fCAhbmV4dEVsZW1lbnQpIHtcbiAgICAgICAgLy8gU29tZSB3ZWlyZG5lc3MgaXMgaGFwcGVuaW5nLCBzbyB3ZSBiYWlsXG4gICAgICAgIC8vIFRPRE86IGNoYW5nZSB0ZXN0cyB0aGF0IHVzZSBlbXB0eSBkaXZzIHRvIGF2b2lkIHRoaXMgY2hlY2tcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNDeWNsaW5nID0gQm9vbGVhbih0aGlzLl9pbnRlcnZhbCk7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChuZXh0RWxlbWVudEluZGV4KTtcbiAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gaXNOZXh0ID8gQ0xBU1NfTkFNRV9TVEFSVCA6IENMQVNTX05BTUVfRU5EO1xuICAgICAgY29uc3Qgb3JkZXJDbGFzc05hbWUgPSBpc05leHQgPyBDTEFTU19OQU1FX05FWFQgOiBDTEFTU19OQU1FX1BSRVY7XG4gICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKG9yZGVyQ2xhc3NOYW1lKTtcbiAgICAgIHJlZmxvdyhuZXh0RWxlbWVudCk7XG4gICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xuICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG4gICAgICBjb25zdCBjb21wbGV0ZUNhbGxCYWNrID0gKCkgPT4ge1xuICAgICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGRpcmVjdGlvbmFsQ2xhc3NOYW1lLCBvcmRlckNsYXNzTmFtZSk7XG4gICAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQyLCBvcmRlckNsYXNzTmFtZSwgZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdHJpZ2dlckV2ZW50KEVWRU5UX1NMSUQpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsQmFjaywgYWN0aXZlRWxlbWVudCwgdGhpcy5faXNBbmltYXRlZCgpKTtcbiAgICAgIGlmIChpc0N5Y2xpbmcpIHtcbiAgICAgICAgdGhpcy5jeWNsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBfaXNBbmltYXRlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NMSURFKTtcbiAgICB9XG4gICAgX2dldEFjdGl2ZSgpIHtcbiAgICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0FDVElWRV9JVEVNLCB0aGlzLl9lbGVtZW50KTtcbiAgICB9XG4gICAgX2dldEl0ZW1zKCkge1xuICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSVRFTSwgdGhpcy5fZWxlbWVudCk7XG4gICAgfVxuICAgIF9jbGVhckludGVydmFsKCkge1xuICAgICAgaWYgKHRoaXMuX2ludGVydmFsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIF9kaXJlY3Rpb25Ub09yZGVyKGRpcmVjdGlvbikge1xuICAgICAgaWYgKGlzUlRMKCkpIHtcbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQgPyBPUkRFUl9QUkVWIDogT1JERVJfTkVYVDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09IERJUkVDVElPTl9MRUZUID8gT1JERVJfTkVYVCA6IE9SREVSX1BSRVY7XG4gICAgfVxuICAgIF9vcmRlclRvRGlyZWN0aW9uKG9yZGVyKSB7XG4gICAgICBpZiAoaXNSVEwoKSkge1xuICAgICAgICByZXR1cm4gb3JkZXIgPT09IE9SREVSX1BSRVYgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmRlciA9PT0gT1JERVJfUFJFViA/IERJUkVDVElPTl9SSUdIVCA6IERJUkVDVElPTl9MRUZUO1xuICAgIH1cblxuICAgIC8vIFN0YXRpY1xuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IENhcm91c2VsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZGF0YS50byhjb25maWcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAgICovXG5cbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQ1LCBTRUxFQ1RPUl9EQVRBX1NMSURFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpO1xuICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQ0FST1VTRUwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgY2Fyb3VzZWwgPSBDYXJvdXNlbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XG4gICAgY29uc3Qgc2xpZGVJbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLXNsaWRlLXRvJyk7XG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgIGNhcm91c2VsLnRvKHNsaWRlSW5kZXgpO1xuICAgICAgY2Fyb3VzZWwuX21heWJlRW5hYmxlQ3ljbGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGUodGhpcywgJ3NsaWRlJykgPT09ICduZXh0Jykge1xuICAgICAgY2Fyb3VzZWwubmV4dCgpO1xuICAgICAgY2Fyb3VzZWwuX21heWJlRW5hYmxlQ3ljbGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2Fyb3VzZWwucHJldigpO1xuICAgIGNhcm91c2VsLl9tYXliZUVuYWJsZUN5Y2xlKCk7XG4gIH0pO1xuICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJJDMsICgpID0+IHtcbiAgICBjb25zdCBjYXJvdXNlbHMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfUklERSk7XG4gICAgZm9yIChjb25zdCBjYXJvdXNlbCBvZiBjYXJvdXNlbHMpIHtcbiAgICAgIENhcm91c2VsLmdldE9yQ3JlYXRlSW5zdGFuY2UoY2Fyb3VzZWwpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oQ2Fyb3VzZWwpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgY29sbGFwc2UuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBOQU1FJGIgPSAnY29sbGFwc2UnO1xuICBjb25zdCBEQVRBX0tFWSQ3ID0gJ2JzLmNvbGxhcHNlJztcbiAgY29uc3QgRVZFTlRfS0VZJDcgPSBgLiR7REFUQV9LRVkkN31gO1xuICBjb25zdCBEQVRBX0FQSV9LRVkkNCA9ICcuZGF0YS1hcGknO1xuICBjb25zdCBFVkVOVF9TSE9XJDYgPSBgc2hvdyR7RVZFTlRfS0VZJDd9YDtcbiAgY29uc3QgRVZFTlRfU0hPV04kNiA9IGBzaG93biR7RVZFTlRfS0VZJDd9YDtcbiAgY29uc3QgRVZFTlRfSElERSQ2ID0gYGhpZGUke0VWRU5UX0tFWSQ3fWA7XG4gIGNvbnN0IEVWRU5UX0hJRERFTiQ2ID0gYGhpZGRlbiR7RVZFTlRfS0VZJDd9YDtcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNCA9IGBjbGljayR7RVZFTlRfS0VZJDd9JHtEQVRBX0FQSV9LRVkkNH1gO1xuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckNyA9ICdzaG93JztcbiAgY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTRSA9ICdjb2xsYXBzZSc7XG4gIGNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0lORyA9ICdjb2xsYXBzaW5nJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTRUQgPSAnY29sbGFwc2VkJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9ERUVQRVJfQ0hJTERSRU4gPSBgOnNjb3BlIC4ke0NMQVNTX05BTUVfQ09MTEFQU0V9IC4ke0NMQVNTX05BTUVfQ09MTEFQU0V9YDtcbiAgY29uc3QgQ0xBU1NfTkFNRV9IT1JJWk9OVEFMID0gJ2NvbGxhcHNlLWhvcml6b250YWwnO1xuICBjb25zdCBXSURUSCA9ICd3aWR0aCc7XG4gIGNvbnN0IEhFSUdIVCA9ICdoZWlnaHQnO1xuICBjb25zdCBTRUxFQ1RPUl9BQ1RJVkVTID0gJy5jb2xsYXBzZS5zaG93LCAuY29sbGFwc2UuY29sbGFwc2luZyc7XG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQgPSAnW2RhdGEtYnMtdG9nZ2xlPVwiY29sbGFwc2VcIl0nO1xuICBjb25zdCBEZWZhdWx0JGEgPSB7XG4gICAgcGFyZW50OiBudWxsLFxuICAgIHRvZ2dsZTogdHJ1ZVxuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSRhID0ge1xuICAgIHBhcmVudDogJyhudWxsfGVsZW1lbnQpJyxcbiAgICB0b2dnbGU6ICdib29sZWFuJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIENvbGxhcHNlIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl90cmlnZ2VyQXJyYXkgPSBbXTtcbiAgICAgIGNvbnN0IHRvZ2dsZUxpc3QgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQpO1xuICAgICAgZm9yIChjb25zdCBlbGVtIG9mIHRvZ2dsZUxpc3QpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBTZWxlY3RvckVuZ2luZS5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW0pO1xuICAgICAgICBjb25zdCBmaWx0ZXJFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvcikuZmlsdGVyKGZvdW5kRWxlbWVudCA9PiBmb3VuZEVsZW1lbnQgPT09IHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwgJiYgZmlsdGVyRWxlbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl90cmlnZ2VyQXJyYXkucHVzaChlbGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faW5pdGlhbGl6ZUNoaWxkcmVuKCk7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgdGhpcy5faXNTaG93bigpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jb25maWcudG9nZ2xlKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0JGE7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkYTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkYjtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICB0b2dnbGUoKSB7XG4gICAgICBpZiAodGhpcy5faXNTaG93bigpKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNob3coKSB7XG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IHRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgYWN0aXZlQ2hpbGRyZW4gPSBbXTtcblxuICAgICAgLy8gZmluZCBhY3RpdmUgY2hpbGRyZW5cbiAgICAgIGlmICh0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICAgIGFjdGl2ZUNoaWxkcmVuID0gdGhpcy5fZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKFNFTEVDVE9SX0FDVElWRVMpLmZpbHRlcihlbGVtZW50ID0+IGVsZW1lbnQgIT09IHRoaXMuX2VsZW1lbnQpLm1hcChlbGVtZW50ID0+IENvbGxhcHNlLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCwge1xuICAgICAgICAgIHRvZ2dsZTogZmFsc2VcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgaWYgKGFjdGl2ZUNoaWxkcmVuLmxlbmd0aCAmJiBhY3RpdmVDaGlsZHJlblswXS5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDYpO1xuICAgICAgaWYgKHN0YXJ0RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGFjdGl2ZUluc3RhbmNlIG9mIGFjdGl2ZUNoaWxkcmVuKSB7XG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLmhpZGUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0UpO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAwO1xuICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgdHJ1ZSk7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0UsIENMQVNTX05BTUVfU0hPVyQ3KTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDYpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNhcGl0YWxpemVkRGltZW5zaW9uID0gZGltZW5zaW9uWzBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoMSk7XG4gICAgICBjb25zdCBzY3JvbGxTaXplID0gYHNjcm9sbCR7Y2FwaXRhbGl6ZWREaW1lbnNpb259YDtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRydWUpO1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudFtzY3JvbGxTaXplXX1weGA7XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICF0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNik7XG4gICAgICBpZiAoc3RhcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpO1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkaW1lbnNpb25dfXB4YDtcbiAgICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0UsIENMQVNTX05BTUVfU0hPVyQ3KTtcbiAgICAgIGZvciAoY29uc3QgdHJpZ2dlciBvZiB0aGlzLl90cmlnZ2VyQXJyYXkpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IodHJpZ2dlcik7XG4gICAgICAgIGlmIChlbGVtZW50ICYmICF0aGlzLl9pc1Nob3duKGVsZW1lbnQpKSB7XG4gICAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFt0cmlnZ2VyXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0UpO1xuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kNik7XG4gICAgICB9O1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0cnVlKTtcbiAgICB9XG4gICAgX2lzU2hvd24oZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckNyk7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZVxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xuICAgICAgY29uZmlnLnRvZ2dsZSA9IEJvb2xlYW4oY29uZmlnLnRvZ2dsZSk7IC8vIENvZXJjZSBzdHJpbmcgdmFsdWVzXG4gICAgICBjb25maWcucGFyZW50ID0gZ2V0RWxlbWVudChjb25maWcucGFyZW50KTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICAgIF9nZXREaW1lbnNpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9IT1JJWk9OVEFMKSA/IFdJRFRIIDogSEVJR0hUO1xuICAgIH1cbiAgICBfaW5pdGlhbGl6ZUNoaWxkcmVuKCkge1xuICAgICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQpO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KTtcbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFtlbGVtZW50XSwgdGhpcy5faXNTaG93bihzZWxlY3RlZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9nZXRGaXJzdExldmVsQ2hpbGRyZW4oc2VsZWN0b3IpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gU2VsZWN0b3JFbmdpbmUuZmluZChDTEFTU19OQU1FX0RFRVBFUl9DSElMRFJFTiwgdGhpcy5fY29uZmlnLnBhcmVudCk7XG4gICAgICAvLyByZW1vdmUgY2hpbGRyZW4gaWYgZ3JlYXRlciBkZXB0aFxuICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IsIHRoaXMuX2NvbmZpZy5wYXJlbnQpLmZpbHRlcihlbGVtZW50ID0+ICFjaGlsZHJlbi5pbmNsdWRlcyhlbGVtZW50KSk7XG4gICAgfVxuICAgIF9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModHJpZ2dlckFycmF5LCBpc09wZW4pIHtcbiAgICAgIGlmICghdHJpZ2dlckFycmF5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdHJpZ2dlckFycmF5KSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShDTEFTU19OQU1FX0NPTExBUFNFRCwgIWlzT3Blbik7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgY29uc3QgX2NvbmZpZyA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnICYmIC9zaG93fGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgICBfY29uZmlnLnRvZ2dsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBDb2xsYXBzZS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIF9jb25maWcpO1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAgICovXG5cbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQ0LCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0LCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBwcmV2ZW50RGVmYXVsdCBvbmx5IGZvciA8YT4gZWxlbWVudHMgKHdoaWNoIGNoYW5nZSB0aGUgVVJMKSBub3QgaW5zaWRlIHRoZSBjb2xsYXBzaWJsZSBlbGVtZW50XG4gICAgaWYgKGV2ZW50LnRhcmdldC50YWdOYW1lID09PSAnQScgfHwgZXZlbnQuZGVsZWdhdGVUYXJnZXQgJiYgZXZlbnQuZGVsZWdhdGVUYXJnZXQudGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgU2VsZWN0b3JFbmdpbmUuZ2V0TXVsdGlwbGVFbGVtZW50c0Zyb21TZWxlY3Rvcih0aGlzKSkge1xuICAgICAgQ29sbGFwc2UuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCB7XG4gICAgICAgIHRvZ2dsZTogZmFsc2VcbiAgICAgIH0pLnRvZ2dsZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oQ29sbGFwc2UpO1xuXG4gIHZhciB0b3AgPSAndG9wJztcbiAgdmFyIGJvdHRvbSA9ICdib3R0b20nO1xuICB2YXIgcmlnaHQgPSAncmlnaHQnO1xuICB2YXIgbGVmdCA9ICdsZWZ0JztcbiAgdmFyIGF1dG8gPSAnYXV0byc7XG4gIHZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xuICB2YXIgc3RhcnQgPSAnc3RhcnQnO1xuICB2YXIgZW5kID0gJ2VuZCc7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbiAgdmFyIHZpZXdwb3J0ID0gJ3ZpZXdwb3J0JztcbiAgdmFyIHBvcHBlciA9ICdwb3BwZXInO1xuICB2YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG4gIHZhciB2YXJpYXRpb25QbGFjZW1lbnRzID0gLyojX19QVVJFX18qL2Jhc2VQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbiAgfSwgW10pO1xuICB2YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQsIHBsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG4gIH0sIFtdKTsgLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cblxuICB2YXIgYmVmb3JlUmVhZCA9ICdiZWZvcmVSZWFkJztcbiAgdmFyIHJlYWQgPSAncmVhZCc7XG4gIHZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcblxuICB2YXIgYmVmb3JlTWFpbiA9ICdiZWZvcmVNYWluJztcbiAgdmFyIG1haW4gPSAnbWFpbic7XG4gIHZhciBhZnRlck1haW4gPSAnYWZ0ZXJNYWluJzsgLy8gbW9kaWZpZXIgd2l0aCB0aGUgcHVycG9zZSB0byB3cml0ZSB0byB0aGUgRE9NIChvciB3cml0ZSBpbnRvIGEgZnJhbWV3b3JrIHN0YXRlKVxuXG4gIHZhciBiZWZvcmVXcml0ZSA9ICdiZWZvcmVXcml0ZSc7XG4gIHZhciB3cml0ZSA9ICd3cml0ZSc7XG4gIHZhciBhZnRlcldyaXRlID0gJ2FmdGVyV3JpdGUnO1xuICB2YXIgbW9kaWZpZXJQaGFzZXMgPSBbYmVmb3JlUmVhZCwgcmVhZCwgYWZ0ZXJSZWFkLCBiZWZvcmVNYWluLCBtYWluLCBhZnRlck1haW4sIGJlZm9yZVdyaXRlLCB3cml0ZSwgYWZ0ZXJXcml0ZV07XG5cbiAgZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cblxuICAgIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICAgIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gICAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuSFRNTEVsZW1lbnQ7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU2hhZG93Um9vdChub2RlKSB7XG4gICAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG4gIH1cblxuICAvLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XG5cbiAgZnVuY3Rpb24gYXBwbHlTdHlsZXMoX3JlZikge1xuICAgIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdG8gZXh0ZW5kIHRoaXMgcHJvcGVydHksIGJ1dCBpdCdzIHRoZSBtb3N0XG4gICAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG5cblxuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZWZmZWN0JDIoX3JlZjIpIHtcbiAgICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcbiAgICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICAgIHBvcHBlcjoge1xuICAgICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgICAgbGVmdDogJzAnLFxuICAgICAgICB0b3A6ICcwJyxcbiAgICAgICAgbWFyZ2luOiAnMCdcbiAgICAgIH0sXG4gICAgICBhcnJvdzoge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgICAgfSxcbiAgICAgIHJlZmVyZW5jZToge31cbiAgICB9O1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gICAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICAgIGlmIChzdGF0ZS5lbGVtZW50cy5hcnJvdykge1xuICAgICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxuXG4gICAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9ICcnO1xuICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuICBjb25zdCBhcHBseVN0eWxlcyQxID0ge1xuICAgIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBwaGFzZTogJ3dyaXRlJyxcbiAgICBmbjogYXBwbHlTdHlsZXMsXG4gICAgZWZmZWN0OiBlZmZlY3QkMixcbiAgICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICAgIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgfVxuXG4gIHZhciBtYXggPSBNYXRoLm1heDtcbiAgdmFyIG1pbiA9IE1hdGgubWluO1xuICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuXG4gIGZ1bmN0aW9uIGdldFVBU3RyaW5nKCkge1xuICAgIHZhciB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcblxuICAgIGlmICh1YURhdGEgIT0gbnVsbCAmJiB1YURhdGEuYnJhbmRzICYmIEFycmF5LmlzQXJyYXkodWFEYXRhLmJyYW5kcykpIHtcbiAgICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5icmFuZCArIFwiL1wiICsgaXRlbS52ZXJzaW9uO1xuICAgICAgfSkuam9pbignICcpO1xuICAgIH1cblxuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMYXlvdXRWaWV3cG9ydCgpIHtcbiAgICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3kpIHtcbiAgICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc0ZpeGVkU3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgICAgaXNGaXhlZFN0cmF0ZWd5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBzY2FsZVggPSAxO1xuICAgIHZhciBzY2FsZVkgPSAxO1xuXG4gICAgaWYgKGluY2x1ZGVTY2FsZSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICBzY2FsZVggPSBlbGVtZW50Lm9mZnNldFdpZHRoID4gMCA/IHJvdW5kKGNsaWVudFJlY3Qud2lkdGgpIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxIDogMTtcbiAgICAgIHNjYWxlWSA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gMCA/IHJvdW5kKGNsaWVudFJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEgOiAxO1xuICAgIH1cblxuICAgIHZhciBfcmVmID0gaXNFbGVtZW50KGVsZW1lbnQpID8gZ2V0V2luZG93KGVsZW1lbnQpIDogd2luZG93LFxuICAgICAgICB2aXN1YWxWaWV3cG9ydCA9IF9yZWYudmlzdWFsVmlld3BvcnQ7XG5cbiAgICB2YXIgYWRkVmlzdWFsT2Zmc2V0cyA9ICFpc0xheW91dFZpZXdwb3J0KCkgJiYgaXNGaXhlZFN0cmF0ZWd5O1xuICAgIHZhciB4ID0gKGNsaWVudFJlY3QubGVmdCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCA6IDApKSAvIHNjYWxlWDtcbiAgICB2YXIgeSA9IChjbGllbnRSZWN0LnRvcCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wIDogMCkpIC8gc2NhbGVZO1xuICAgIHZhciB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZVg7XG4gICAgdmFyIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGVZO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHRvcDogeSxcbiAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgICBsZWZ0OiB4LFxuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuICB9XG5cbiAgLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuXG4gIGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xuICAgIHZhciBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpOyAvLyBVc2UgdGhlIGNsaWVudFJlY3Qgc2l6ZXMgaWYgaXQncyBub3QgYmVlbiB0cmFuc2Zvcm1lZC5cbiAgICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcblxuICAgIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3Qud2lkdGggLSB3aWR0aCkgPD0gMSkge1xuICAgICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICAgIH1cblxuICAgIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xuICAgICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICAgIHk6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICAgIHZhciByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlICYmIGNoaWxkLmdldFJvb3ROb2RlKCk7IC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcblxuICAgIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gICAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgICAgICB2YXIgbmV4dCA9IGNoaWxkO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ106IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG5cblxuICAgICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICAgIH0gLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuXG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkge1xuICAgIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICByZXR1cm4gKChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICAgIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gKC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgICAgaXNTaGFkb3dSb290KGVsZW1lbnQpID8gZWxlbWVudC5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXG5cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gICAgZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gIH0gLy8gYC5vZmZzZXRQYXJlbnRgIHJlcG9ydHMgYG51bGxgIGZvciBmaXhlZCBlbGVtZW50cywgd2hpbGUgYWJzb2x1dGUgZWxlbWVudHNcbiAgLy8gcmV0dXJuIHRoZSBjb250YWluaW5nIGJsb2NrXG5cblxuICBmdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICAgIHZhciBpc0ZpcmVmb3ggPSAvZmlyZWZveC9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG4gICAgdmFyIGlzSUUgPSAvVHJpZGVudC9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG5cbiAgICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAvLyBJbiBJRSA5LCAxMCBhbmQgMTEgZml4ZWQgZWxlbWVudHMgY29udGFpbmluZyBibG9jayBpcyBhbHdheXMgZXN0YWJsaXNoZWQgYnkgdGhlIHZpZXdwb3J0XG4gICAgICB2YXIgZWxlbWVudENzcyA9IGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KTtcblxuICAgICAgaWYgKGVsZW1lbnRDc3MucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICAgIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmhvc3Q7XG4gICAgfVxuXG4gICAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgICAgdmFyIGNzcyA9IGdldENvbXB1dGVkU3R5bGUkMShjdXJyZW50Tm9kZSk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxuICAgICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG5cbiAgICAgIGlmIChjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmRleE9mKGNzcy53aWxsQ2hhbmdlKSAhPT0gLTEgfHwgaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJyB8fCBpc0ZpcmVmb3ggJiYgY3NzLmZpbHRlciAmJiBjc3MuZmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbiAgLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cblxuXG4gIGZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gICAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KTtcblxuICAgIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlJDEob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUkMShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykpIHtcbiAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICAgIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgPj0gMCA/ICd4JyA6ICd5JztcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhpbihtaW4kMSwgdmFsdWUsIG1heCQxKSB7XG4gICAgcmV0dXJuIG1heChtaW4kMSwgbWluKHZhbHVlLCBtYXgkMSkpO1xuICB9XG4gIGZ1bmN0aW9uIHdpdGhpbk1heENsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xuICAgIHZhciB2ID0gd2l0aGluKG1pbiwgdmFsdWUsIG1heCk7XG4gICAgcmV0dXJuIHYgPiBtYXggPyBtYXggOiB2O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGxlZnQ6IDBcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VQYWRkaW5nT2JqZWN0KHBhZGRpbmdPYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RnJlc2hTaWRlT2JqZWN0KCksIHBhZGRpbmdPYmplY3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNoTWFwLCBrZXkpIHtcbiAgICAgIGhhc2hNYXBba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIGhhc2hNYXA7XG4gICAgfSwge30pO1xuICB9XG5cbiAgdmFyIHRvUGFkZGluZ09iamVjdCA9IGZ1bmN0aW9uIHRvUGFkZGluZ09iamVjdChwYWRkaW5nLCBzdGF0ZSkge1xuICAgIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gICAgfSkpIDogcGFkZGluZztcbiAgICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbiAgfTtcblxuICBmdW5jdGlvbiBhcnJvdyhfcmVmKSB7XG4gICAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcblxuICAgIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICAgIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICAgIHZhciBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICAgIHZhciBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gICAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCB8fCAhcG9wcGVyT2Zmc2V0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xuICAgIHZhciBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gICAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIHZhciBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgdmFyIGVuZERpZmYgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbbGVuXSArIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5wb3BwZXJbbGVuXTtcbiAgICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcbiAgICB2YXIgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcbiAgICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcbiAgICAvLyBvdXRzaWRlIG9mIHRoZSBwb3BwZXIgYm91bmRzXG5cbiAgICB2YXIgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgICB2YXIgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgICB2YXIgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBQcmV2ZW50cyBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLi4uXG5cbiAgICB2YXIgYXhpc1Byb3AgPSBheGlzO1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSAoX3N0YXRlJG1vZGlmaWVyc0RhdGEkID0ge30sIF9zdGF0ZSRtb2RpZmllcnNEYXRhJFtheGlzUHJvcF0gPSBvZmZzZXQsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJC5jZW50ZXJPZmZzZXQgPSBvZmZzZXQgLSBjZW50ZXIsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJCk7XG4gIH1cblxuICBmdW5jdGlvbiBlZmZlY3QkMShfcmVmMikge1xuICAgIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgICB2YXIgX29wdGlvbnMkZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudCxcbiAgICAgICAgYXJyb3dFbGVtZW50ID0gX29wdGlvbnMkZWxlbWVudCA9PT0gdm9pZCAwID8gJ1tkYXRhLXBvcHBlci1hcnJvd10nIDogX29wdGlvbnMkZWxlbWVudDtcblxuICAgIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ1NTIHNlbGVjdG9yXG5cblxuICAgIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbiAgY29uc3QgYXJyb3ckMSA9IHtcbiAgICBuYW1lOiAnYXJyb3cnLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgcGhhc2U6ICdtYWluJyxcbiAgICBmbjogYXJyb3csXG4gICAgZWZmZWN0OiBlZmZlY3QkMSxcbiAgICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gICAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG4gIH1cblxuICB2YXIgdW5zZXRTaWRlcyA9IHtcbiAgICB0b3A6ICdhdXRvJyxcbiAgICByaWdodDogJ2F1dG8nLFxuICAgIGJvdHRvbTogJ2F1dG8nLFxuICAgIGxlZnQ6ICdhdXRvJ1xuICB9OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuICAvLyBab29taW5nIGNhbiBjaGFuZ2UgdGhlIERQUiwgYnV0IGl0IHNlZW1zIHRvIHJlcG9ydCBhIHZhbHVlIHRoYXQgd2lsbFxuICAvLyBjbGVhbmx5IGRpdmlkZSB0aGUgdmFsdWVzIGludG8gdGhlIGFwcHJvcHJpYXRlIHN1YnBpeGVscy5cblxuICBmdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmLCB3aW4pIHtcbiAgICB2YXIgeCA9IF9yZWYueCxcbiAgICAgICAgeSA9IF9yZWYueTtcbiAgICB2YXIgZHByID0gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcm91bmQoeCAqIGRwcikgLyBkcHIgfHwgMCxcbiAgICAgIHk6IHJvdW5kKHkgKiBkcHIpIC8gZHByIHx8IDBcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ24yO1xuXG4gICAgdmFyIHBvcHBlciA9IF9yZWYyLnBvcHBlcixcbiAgICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICAgIHBsYWNlbWVudCA9IF9yZWYyLnBsYWNlbWVudCxcbiAgICAgICAgdmFyaWF0aW9uID0gX3JlZjIudmFyaWF0aW9uLFxuICAgICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgICAgcG9zaXRpb24gPSBfcmVmMi5wb3NpdGlvbixcbiAgICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX3JlZjIuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlLFxuICAgICAgICByb3VuZE9mZnNldHMgPSBfcmVmMi5yb3VuZE9mZnNldHMsXG4gICAgICAgIGlzRml4ZWQgPSBfcmVmMi5pc0ZpeGVkO1xuICAgIHZhciBfb2Zmc2V0cyR4ID0gb2Zmc2V0cy54LFxuICAgICAgICB4ID0gX29mZnNldHMkeCA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHgsXG4gICAgICAgIF9vZmZzZXRzJHkgPSBvZmZzZXRzLnksXG4gICAgICAgIHkgPSBfb2Zmc2V0cyR5ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeTtcblxuICAgIHZhciBfcmVmMyA9IHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMoe1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9KSA6IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcblxuICAgIHggPSBfcmVmMy54O1xuICAgIHkgPSBfcmVmMy55O1xuICAgIHZhciBoYXNYID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneCcpO1xuICAgIHZhciBoYXNZID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneScpO1xuICAgIHZhciBzaWRlWCA9IGxlZnQ7XG4gICAgdmFyIHNpZGVZID0gdG9wO1xuICAgIHZhciB3aW4gPSB3aW5kb3c7XG5cbiAgICBpZiAoYWRhcHRpdmUpIHtcbiAgICAgIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKTtcbiAgICAgIHZhciBoZWlnaHRQcm9wID0gJ2NsaWVudEhlaWdodCc7XG4gICAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgICAgaWYgKG9mZnNldFBhcmVudCA9PT0gZ2V0V2luZG93KHBvcHBlcikpIHtcbiAgICAgICAgb2Zmc2V0UGFyZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KHBvcHBlcik7XG5cbiAgICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUkMShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uICE9PSAnc3RhdGljJyAmJiBwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJykge1xuICAgICAgICAgIGhlaWdodFByb3AgPSAnc2Nyb2xsSGVpZ2h0JztcbiAgICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgICB9XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhc3RdOiBmb3JjZSB0eXBlIHJlZmluZW1lbnQsIHdlIGNvbXBhcmUgb2Zmc2V0UGFyZW50IHdpdGggd2luZG93IGFib3ZlLCBidXQgRmxvdyBkb2Vzbid0IGRldGVjdCBpdFxuXG5cbiAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgICAgaWYgKHBsYWNlbWVudCA9PT0gdG9wIHx8IChwbGFjZW1lbnQgPT09IGxlZnQgfHwgcGxhY2VtZW50ID09PSByaWdodCkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgICAgc2lkZVkgPSBib3R0b207XG4gICAgICAgIHZhciBvZmZzZXRZID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQuaGVpZ2h0IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICAgIG9mZnNldFBhcmVudFtoZWlnaHRQcm9wXTtcbiAgICAgICAgeSAtPSBvZmZzZXRZIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XG4gICAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgICAgfVxuXG4gICAgICBpZiAocGxhY2VtZW50ID09PSBsZWZ0IHx8IChwbGFjZW1lbnQgPT09IHRvcCB8fCBwbGFjZW1lbnQgPT09IGJvdHRvbSkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgICAgc2lkZVggPSByaWdodDtcbiAgICAgICAgdmFyIG9mZnNldFggPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC53aWR0aCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICBvZmZzZXRQYXJlbnRbd2lkdGhQcm9wXTtcbiAgICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgICAgeCAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbW1vblN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgICB2YXIgX3JlZjQgPSByb3VuZE9mZnNldHMgPT09IHRydWUgPyByb3VuZE9mZnNldHNCeURQUih7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH0sIGdldFdpbmRvdyhwb3BwZXIpKSA6IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcblxuICAgIHggPSBfcmVmNC54O1xuICAgIHkgPSBfcmVmNC55O1xuXG4gICAgaWYgKGdwdUFjY2VsZXJhdGlvbikge1xuICAgICAgdmFyIF9PYmplY3QkYXNzaWduO1xuXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24yID0ge30sIF9PYmplY3QkYXNzaWduMltzaWRlWV0gPSBoYXNZID8geSArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjJbc2lkZVhdID0gaGFzWCA/IHggKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yLnRyYW5zZm9ybSA9ICcnLCBfT2JqZWN0JGFzc2lnbjIpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVTdHlsZXMoX3JlZjUpIHtcbiAgICB2YXIgc3RhdGUgPSBfcmVmNS5zdGF0ZSxcbiAgICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XG4gICAgdmFyIF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgICBncHVBY2NlbGVyYXRpb24gPSBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRncHVBY2NlbGVyYXQsXG4gICAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgICAgYWRhcHRpdmUgPSBfb3B0aW9ucyRhZGFwdGl2ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFkYXB0aXZlLFxuICAgICAgICBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPSBvcHRpb25zLnJvdW5kT2Zmc2V0cyxcbiAgICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuICAgIHZhciBjb21tb25TdHlsZXMgPSB7XG4gICAgICBwbGFjZW1lbnQ6IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KSxcbiAgICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgICBwb3BwZXI6IHN0YXRlLmVsZW1lbnRzLnBvcHBlcixcbiAgICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgaXNGaXhlZDogc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJ1xuICAgIH07XG5cbiAgICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMucG9wcGVyLCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFxuICAgICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgICAgYWRhcHRpdmU6IGFkYXB0aXZlLFxuICAgICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgICAgfSkpKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsKSB7XG4gICAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgICAgfSkpKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgICAnZGF0YS1wb3BwZXItcGxhY2VtZW50Jzogc3RhdGUucGxhY2VtZW50XG4gICAgfSk7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbiAgY29uc3QgY29tcHV0ZVN0eWxlcyQxID0ge1xuICAgIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICAgIGZuOiBjb21wdXRlU3R5bGVzLFxuICAgIGRhdGE6IHt9XG4gIH07XG5cbiAgdmFyIHBhc3NpdmUgPSB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGVmZmVjdChfcmVmKSB7XG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICAgIHZhciBfb3B0aW9ucyRzY3JvbGwgPSBvcHRpb25zLnNjcm9sbCxcbiAgICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgICBfb3B0aW9ucyRyZXNpemUgPSBvcHRpb25zLnJlc2l6ZSxcbiAgICAgICAgcmVzaXplID0gX29wdGlvbnMkcmVzaXplID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcmVzaXplO1xuICAgIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgICB2YXIgc2Nyb2xsUGFyZW50cyA9IFtdLmNvbmNhdChzdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgc3RhdGUuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuXG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc2l6ZSkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG4gIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0ge1xuICAgIG5hbWU6ICdldmVudExpc3RlbmVycycsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBwaGFzZTogJ3dyaXRlJyxcbiAgICBmbjogZnVuY3Rpb24gZm4oKSB7fSxcbiAgICBlZmZlY3Q6IGVmZmVjdCxcbiAgICBkYXRhOiB7fVxuICB9O1xuXG4gIHZhciBoYXNoJDEgPSB7XG4gICAgbGVmdDogJ3JpZ2h0JyxcbiAgICByaWdodDogJ2xlZnQnLFxuICAgIGJvdHRvbTogJ3RvcCcsXG4gICAgdG9wOiAnYm90dG9tJ1xuICB9O1xuICBmdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgICAgcmV0dXJuIGhhc2gkMVttYXRjaGVkXTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNoID0ge1xuICAgIHN0YXJ0OiAnZW5kJyxcbiAgICBlbmQ6ICdzdGFydCdcbiAgfTtcbiAgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKG5vZGUpIHtcbiAgICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICAgIHZhciBzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0O1xuICAgIHZhciBzY3JvbGxUb3AgPSB3aW4ucGFnZVlPZmZzZXQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gICAgLy8gaW5jb3JyZWN0IGZvciBSVEwuXG4gICAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gICAgLy8gYW55d2F5LlxuICAgIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gICAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldFdpbmRvd1Njcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gICAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gICAgdmFyIHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciB5ID0gMDtcblxuICAgIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICAgIHZhciBsYXlvdXRWaWV3cG9ydCA9IGlzTGF5b3V0Vmlld3BvcnQoKTtcblxuICAgICAgaWYgKGxheW91dFZpZXdwb3J0IHx8ICFsYXlvdXRWaWV3cG9ydCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICB4OiB4ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSxcbiAgICAgIHk6IHlcbiAgICB9O1xuICB9XG5cbiAgLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG4gIGZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gICAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICAgIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICAgIHZhciB3aW5TY3JvbGwgPSBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCk7XG4gICAgdmFyIGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XG4gICAgdmFyIHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgICB2YXIgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCwgYm9keSA/IGJvZHkuY2xpZW50SGVpZ2h0IDogMCk7XG4gICAgdmFyIHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICAgIHZhciB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSQxKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gICAgdmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLFxuICAgICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgICBvdmVyZmxvd1ggPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gsXG4gICAgICAgIG92ZXJmbG93WSA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WTtcblxuICAgIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgICBpZiAoWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5kZXhPZihnZXROb2RlTmFtZShub2RlKSkgPj0gMCkge1xuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KG5vZGUpICYmIGlzU2Nyb2xsUGFyZW50KG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUobm9kZSkpO1xuICB9XG5cbiAgLypcbiAgZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcbiAgdW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbiAgdG8sIGJlY2F1c2UgaWYgYW55IG9mIHRoZXNlIHBhcmVudCBlbGVtZW50cyBzY3JvbGwsIHdlJ2xsIG5lZWQgdG8gcmUtY2FsY3VsYXRlIHRoZVxuICByZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxuICAqL1xuXG4gIGZ1bmN0aW9uIGxpc3RTY3JvbGxQYXJlbnRzKGVsZW1lbnQsIGxpc3QpIHtcbiAgICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gICAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgICAgbGlzdCA9IFtdO1xuICAgIH1cblxuICAgIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gICAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudCA9PT0gKChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keSk7XG4gICAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICAgIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xuICAgIHZhciB1cGRhdGVkTGlzdCA9IGxpc3QuY29uY2F0KHRhcmdldCk7XG4gICAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gICAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlY3QsIHtcbiAgICAgIGxlZnQ6IHJlY3QueCxcbiAgICAgIHRvcDogcmVjdC55LFxuICAgICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICAgIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGZhbHNlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gICAgcmVjdC50b3AgPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICAgIHJlY3QubGVmdCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgcmVjdC53aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICByZWN0LnggPSByZWN0LmxlZnQ7XG4gICAgcmVjdC55ID0gcmVjdC50b3A7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIHtcbiAgICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpKSA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG4gIH0gLy8gQSBcImNsaXBwaW5nIHBhcmVudFwiIGlzIGFuIG92ZXJmbG93YWJsZSBjb250YWluZXIgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2ZcbiAgLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4gIC8vIGBpbml0aWFsYFxuXG5cbiAgZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIHtcbiAgICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gbGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG4gICAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLnBvc2l0aW9uKSA+PSAwO1xuICAgIHZhciBjbGlwcGVyRWxlbWVudCA9IGNhbkVzY2FwZUNsaXBwaW5nICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gICAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMTQxNFxuXG5cbiAgICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICAgIHJldHVybiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpICYmIGNvbnRhaW5zKGNsaXBwaW5nUGFyZW50LCBjbGlwcGVyRWxlbWVudCkgJiYgZ2V0Tm9kZU5hbWUoY2xpcHBpbmdQYXJlbnQpICE9PSAnYm9keSc7XG4gICAgfSk7XG4gIH0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuICAvLyBjbGlwcGluZyBwYXJlbnRzXG5cblxuICBmdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoZWxlbWVudCwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSwgc3RyYXRlZ3kpIHtcbiAgICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gICAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IFtdLmNvbmNhdChtYWluQ2xpcHBpbmdQYXJlbnRzLCBbcm9vdEJvdW5kYXJ5XSk7XG4gICAgdmFyIGZpcnN0Q2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNbMF07XG4gICAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XG4gICAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSk7XG4gICAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICAgIGFjY1JlY3QuYm90dG9tID0gbWluKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XG4gICAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgICAgcmV0dXJuIGFjY1JlY3Q7XG4gICAgfSwgZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgZmlyc3RDbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpKTtcbiAgICBjbGlwcGluZ1JlY3Qud2lkdGggPSBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gICAgY2xpcHBpbmdSZWN0LnggPSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgICBjbGlwcGluZ1JlY3QueSA9IGNsaXBwaW5nUmVjdC50b3A7XG4gICAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKF9yZWYpIHtcbiAgICB2YXIgcmVmZXJlbmNlID0gX3JlZi5yZWZlcmVuY2UsXG4gICAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICAgIHBsYWNlbWVudCA9IF9yZWYucGxhY2VtZW50O1xuICAgIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50ID8gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIDogbnVsbDtcbiAgICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICAgIHZhciBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZWxlbWVudC53aWR0aCAvIDI7XG4gICAgdmFyIGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZWxlbWVudC5oZWlnaHQgLyAyO1xuICAgIHZhciBvZmZzZXRzO1xuXG4gICAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XG4gICAgICBjYXNlIHRvcDpcbiAgICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZWxlbWVudC5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgYm90dG9tOlxuICAgICAgICBvZmZzZXRzID0ge1xuICAgICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHJpZ2h0OlxuICAgICAgICBvZmZzZXRzID0ge1xuICAgICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICAgIHk6IGNvbW1vbllcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgbGVmdDpcbiAgICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXG4gICAgICAgICAgeTogY29tbW9uWVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgICB5OiByZWZlcmVuY2UueVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtYWluQXhpcyA9IGJhc2VQbGFjZW1lbnQgPyBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCkgOiBudWxsO1xuXG4gICAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgICBzd2l0Y2ggKHZhcmlhdGlvbikge1xuICAgICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gLSAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBlbmQ6XG4gICAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSArIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICAgIF9vcHRpb25zJHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXG4gICAgICAgIF9vcHRpb25zJHN0cmF0ZWd5ID0gX29wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICAgIHN0cmF0ZWd5ID0gX29wdGlvbnMkc3RyYXRlZ3kgPT09IHZvaWQgMCA/IHN0YXRlLnN0cmF0ZWd5IDogX29wdGlvbnMkc3RyYXRlZ3ksXG4gICAgICAgIF9vcHRpb25zJGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IGNsaXBwaW5nUGFyZW50cyA6IF9vcHRpb25zJGJvdW5kYXJ5LFxuICAgICAgICBfb3B0aW9ucyRyb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9PT0gdm9pZCAwID8gdmlld3BvcnQgOiBfb3B0aW9ucyRyb290Qm91bmRhcnksXG4gICAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxuICAgICAgICBlbGVtZW50Q29udGV4dCA9IF9vcHRpb25zJGVsZW1lbnRDb250ZSA9PT0gdm9pZCAwID8gcG9wcGVyIDogX29wdGlvbnMkZWxlbWVudENvbnRlLFxuICAgICAgICBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9IF9vcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxuICAgICAgICBfb3B0aW9ucyRwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgICAgcGFkZGluZyA9IF9vcHRpb25zJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRwYWRkaW5nO1xuICAgIHZhciBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbiAgICB2YXIgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyByZWZlcmVuY2UgOiBwb3BwZXI7XG4gICAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gICAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IGdldENsaXBwaW5nUmVjdChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCBnZXREb2N1bWVudEVsZW1lbnQoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSwgc3RyYXRlZ3kpO1xuICAgIHZhciByZWZlcmVuY2VDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSk7XG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgICBlbGVtZW50OiBwb3BwZXJSZWN0LFxuICAgICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICAgIH0pO1xuICAgIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCBwb3BwZXJPZmZzZXRzKSk7XG4gICAgdmFyIGVsZW1lbnRDbGllbnRSZWN0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHBvcHBlckNsaWVudFJlY3QgOiByZWZlcmVuY2VDbGllbnRSZWN0OyAvLyBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyByZWN0XG4gICAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuXG4gICAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcbiAgICAgIHRvcDogY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wLFxuICAgICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgICByaWdodDogZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0XG4gICAgfTtcbiAgICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG5cbiAgICBpZiAoZWxlbWVudENvbnRleHQgPT09IHBvcHBlciAmJiBvZmZzZXREYXRhKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuICAgICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIG11bHRpcGx5ID0gW3JpZ2h0LCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gMSA6IC0xO1xuICAgICAgICB2YXIgYXhpcyA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgICBwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPT09IHZvaWQgMCA/IHBsYWNlbWVudHMgOiBfb3B0aW9ucyRhbGxvd2VkQXV0b1A7XG4gICAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpO1xuICAgIHZhciBwbGFjZW1lbnRzJDEgPSB2YXJpYXRpb24gPyBmbGlwVmFyaWF0aW9ucyA/IHZhcmlhdGlvblBsYWNlbWVudHMgOiB2YXJpYXRpb25QbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcbiAgICB9KSA6IGJhc2VQbGFjZW1lbnRzO1xuICAgIHZhciBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMkMS5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgICB9KTtcblxuICAgIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cyQxO1xuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IEZsb3cgc2VlbXMgdG8gaGF2ZSBwcm9ibGVtcyB3aXRoIHR3byBhcnJheSB1bmlvbnMuLi5cblxuXG4gICAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICAgIGFjY1twbGFjZW1lbnRdID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gb3ZlcmZsb3dzW2FdIC0gb3ZlcmZsb3dzW2JdO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gICAgaWYgKGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gICAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsaXAoX3JlZikge1xuICAgIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG5cbiAgICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzID0gb3B0aW9ucy5mYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRmbGlwVmFyaWF0aW8sXG4gICAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IG9wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzO1xuICAgIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KTtcbiAgICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gYmFzZVBsYWNlbWVudCA9PT0gcHJlZmVycmVkUGxhY2VtZW50O1xuICAgIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgICB2YXIgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnRdLmNvbmNhdChmYWxsYmFja1BsYWNlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0byA/IGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCB7XG4gICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgICBmbGlwVmFyaWF0aW9uczogZmxpcFZhcmlhdGlvbnMsXG4gICAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogYWxsb3dlZEF1dG9QbGFjZW1lbnRzXG4gICAgICB9KSA6IHBsYWNlbWVudCk7XG4gICAgfSwgW10pO1xuICAgIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICAgIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICAgIHZhciBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XG4gICAgdmFyIG1ha2VGYWxsYmFja0NoZWNrcyA9IHRydWU7XG4gICAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwbGFjZW1lbnQgPSBwbGFjZW1lbnRzW2ldO1xuXG4gICAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICAgIHZhciBpc1N0YXJ0VmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHN0YXJ0O1xuICAgICAgdmFyIGlzVmVydGljYWwgPSBbdG9wLCBib3R0b21dLmluZGV4T2YoX2Jhc2VQbGFjZW1lbnQpID49IDA7XG4gICAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnksXG4gICAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICAgIH0pO1xuICAgICAgdmFyIG1haW5WYXJpYXRpb25TaWRlID0gaXNWZXJ0aWNhbCA/IGlzU3RhcnRWYXJpYXRpb24gPyByaWdodCA6IGxlZnQgOiBpc1N0YXJ0VmFyaWF0aW9uID8gYm90dG9tIDogdG9wO1xuXG4gICAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICAgIHZhciBjaGVja3MgPSBbXTtcblxuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgICAgfSkpIHtcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICAgIH1cblxuICAgIGlmIChtYWtlRmFsbGJhY2tDaGVja3MpIHtcbiAgICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxuICAgICAgdmFyIG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kpIHtcbiAgICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICAgIHZhciBjaGVja3MgPSBjaGVja3NNYXAuZ2V0KHBsYWNlbWVudCk7XG5cbiAgICAgICAgICBpZiAoY2hlY2tzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZml0dGluZ1BsYWNlbWVudCkge1xuICAgICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgX2kgPSBudW1iZXJPZkNoZWNrczsgX2kgPiAwOyBfaS0tKSB7XG4gICAgICAgIHZhciBfcmV0ID0gX2xvb3AoX2kpO1xuXG4gICAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XG4gICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gICAgfVxuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG4gIGNvbnN0IGZsaXAkMSA9IHtcbiAgICBuYW1lOiAnZmxpcCcsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBwaGFzZTogJ21haW4nLFxuICAgIGZuOiBmbGlwLFxuICAgIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gICAgZGF0YToge1xuICAgICAgX3NraXA6IGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XG4gICAgaWYgKHByZXZlbnRlZE9mZnNldHMgPT09IHZvaWQgMCkge1xuICAgICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0ICsgcHJldmVudGVkT2Zmc2V0cy55LFxuICAgICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gICAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgIHJldHVybiBvdmVyZmxvd1tzaWRlXSA+PSAwO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGlkZShfcmVmKSB7XG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICAgIHZhciByZWZlcmVuY2VPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICB9KTtcbiAgICB2YXIgcG9wcGVyQWx0T3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgICB9KTtcbiAgICB2YXIgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocmVmZXJlbmNlT3ZlcmZsb3csIHJlZmVyZW5jZVJlY3QpO1xuICAgIHZhciBwb3BwZXJFc2NhcGVPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocG9wcGVyQWx0T3ZlcmZsb3csIHBvcHBlclJlY3QsIHByZXZlbnRlZE9mZnNldHMpO1xuICAgIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICAgIHZhciBoYXNQb3BwZXJFc2NhcGVkID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHBvcHBlckVzY2FwZU9mZnNldHMpO1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICAgIHBvcHBlckVzY2FwZU9mZnNldHM6IHBvcHBlckVzY2FwZU9mZnNldHMsXG4gICAgICBpc1JlZmVyZW5jZUhpZGRlbjogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gICAgfTtcbiAgICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICAgJ2RhdGEtcG9wcGVyLWVzY2FwZWQnOiBoYXNQb3BwZXJFc2NhcGVkXG4gICAgfSk7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbiAgY29uc3QgaGlkZSQxID0ge1xuICAgIG5hbWU6ICdoaWRlJyxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHBoYXNlOiAnbWFpbicsXG4gICAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXSxcbiAgICBmbjogaGlkZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgcmVjdHMsIG9mZnNldCkge1xuICAgIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICAgIHZhciBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICAgIHZhciBfcmVmID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldChPYmplY3QuYXNzaWduKHt9LCByZWN0cywge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgICB9KSkgOiBvZmZzZXQsXG4gICAgICAgIHNraWRkaW5nID0gX3JlZlswXSxcbiAgICAgICAgZGlzdGFuY2UgPSBfcmVmWzFdO1xuXG4gICAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xuICAgIGRpc3RhbmNlID0gKGRpc3RhbmNlIHx8IDApICogaW52ZXJ0RGlzdGFuY2U7XG4gICAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8ge1xuICAgICAgeDogZGlzdGFuY2UsXG4gICAgICB5OiBza2lkZGluZ1xuICAgIH0gOiB7XG4gICAgICB4OiBza2lkZGluZyxcbiAgICAgIHk6IGRpc3RhbmNlXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9mZnNldChfcmVmMikge1xuICAgIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcbiAgICAgICAgbmFtZSA9IF9yZWYyLm5hbWU7XG4gICAgdmFyIF9vcHRpb25zJG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcbiAgICB2YXIgZGF0YSA9IHBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgdmFyIF9kYXRhJHN0YXRlJHBsYWNlbWVudCA9IGRhdGFbc3RhdGUucGxhY2VtZW50XSxcbiAgICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxuICAgICAgICB5ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50Lnk7XG5cbiAgICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB5O1xuICAgIH1cblxuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG4gIGNvbnN0IG9mZnNldCQxID0ge1xuICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgcGhhc2U6ICdtYWluJyxcbiAgICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gICAgZm46IG9mZnNldFxuICB9O1xuXG4gIGZ1bmN0aW9uIHBvcHBlck9mZnNldHMoX3JlZikge1xuICAgIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcbiAgICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gICAgLy8gVGhpcyBpcyB0aGUgbW9zdCBiYXNpYyBwbGFjZW1lbnQsIGFuZCB3aWxsIGJlIGFkanVzdGVkIGJ5XG4gICAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICAgIHJlZmVyZW5jZTogc3RhdGUucmVjdHMucmVmZXJlbmNlLFxuICAgICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICAgIH0pO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG4gIGNvbnN0IHBvcHBlck9mZnNldHMkMSA9IHtcbiAgICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBwaGFzZTogJ3JlYWQnLFxuICAgIGZuOiBwb3BwZXJPZmZzZXRzLFxuICAgIGRhdGE6IHt9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0QWx0QXhpcyhheGlzKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgICB0ZXRoZXIgPSBfb3B0aW9ucyR0ZXRoZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyR0ZXRoZXIsXG4gICAgICAgIF9vcHRpb25zJHRldGhlck9mZnNldCA9IG9wdGlvbnMudGV0aGVyT2Zmc2V0LFxuICAgICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gICAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeVxuICAgIH0pO1xuICAgIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICAgIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KTtcbiAgICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgICB2YXIgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gICAgdmFyIGFsdEF4aXMgPSBnZXRBbHRBeGlzKG1haW5BeGlzKTtcbiAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICAgIH0pKSA6IHRldGhlck9mZnNldDtcbiAgICB2YXIgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldFZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICAgIG1haW5BeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZSxcbiAgICAgIGFsdEF4aXM6IHRldGhlck9mZnNldFZhbHVlXG4gICAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbWFpbkF4aXM6IDAsXG4gICAgICBhbHRBeGlzOiAwXG4gICAgfSwgdGV0aGVyT2Zmc2V0VmFsdWUpO1xuICAgIHZhciBvZmZzZXRNb2RpZmllclN0YXRlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdIDogbnVsbDtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcblxuICAgIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkO1xuXG4gICAgICB2YXIgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgICAgIHZhciBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICB2YXIgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc107XG4gICAgICB2YXIgbWluJDEgPSBvZmZzZXQgKyBvdmVyZmxvd1ttYWluU2lkZV07XG4gICAgICB2YXIgbWF4JDEgPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICAgIHZhciBhZGRpdGl2ZSA9IHRldGhlciA/IC1wb3BwZXJSZWN0W2xlbl0gLyAyIDogMDtcbiAgICAgIHZhciBtaW5MZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gcmVmZXJlbmNlUmVjdFtsZW5dIDogcG9wcGVyUmVjdFtsZW5dO1xuICAgICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAgIC8vIG91dHNpZGUgdGhlIHJlZmVyZW5jZSBib3VuZHNcblxuICAgICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICAgICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH07XG4gICAgICB2YXIgYXJyb3dQYWRkaW5nT2JqZWN0ID0gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddID8gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddLnBhZGRpbmcgOiBnZXRGcmVzaFNpZGVPYmplY3QoKTtcbiAgICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xuICAgICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAgIC8vIHRvIGluY2x1ZGUgaXRzIGZ1bGwgc2l6ZSBpbiB0aGUgY2FsY3VsYXRpb24uIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGxcbiAgICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXG4gICAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgICAvLyB3aWR0aCBvciBoZWlnaHQpXG5cbiAgICAgIHZhciBhcnJvd0xlbiA9IHdpdGhpbigwLCByZWZlcmVuY2VSZWN0W2xlbl0sIGFycm93UmVjdFtsZW5dKTtcbiAgICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1pbkxlbiAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgICAgdmFyIG1heE9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IC1yZWZlcmVuY2VSZWN0W2xlbl0gLyAyICsgYWRkaXRpdmUgKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1heExlbiArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICAgIHZhciBjbGllbnRPZmZzZXQgPSBhcnJvd09mZnNldFBhcmVudCA/IG1haW5BeGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRUb3AgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudExlZnQgfHwgMCA6IDA7XG4gICAgICB2YXIgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW21haW5BeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJCA6IDA7XG4gICAgICB2YXIgdGV0aGVyTWluID0gb2Zmc2V0ICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICAgIHZhciB0ZXRoZXJNYXggPSBvZmZzZXQgKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuICAgICAgdmFyIHByZXZlbnRlZE9mZnNldCA9IHdpdGhpbih0ZXRoZXIgPyBtaW4obWluJDEsIHRldGhlck1pbikgOiBtaW4kMSwgb2Zmc2V0LCB0ZXRoZXIgPyBtYXgobWF4JDEsIHRldGhlck1heCkgOiBtYXgkMSk7XG4gICAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcbiAgICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyO1xuXG4gICAgICB2YXIgX21haW5TaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IHRvcCA6IGxlZnQ7XG5cbiAgICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBib3R0b20gOiByaWdodDtcblxuICAgICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgICB2YXIgX2xlbiA9IGFsdEF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcblxuICAgICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgICB2YXIgaXNPcmlnaW5TaWRlID0gW3RvcCwgbGVmdF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVthbHRBeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJDIgOiAwO1xuXG4gICAgICB2YXIgX3RldGhlck1pbiA9IGlzT3JpZ2luU2lkZSA/IF9taW4gOiBfb2Zmc2V0IC0gcmVmZXJlbmNlUmVjdFtfbGVuXSAtIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xuXG4gICAgICB2YXIgX3RldGhlck1heCA9IGlzT3JpZ2luU2lkZSA/IF9vZmZzZXQgKyByZWZlcmVuY2VSZWN0W19sZW5dICsgcG9wcGVyUmVjdFtfbGVuXSAtIF9vZmZzZXRNb2RpZmllclZhbHVlIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXMgOiBfbWF4O1xuXG4gICAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHRldGhlciAmJiBpc09yaWdpblNpZGUgPyB3aXRoaW5NYXhDbGFtcChfdGV0aGVyTWluLCBfb2Zmc2V0LCBfdGV0aGVyTWF4KSA6IHdpdGhpbih0ZXRoZXIgPyBfdGV0aGVyTWluIDogX21pbiwgX29mZnNldCwgdGV0aGVyID8gX3RldGhlck1heCA6IF9tYXgpO1xuXG4gICAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcbiAgICAgIGRhdGFbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0IC0gX29mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuICBjb25zdCBwcmV2ZW50T3ZlcmZsb3ckMSA9IHtcbiAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHBoYXNlOiAnbWFpbicsXG4gICAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddXG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRTY3JvbGwoZWxlbWVudCkge1xuICAgIHJldHVybiB7XG4gICAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5vZGVTY3JvbGwobm9kZSkge1xuICAgIGlmIChub2RlID09PSBnZXRXaW5kb3cobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRIVE1MRWxlbWVudFNjcm9sbChub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0VsZW1lbnRTY2FsZWQoZWxlbWVudCkge1xuICAgIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gICAgdmFyIHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gICAgcmV0dXJuIHNjYWxlWCAhPT0gMSB8fCBzY2FsZVkgIT09IDE7XG4gIH0gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuICAvLyBDb21wb3NpdGUgbWVhbnMgaXQgdGFrZXMgaW50byBhY2NvdW50IHRyYW5zZm9ybXMgYXMgd2VsbCBhcyBsYXlvdXQuXG5cblxuICBmdW5jdGlvbiBnZXRDb21wb3NpdGVSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnQsIGlzRml4ZWQpIHtcbiAgICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpc0ZpeGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICAgIHZhciBvZmZzZXRQYXJlbnRJc1NjYWxlZCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBpc0VsZW1lbnRTY2FsZWQob2Zmc2V0UGFyZW50KTtcbiAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gICAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudElzU2NhbGVkLCBpc0ZpeGVkKTtcbiAgICB2YXIgc2Nyb2xsID0ge1xuICAgICAgc2Nyb2xsTGVmdDogMCxcbiAgICAgIHNjcm9sbFRvcDogMFxuICAgIH07XG4gICAgdmFyIG9mZnNldHMgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG5cbiAgICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgICAgaXNTY3JvbGxQYXJlbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgICAgb2Zmc2V0cyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUpO1xuICAgICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICAgIG9mZnNldHMueSArPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcbiAgICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICAgIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG5cbiAgICBmdW5jdGlvbiBzb3J0KG1vZGlmaWVyKSB7XG4gICAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcbiAgICAgIHZhciByZXF1aXJlcyA9IFtdLmNvbmNhdChtb2RpZmllci5yZXF1aXJlcyB8fCBbXSwgbW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgICByZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XG4gICAgICAgICAgdmFyIGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xuXG4gICAgICAgICAgaWYgKGRlcE1vZGlmaWVyKSB7XG4gICAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xuICAgIH1cblxuICAgIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xuICAgICAgICAvLyBjaGVjayBmb3IgdmlzaXRlZCBvYmplY3RcbiAgICAgICAgc29ydChtb2RpZmllcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9yZGVyTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICAgIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICAgIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTsgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcblxuICAgIHJldHVybiBtb2RpZmllclBoYXNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGhhc2UpIHtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICByZXR1cm4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlO1xuICAgICAgfSkpO1xuICAgIH0sIFtdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlKGZuKSB7XG4gICAgdmFyIHBlbmRpbmc7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghcGVuZGluZykge1xuICAgICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBlbmRpbmc7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xuICAgIHZhciBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKGZ1bmN0aW9uIChtZXJnZWQsIGN1cnJlbnQpIHtcbiAgICAgIHZhciBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBjdXJyZW50LCB7XG4gICAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLm9wdGlvbnMsIGN1cnJlbnQub3B0aW9ucyksXG4gICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLmRhdGEsIGN1cnJlbnQuZGF0YSlcbiAgICAgIH0pIDogY3VycmVudDtcbiAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfSwge30pOyAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBtZXJnZWRba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICBtb2RpZmllcnM6IFtdLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG4gIH07XG5cbiAgZnVuY3Rpb24gYXJlVmFsaWRFbGVtZW50cygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiAhKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zKSB7XG4gICAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgZ2VuZXJhdG9yT3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXG4gICAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRNb2RpZmllcnMsXG4gICAgICAgIGRlZmF1bHRNb2RpZmllcnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPT09IHZvaWQgMCA/IFtdIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmLFxuICAgICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIGRlZmF1bHRPcHRpb25zID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9PT0gdm9pZCAwID8gREVGQVVMVF9PUFRJT05TIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgICBlbGVtZW50czoge1xuICAgICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICAgIHBvcHBlcjogcG9wcGVyXG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICBzdHlsZXM6IHt9XG4gICAgICB9O1xuICAgICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgdmFyIGluc3RhbmNlID0ge1xuICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMoc2V0T3B0aW9uc0FjdGlvbikge1xuICAgICAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHNldE9wdGlvbnNBY3Rpb24gPT09ICdmdW5jdGlvbicgPyBzZXRPcHRpb25zQWN0aW9uKHN0YXRlLm9wdGlvbnMpIDogc2V0T3B0aW9uc0FjdGlvbjtcbiAgICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgICAgc3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBzdGF0ZS5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlcilcbiAgICAgICAgICB9OyAvLyBPcmRlcnMgdGhlIG1vZGlmaWVycyBiYXNlZCBvbiB0aGVpciBkZXBlbmRlbmNpZXMgYW5kIGBwaGFzZWBcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyTW9kaWZpZXJzKG1lcmdlQnlOYW1lKFtdLmNvbmNhdChkZWZhdWx0TW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycykpKTsgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xuXG4gICAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5lbmFibGVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJ1bk1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgICAvLyBsb2dpYy5cbiAgICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3N0YXRlJGVsZW1lbnRzID0gc3RhdGUuZWxlbWVudHMsXG4gICAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXG4gICAgICAgICAgICAgIHBvcHBlciA9IF9zdGF0ZSRlbGVtZW50cy5wb3BwZXI7IC8vIERvbid0IHByb2NlZWQgaWYgYHJlZmVyZW5jZWAgb3IgYHBvcHBlcmAgYXJlIG5vdCB2YWxpZCBlbGVtZW50c1xuICAgICAgICAgIC8vIGFueW1vcmVcblxuICAgICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xuXG5cbiAgICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICAgIHBvcHBlcjogZ2V0TGF5b3V0UmVjdChwb3BwZXIpXG4gICAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcbiAgICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAgIC8vIHBsYWNlbWVudCwgd2hpY2ggdGhlbiBuZWVkcyB0byByZS1ydW4gYWxsIHRoZSBtb2RpZmllcnMsIGJlY2F1c2UgdGhlXG4gICAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7IC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cbiAgICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcblxuICAgICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5tb2RpZmllcnNEYXRhW21vZGlmaWVyLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kaWZpZXIuZGF0YSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5yZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZSA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnNbaW5kZXhdLFxuICAgICAgICAgICAgICAgIGZuID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLmZuLFxuICAgICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBfb3B0aW9ucyA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPT09IHZvaWQgMCA/IHt9IDogX3N0YXRlJG9yZGVyZWRNb2RpZmllMixcbiAgICAgICAgICAgICAgICBuYW1lID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm5hbWU7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBmbih7XG4gICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXG4gICAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxuICAgICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICAgIGlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgaWYgKCFpc0Rlc3Ryb3llZCAmJiBvcHRpb25zLm9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgICAvLyB1cGRhdGUgY3ljbGUgcnVucy4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1cGRhdGVcbiAgICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XG4gICAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAgIC8vIG9uZS5cblxuICAgICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgICAgICAgX3JlZiRvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgICAgICAgICBvcHRpb25zID0gX3JlZiRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkb3B0aW9ucyxcbiAgICAgICAgICAgICAgZWZmZWN0ID0gX3JlZi5lZmZlY3Q7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XG4gICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIG5vb3BGbiA9IGZ1bmN0aW9uIG5vb3BGbigpIHt9O1xuXG4gICAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcbiAgfVxuICB2YXIgY3JlYXRlUG9wcGVyJDIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuICB2YXIgZGVmYXVsdE1vZGlmaWVycyQxID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzJDEsIGNvbXB1dGVTdHlsZXMkMSwgYXBwbHlTdHlsZXMkMV07XG4gIHZhciBjcmVhdGVQb3BwZXIkMSA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICAgIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnMkMVxuICB9KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG4gIHZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzJDEsIGNvbXB1dGVTdHlsZXMkMSwgYXBwbHlTdHlsZXMkMSwgb2Zmc2V0JDEsIGZsaXAkMSwgcHJldmVudE92ZXJmbG93JDEsIGFycm93JDEsIGhpZGUkMV07XG4gIHZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG4gIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbiAgY29uc3QgUG9wcGVyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoLyojX19QVVJFX18qL09iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGFmdGVyTWFpbixcbiAgICBhZnRlclJlYWQsXG4gICAgYWZ0ZXJXcml0ZSxcbiAgICBhcHBseVN0eWxlczogYXBwbHlTdHlsZXMkMSxcbiAgICBhcnJvdzogYXJyb3ckMSxcbiAgICBhdXRvLFxuICAgIGJhc2VQbGFjZW1lbnRzLFxuICAgIGJlZm9yZU1haW4sXG4gICAgYmVmb3JlUmVhZCxcbiAgICBiZWZvcmVXcml0ZSxcbiAgICBib3R0b20sXG4gICAgY2xpcHBpbmdQYXJlbnRzLFxuICAgIGNvbXB1dGVTdHlsZXM6IGNvbXB1dGVTdHlsZXMkMSxcbiAgICBjcmVhdGVQb3BwZXIsXG4gICAgY3JlYXRlUG9wcGVyQmFzZTogY3JlYXRlUG9wcGVyJDIsXG4gICAgY3JlYXRlUG9wcGVyTGl0ZTogY3JlYXRlUG9wcGVyJDEsXG4gICAgZGV0ZWN0T3ZlcmZsb3csXG4gICAgZW5kLFxuICAgIGV2ZW50TGlzdGVuZXJzLFxuICAgIGZsaXA6IGZsaXAkMSxcbiAgICBoaWRlOiBoaWRlJDEsXG4gICAgbGVmdCxcbiAgICBtYWluLFxuICAgIG1vZGlmaWVyUGhhc2VzLFxuICAgIG9mZnNldDogb2Zmc2V0JDEsXG4gICAgcGxhY2VtZW50cyxcbiAgICBwb3BwZXIsXG4gICAgcG9wcGVyR2VuZXJhdG9yLFxuICAgIHBvcHBlck9mZnNldHM6IHBvcHBlck9mZnNldHMkMSxcbiAgICBwcmV2ZW50T3ZlcmZsb3c6IHByZXZlbnRPdmVyZmxvdyQxLFxuICAgIHJlYWQsXG4gICAgcmVmZXJlbmNlLFxuICAgIHJpZ2h0LFxuICAgIHN0YXJ0LFxuICAgIHRvcCxcbiAgICB2YXJpYXRpb25QbGFjZW1lbnRzLFxuICAgIHZpZXdwb3J0LFxuICAgIHdyaXRlXG4gIH0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSkpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgZHJvcGRvd24uanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBOQU1FJGEgPSAnZHJvcGRvd24nO1xuICBjb25zdCBEQVRBX0tFWSQ2ID0gJ2JzLmRyb3Bkb3duJztcbiAgY29uc3QgRVZFTlRfS0VZJDYgPSBgLiR7REFUQV9LRVkkNn1gO1xuICBjb25zdCBEQVRBX0FQSV9LRVkkMyA9ICcuZGF0YS1hcGknO1xuICBjb25zdCBFU0NBUEVfS0VZJDIgPSAnRXNjYXBlJztcbiAgY29uc3QgVEFCX0tFWSQxID0gJ1RhYic7XG4gIGNvbnN0IEFSUk9XX1VQX0tFWSQxID0gJ0Fycm93VXAnO1xuICBjb25zdCBBUlJPV19ET1dOX0tFWSQxID0gJ0Fycm93RG93bic7XG4gIGNvbnN0IFJJR0hUX01PVVNFX0JVVFRPTiA9IDI7IC8vIE1vdXNlRXZlbnQuYnV0dG9uIHZhbHVlIGZvciB0aGUgc2Vjb25kYXJ5IGJ1dHRvbiwgdXN1YWxseSB0aGUgcmlnaHQgYnV0dG9uXG5cbiAgY29uc3QgRVZFTlRfSElERSQ1ID0gYGhpZGUke0VWRU5UX0tFWSQ2fWA7XG4gIGNvbnN0IEVWRU5UX0hJRERFTiQ1ID0gYGhpZGRlbiR7RVZFTlRfS0VZJDZ9YDtcbiAgY29uc3QgRVZFTlRfU0hPVyQ1ID0gYHNob3cke0VWRU5UX0tFWSQ2fWA7XG4gIGNvbnN0IEVWRU5UX1NIT1dOJDUgPSBgc2hvd24ke0VWRU5UX0tFWSQ2fWA7XG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMgPSBgY2xpY2ske0VWRU5UX0tFWSQ2fSR7REFUQV9BUElfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSA9IGBrZXlkb3duJHtFVkVOVF9LRVkkNn0ke0RBVEFfQVBJX0tFWSQzfWA7XG4gIGNvbnN0IEVWRU5UX0tFWVVQX0RBVEFfQVBJID0gYGtleXVwJHtFVkVOVF9LRVkkNn0ke0RBVEFfQVBJX0tFWSQzfWA7XG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQ2ID0gJ3Nob3cnO1xuICBjb25zdCBDTEFTU19OQU1FX0RST1BVUCA9ICdkcm9wdXAnO1xuICBjb25zdCBDTEFTU19OQU1FX0RST1BFTkQgPSAnZHJvcGVuZCc7XG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUFNUQVJUID0gJ2Ryb3BzdGFydCc7XG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUFVQX0NFTlRFUiA9ICdkcm9wdXAtY2VudGVyJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9EUk9QRE9XTl9DRU5URVIgPSAnZHJvcGRvd24tY2VudGVyJztcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkMyA9ICdbZGF0YS1icy10b2dnbGU9XCJkcm9wZG93blwiXTpub3QoLmRpc2FibGVkKTpub3QoOmRpc2FibGVkKSc7XG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFX1NIT1dOID0gYCR7U0VMRUNUT1JfREFUQV9UT0dHTEUkM30uJHtDTEFTU19OQU1FX1NIT1ckNn1gO1xuICBjb25zdCBTRUxFQ1RPUl9NRU5VID0gJy5kcm9wZG93bi1tZW51JztcbiAgY29uc3QgU0VMRUNUT1JfTkFWQkFSID0gJy5uYXZiYXInO1xuICBjb25zdCBTRUxFQ1RPUl9OQVZCQVJfTkFWID0gJy5uYXZiYXItbmF2JztcbiAgY29uc3QgU0VMRUNUT1JfVklTSUJMRV9JVEVNUyA9ICcuZHJvcGRvd24tbWVudSAuZHJvcGRvd24taXRlbTpub3QoLmRpc2FibGVkKTpub3QoOmRpc2FibGVkKSc7XG4gIGNvbnN0IFBMQUNFTUVOVF9UT1AgPSBpc1JUTCgpID8gJ3RvcC1lbmQnIDogJ3RvcC1zdGFydCc7XG4gIGNvbnN0IFBMQUNFTUVOVF9UT1BFTkQgPSBpc1JUTCgpID8gJ3RvcC1zdGFydCcgOiAndG9wLWVuZCc7XG4gIGNvbnN0IFBMQUNFTUVOVF9CT1RUT00gPSBpc1JUTCgpID8gJ2JvdHRvbS1lbmQnIDogJ2JvdHRvbS1zdGFydCc7XG4gIGNvbnN0IFBMQUNFTUVOVF9CT1RUT01FTkQgPSBpc1JUTCgpID8gJ2JvdHRvbS1zdGFydCcgOiAnYm90dG9tLWVuZCc7XG4gIGNvbnN0IFBMQUNFTUVOVF9SSUdIVCA9IGlzUlRMKCkgPyAnbGVmdC1zdGFydCcgOiAncmlnaHQtc3RhcnQnO1xuICBjb25zdCBQTEFDRU1FTlRfTEVGVCA9IGlzUlRMKCkgPyAncmlnaHQtc3RhcnQnIDogJ2xlZnQtc3RhcnQnO1xuICBjb25zdCBQTEFDRU1FTlRfVE9QQ0VOVEVSID0gJ3RvcCc7XG4gIGNvbnN0IFBMQUNFTUVOVF9CT1RUT01DRU5URVIgPSAnYm90dG9tJztcbiAgY29uc3QgRGVmYXVsdCQ5ID0ge1xuICAgIGF1dG9DbG9zZTogdHJ1ZSxcbiAgICBib3VuZGFyeTogJ2NsaXBwaW5nUGFyZW50cycsXG4gICAgZGlzcGxheTogJ2R5bmFtaWMnLFxuICAgIG9mZnNldDogWzAsIDJdLFxuICAgIHBvcHBlckNvbmZpZzogbnVsbCxcbiAgICByZWZlcmVuY2U6ICd0b2dnbGUnXG4gIH07XG4gIGNvbnN0IERlZmF1bHRUeXBlJDkgPSB7XG4gICAgYXV0b0Nsb3NlOiAnKGJvb2xlYW58c3RyaW5nKScsXG4gICAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgICBkaXNwbGF5OiAnc3RyaW5nJyxcbiAgICBvZmZzZXQ6ICcoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKScsXG4gICAgcG9wcGVyQ29uZmlnOiAnKG51bGx8b2JqZWN0fGZ1bmN0aW9uKScsXG4gICAgcmVmZXJlbmNlOiAnKHN0cmluZ3xlbGVtZW50fG9iamVjdCknXG4gIH07XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgRHJvcGRvd24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xuICAgICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlOyAvLyBkcm9wZG93biB3cmFwcGVyXG4gICAgICAvLyBUT0RPOiB2NiByZXZlcnQgIzM3MDExICYgY2hhbmdlIG1hcmt1cCBodHRwczovL2dldGJvb3RzdHJhcC5jb20vZG9jcy81LjMvZm9ybXMvaW5wdXQtZ3JvdXAvXG4gICAgICB0aGlzLl9tZW51ID0gU2VsZWN0b3JFbmdpbmUubmV4dCh0aGlzLl9lbGVtZW50LCBTRUxFQ1RPUl9NRU5VKVswXSB8fCBTZWxlY3RvckVuZ2luZS5wcmV2KHRoaXMuX2VsZW1lbnQsIFNFTEVDVE9SX01FTlUpWzBdIHx8IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfTUVOVSwgdGhpcy5fcGFyZW50KTtcbiAgICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCk7XG4gICAgfVxuXG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0JDk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkOTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkYTtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICB0b2dnbGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgIGlmIChpc0Rpc2FibGVkKHRoaXMuX2VsZW1lbnQpIHx8IHRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ1LCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jcmVhdGVQb3BwZXIoKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB0byB0aGUgYm9keSdzIGltbWVkaWF0ZSBjaGlsZHJlbjtcbiAgICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXG4gICAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgIXRoaXMuX3BhcmVudC5jbG9zZXN0KFNFTEVDVE9SX05BVkJBUl9OQVYpKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcbiAgICAgICAgICBFdmVudEhhbmRsZXIub24oZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuICAgICAgdGhpcy5fbWVudS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ2KTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNik7XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQ1LCByZWxhdGVkVGFyZ2V0KTtcbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgIGlmIChpc0Rpc2FibGVkKHRoaXMuX2VsZW1lbnQpIHx8ICF0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgICAgfTtcbiAgICAgIHRoaXMuX2NvbXBsZXRlSGlkZShyZWxhdGVkVGFyZ2V0KTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKTtcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNSwgcmVsYXRlZFRhcmdldCk7XG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xuICAgICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tZW51LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDYpO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ2KTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgICBNYW5pcHVsYXRvci5yZW1vdmVEYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsICdwb3BwZXInKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQ1LCByZWxhdGVkVGFyZ2V0KTtcbiAgICB9XG4gICAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9IHN1cGVyLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZmVyZW5jZSA9PT0gJ29iamVjdCcgJiYgIWlzRWxlbWVudCQxKGNvbmZpZy5yZWZlcmVuY2UpICYmIHR5cGVvZiBjb25maWcucmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBQb3BwZXIgdmlydHVhbCBlbGVtZW50cyByZXF1aXJlIGEgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG1ldGhvZFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke05BTUUkYS50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwicmVmZXJlbmNlXCIgcHJvdmlkZWQgdHlwZSBcIm9iamVjdFwiIHdpdGhvdXQgYSByZXF1aXJlZCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiIG1ldGhvZC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICAgIF9jcmVhdGVQb3BwZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyBkcm9wZG93bnMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZyknKTtcbiAgICAgIH1cbiAgICAgIGxldCByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fZWxlbWVudDtcbiAgICAgIGlmICh0aGlzLl9jb25maWcucmVmZXJlbmNlID09PSAncGFyZW50Jykge1xuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgfSBlbHNlIGlmIChpc0VsZW1lbnQkMSh0aGlzLl9jb25maWcucmVmZXJlbmNlKSkge1xuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gZ2V0RWxlbWVudCh0aGlzLl9jb25maWcucmVmZXJlbmNlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9jb25maWcucmVmZXJlbmNlO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9wcGVyQ29uZmlnID0gdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKCk7XG4gICAgICB0aGlzLl9wb3BwZXIgPSBjcmVhdGVQb3BwZXIocmVmZXJlbmNlRWxlbWVudCwgdGhpcy5fbWVudSwgcG9wcGVyQ29uZmlnKTtcbiAgICB9XG4gICAgX2lzU2hvd24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWVudS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDYpO1xuICAgIH1cbiAgICBfZ2V0UGxhY2VtZW50KCkge1xuICAgICAgY29uc3QgcGFyZW50RHJvcGRvd24gPSB0aGlzLl9wYXJlbnQ7XG4gICAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUEVORCkpIHtcbiAgICAgICAgcmV0dXJuIFBMQUNFTUVOVF9SSUdIVDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QU1RBUlQpKSB7XG4gICAgICAgIHJldHVybiBQTEFDRU1FTlRfTEVGVDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QVVBfQ0VOVEVSKSkge1xuICAgICAgICByZXR1cm4gUExBQ0VNRU5UX1RPUENFTlRFUjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRE9XTl9DRU5URVIpKSB7XG4gICAgICAgIHJldHVybiBQTEFDRU1FTlRfQk9UVE9NQ0VOVEVSO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBuZWVkIHRvIHRyaW0gdGhlIHZhbHVlIGJlY2F1c2UgY3VzdG9tIHByb3BlcnRpZXMgY2FuIGFsc28gaW5jbHVkZSBzcGFjZXNcbiAgICAgIGNvbnN0IGlzRW5kID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9tZW51KS5nZXRQcm9wZXJ0eVZhbHVlKCctLWJzLXBvc2l0aW9uJykudHJpbSgpID09PSAnZW5kJztcbiAgICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QVVApKSB7XG4gICAgICAgIHJldHVybiBpc0VuZCA/IFBMQUNFTUVOVF9UT1BFTkQgOiBQTEFDRU1FTlRfVE9QO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRW5kID8gUExBQ0VNRU5UX0JPVFRPTUVORCA6IFBMQUNFTUVOVF9CT1RUT007XG4gICAgfVxuICAgIF9kZXRlY3ROYXZiYXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX05BVkJBUikgIT09IG51bGw7XG4gICAgfVxuICAgIF9nZXRPZmZzZXQoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IHRoaXMuX2NvbmZpZztcbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gb2Zmc2V0LnNwbGl0KCcsJykubWFwKHZhbHVlID0+IE51bWJlci5wYXJzZUludCh2YWx1ZSwgMTApKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBwb3BwZXJEYXRhID0+IG9mZnNldChwb3BwZXJEYXRhLCB0aGlzLl9lbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIF9nZXRQb3BwZXJDb25maWcoKSB7XG4gICAgICBjb25zdCBkZWZhdWx0QnNQb3BwZXJDb25maWcgPSB7XG4gICAgICAgIHBsYWNlbWVudDogdGhpcy5fZ2V0UGxhY2VtZW50KCksXG4gICAgICAgIG1vZGlmaWVyczogW3tcbiAgICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLl9nZXRPZmZzZXQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfV1cbiAgICAgIH07XG5cbiAgICAgIC8vIERpc2FibGUgUG9wcGVyIGlmIHdlIGhhdmUgYSBzdGF0aWMgZGlzcGxheSBvciBEcm9wZG93biBpcyBpbiBOYXZiYXJcbiAgICAgIGlmICh0aGlzLl9pbk5hdmJhciB8fCB0aGlzLl9jb25maWcuZGlzcGxheSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCAncG9wcGVyJywgJ3N0YXRpYycpOyAvLyBUT0RPOiB2NiByZW1vdmVcbiAgICAgICAgZGVmYXVsdEJzUG9wcGVyQ29uZmlnLm1vZGlmaWVycyA9IFt7XG4gICAgICAgICAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmRlZmF1bHRCc1BvcHBlckNvbmZpZyxcbiAgICAgICAgLi4uZXhlY3V0ZSh0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnLCBbZGVmYXVsdEJzUG9wcGVyQ29uZmlnXSlcbiAgICAgIH07XG4gICAgfVxuICAgIF9zZWxlY3RNZW51SXRlbSh7XG4gICAgICBrZXksXG4gICAgICB0YXJnZXRcbiAgICB9KSB7XG4gICAgICBjb25zdCBpdGVtcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfVklTSUJMRV9JVEVNUywgdGhpcy5fbWVudSkuZmlsdGVyKGVsZW1lbnQgPT4gaXNWaXNpYmxlKGVsZW1lbnQpKTtcbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGFyZ2V0IGlzbid0IGluY2x1ZGVkIGluIGl0ZW1zIChlLmcuIHdoZW4gZXhwYW5kaW5nIHRoZSBkcm9wZG93bilcbiAgICAgIC8vIGFsbG93IGN5Y2xpbmcgdG8gZ2V0IHRoZSBsYXN0IGl0ZW0gaW4gY2FzZSBrZXkgZXF1YWxzIEFSUk9XX1VQX0tFWVxuICAgICAgZ2V0TmV4dEFjdGl2ZUVsZW1lbnQoaXRlbXMsIHRhcmdldCwga2V5ID09PSBBUlJPV19ET1dOX0tFWSQxLCAhaXRlbXMuaW5jbHVkZXModGFyZ2V0KSkuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBEcm9wZG93bi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBjbGVhck1lbnVzKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuYnV0dG9uID09PSBSSUdIVF9NT1VTRV9CVVRUT04gfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC5rZXkgIT09IFRBQl9LRVkkMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvcGVuVG9nZ2xlcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9UT0dHTEVfU0hPV04pO1xuICAgICAgZm9yIChjb25zdCB0b2dnbGUgb2Ygb3BlblRvZ2dsZXMpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IERyb3Bkb3duLmdldEluc3RhbmNlKHRvZ2dsZSk7XG4gICAgICAgIGlmICghY29udGV4dCB8fCBjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSBmYWxzZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBvc2VkUGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgICAgICBjb25zdCBpc01lbnVUYXJnZXQgPSBjb21wb3NlZFBhdGguaW5jbHVkZXMoY29udGV4dC5fbWVudSk7XG4gICAgICAgIGlmIChjb21wb3NlZFBhdGguaW5jbHVkZXMoY29udGV4dC5fZWxlbWVudCkgfHwgY29udGV4dC5fY29uZmlnLmF1dG9DbG9zZSA9PT0gJ2luc2lkZScgJiYgIWlzTWVudVRhcmdldCB8fCBjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSAnb3V0c2lkZScgJiYgaXNNZW51VGFyZ2V0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUYWIgbmF2aWdhdGlvbiB0aHJvdWdoIHRoZSBkcm9wZG93biBtZW51IG9yIGV2ZW50cyBmcm9tIGNvbnRhaW5lZCBpbnB1dHMgc2hvdWxkbid0IGNsb3NlIHRoZSBtZW51XG4gICAgICAgIGlmIChjb250ZXh0Ll9tZW51LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkgJiYgKGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQua2V5ID09PSBUQUJfS0VZJDEgfHwgL2lucHV0fHNlbGVjdHxvcHRpb258dGV4dGFyZWF8Zm9ybS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogY29udGV4dC5fZWxlbWVudFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQuY2xpY2tFdmVudCA9IGV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuX2NvbXBsZXRlSGlkZShyZWxhdGVkVGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGRhdGFBcGlLZXlkb3duSGFuZGxlcihldmVudCkge1xuICAgICAgLy8gSWYgbm90IGFuIFVQIHwgRE9XTiB8IEVTQ0FQRSBrZXkgPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgICAgLy8gSWYgaW5wdXQvdGV4dGFyZWEgJiYgaWYga2V5IGlzIG90aGVyIHRoYW4gRVNDQVBFID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcblxuICAgICAgY29uc3QgaXNJbnB1dCA9IC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpO1xuICAgICAgY29uc3QgaXNFc2NhcGVFdmVudCA9IGV2ZW50LmtleSA9PT0gRVNDQVBFX0tFWSQyO1xuICAgICAgY29uc3QgaXNVcE9yRG93bkV2ZW50ID0gW0FSUk9XX1VQX0tFWSQxLCBBUlJPV19ET1dOX0tFWSQxXS5pbmNsdWRlcyhldmVudC5rZXkpO1xuICAgICAgaWYgKCFpc1VwT3JEb3duRXZlbnQgJiYgIWlzRXNjYXBlRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzSW5wdXQgJiYgIWlzRXNjYXBlRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgLy8gVE9ETzogdjYgcmV2ZXJ0ICMzNzAxMSAmIGNoYW5nZSBtYXJrdXAgaHR0cHM6Ly9nZXRib290c3RyYXAuY29tL2RvY3MvNS4zL2Zvcm1zL2lucHV0LWdyb3VwL1xuICAgICAgY29uc3QgZ2V0VG9nZ2xlQnV0dG9uID0gdGhpcy5tYXRjaGVzKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMpID8gdGhpcyA6IFNlbGVjdG9yRW5naW5lLnByZXYodGhpcywgU0VMRUNUT1JfREFUQV9UT0dHTEUkMylbMF0gfHwgU2VsZWN0b3JFbmdpbmUubmV4dCh0aGlzLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzKVswXSB8fCBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMsIGV2ZW50LmRlbGVnYXRlVGFyZ2V0LnBhcmVudE5vZGUpO1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBEcm9wZG93bi5nZXRPckNyZWF0ZUluc3RhbmNlKGdldFRvZ2dsZUJ1dHRvbik7XG4gICAgICBpZiAoaXNVcE9yRG93bkV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpbnN0YW5jZS5zaG93KCk7XG4gICAgICAgIGluc3RhbmNlLl9zZWxlY3RNZW51SXRlbShldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpbnN0YW5jZS5faXNTaG93bigpKSB7XG4gICAgICAgIC8vIGVsc2UgaXMgZXNjYXBlIGFuZCB3ZSBjaGVjayBpZiBpdCBpcyBzaG93blxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgICAgICBnZXRUb2dnbGVCdXR0b24uZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAgICovXG5cbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9LRVlET1dOX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzLCBEcm9wZG93bi5kYXRhQXBpS2V5ZG93bkhhbmRsZXIpO1xuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fREFUQV9BUEksIFNFTEVDVE9SX01FTlUsIERyb3Bkb3duLmRhdGFBcGlLZXlkb3duSGFuZGxlcik7XG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMywgRHJvcGRvd24uY2xlYXJNZW51cyk7XG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZVVBfREFUQV9BUEksIERyb3Bkb3duLmNsZWFyTWVudXMpO1xuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgRHJvcGRvd24uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKS50b2dnbGUoKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oRHJvcGRvd24pO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgdXRpbC9iYWNrZHJvcC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkOSA9ICdiYWNrZHJvcCc7XG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQ0ID0gJ2ZhZGUnO1xuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckNSA9ICdzaG93JztcbiAgY29uc3QgRVZFTlRfTU9VU0VET1dOID0gYG1vdXNlZG93bi5icy4ke05BTUUkOX1gO1xuICBjb25zdCBEZWZhdWx0JDggPSB7XG4gICAgY2xhc3NOYW1lOiAnbW9kYWwtYmFja2Ryb3AnLFxuICAgIGNsaWNrQ2FsbGJhY2s6IG51bGwsXG4gICAgaXNBbmltYXRlZDogZmFsc2UsXG4gICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgIC8vIGlmIGZhbHNlLCB3ZSB1c2UgdGhlIGJhY2tkcm9wIGhlbHBlciB3aXRob3V0IGFkZGluZyBhbnkgZWxlbWVudCB0byB0aGUgZG9tXG4gICAgcm9vdEVsZW1lbnQ6ICdib2R5JyAvLyBnaXZlIHRoZSBjaG9pY2UgdG8gcGxhY2UgYmFja2Ryb3AgdW5kZXIgZGlmZmVyZW50IGVsZW1lbnRzXG4gIH07XG4gIGNvbnN0IERlZmF1bHRUeXBlJDggPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICBjbGlja0NhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJyxcbiAgICBpc0FuaW1hdGVkOiAnYm9vbGVhbicsXG4gICAgaXNWaXNpYmxlOiAnYm9vbGVhbicsXG4gICAgcm9vdEVsZW1lbnQ6ICcoZWxlbWVudHxzdHJpbmcpJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIEJhY2tkcm9wIGV4dGVuZHMgQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgIHRoaXMuX2lzQXBwZW5kZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCQ4O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDg7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJDk7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgc2hvdyhjYWxsYmFjaykge1xuICAgICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XG4gICAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9hcHBlbmQoKTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9nZXRFbGVtZW50KCk7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpIHtcbiAgICAgICAgcmVmbG93KGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ1KTtcbiAgICAgIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xuICAgICAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBoaWRlKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5pc1Zpc2libGUpIHtcbiAgICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2dldEVsZW1lbnQoKS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ1KTtcbiAgICAgIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIGlmICghdGhpcy5faXNBcHBlbmRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFRE9XTik7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZSgpO1xuICAgICAgdGhpcy5faXNBcHBlbmRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfZ2V0RWxlbWVudCgpIHtcbiAgICAgIGlmICghdGhpcy5fZWxlbWVudCkge1xuICAgICAgICBjb25zdCBiYWNrZHJvcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBiYWNrZHJvcC5jbGFzc05hbWUgPSB0aGlzLl9jb25maWcuY2xhc3NOYW1lO1xuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpIHtcbiAgICAgICAgICBiYWNrZHJvcC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSQ0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbGVtZW50ID0gYmFja2Ryb3A7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgICB9XG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XG4gICAgICAvLyB1c2UgZ2V0RWxlbWVudCgpIHdpdGggdGhlIGRlZmF1bHQgXCJib2R5XCIgdG8gZ2V0IGEgZnJlc2ggRWxlbWVudCBvbiBlYWNoIGluc3RhbnRpYXRpb25cbiAgICAgIGNvbmZpZy5yb290RWxlbWVudCA9IGdldEVsZW1lbnQoY29uZmlnLnJvb3RFbGVtZW50KTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICAgIF9hcHBlbmQoKSB7XG4gICAgICBpZiAodGhpcy5faXNBcHBlbmRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZ2V0RWxlbWVudCgpO1xuICAgICAgdGhpcy5fY29uZmlnLnJvb3RFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbihlbGVtZW50LCBFVkVOVF9NT1VTRURPV04sICgpID0+IHtcbiAgICAgICAgZXhlY3V0ZSh0aGlzLl9jb25maWcuY2xpY2tDYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2lzQXBwZW5kZWQgPSB0cnVlO1xuICAgIH1cbiAgICBfZW11bGF0ZUFuaW1hdGlvbihjYWxsYmFjaykge1xuICAgICAgZXhlY3V0ZUFmdGVyVHJhbnNpdGlvbihjYWxsYmFjaywgdGhpcy5fZ2V0RWxlbWVudCgpLCB0aGlzLl9jb25maWcuaXNBbmltYXRlZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCB1dGlsL2ZvY3VzdHJhcC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkOCA9ICdmb2N1c3RyYXAnO1xuICBjb25zdCBEQVRBX0tFWSQ1ID0gJ2JzLmZvY3VzdHJhcCc7XG4gIGNvbnN0IEVWRU5UX0tFWSQ1ID0gYC4ke0RBVEFfS0VZJDV9YDtcbiAgY29uc3QgRVZFTlRfRk9DVVNJTiQyID0gYGZvY3VzaW4ke0VWRU5UX0tFWSQ1fWA7XG4gIGNvbnN0IEVWRU5UX0tFWURPV05fVEFCID0gYGtleWRvd24udGFiJHtFVkVOVF9LRVkkNX1gO1xuICBjb25zdCBUQUJfS0VZID0gJ1RhYic7XG4gIGNvbnN0IFRBQl9OQVZfRk9SV0FSRCA9ICdmb3J3YXJkJztcbiAgY29uc3QgVEFCX05BVl9CQUNLV0FSRCA9ICdiYWNrd2FyZCc7XG4gIGNvbnN0IERlZmF1bHQkNyA9IHtcbiAgICBhdXRvZm9jdXM6IHRydWUsXG4gICAgdHJhcEVsZW1lbnQ6IG51bGwgLy8gVGhlIGVsZW1lbnQgdG8gdHJhcCBmb2N1cyBpbnNpZGUgb2ZcbiAgfTtcbiAgY29uc3QgRGVmYXVsdFR5cGUkNyA9IHtcbiAgICBhdXRvZm9jdXM6ICdib29sZWFuJyxcbiAgICB0cmFwRWxlbWVudDogJ2VsZW1lbnQnXG4gIH07XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgRm9jdXNUcmFwIGV4dGVuZHMgQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHQkNztcbiAgICB9XG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ3O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gTkFNRSQ4O1xuICAgIH1cblxuICAgIC8vIFB1YmxpY1xuICAgIGFjdGl2YXRlKCkge1xuICAgICAgaWYgKHRoaXMuX2lzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jb25maWcuYXV0b2ZvY3VzKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZy50cmFwRWxlbWVudC5mb2N1cygpO1xuICAgICAgfVxuICAgICAgRXZlbnRIYW5kbGVyLm9mZihkb2N1bWVudCwgRVZFTlRfS0VZJDUpOyAvLyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcbiAgICAgIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTiQyLCBldmVudCA9PiB0aGlzLl9oYW5kbGVGb2N1c2luKGV2ZW50KSk7XG4gICAgICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fVEFCLCBldmVudCA9PiB0aGlzLl9oYW5kbGVLZXlkb3duKGV2ZW50KSk7XG4gICAgICB0aGlzLl9pc0FjdGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKGRvY3VtZW50LCBFVkVOVF9LRVkkNSk7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZVxuICAgIF9oYW5kbGVGb2N1c2luKGV2ZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRyYXBFbGVtZW50XG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gZG9jdW1lbnQgfHwgZXZlbnQudGFyZ2V0ID09PSB0cmFwRWxlbWVudCB8fCB0cmFwRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gU2VsZWN0b3JFbmdpbmUuZm9jdXNhYmxlQ2hpbGRyZW4odHJhcEVsZW1lbnQpO1xuICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0cmFwRWxlbWVudC5mb2N1cygpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID09PSBUQUJfTkFWX0JBQ0tXQVJEKSB7XG4gICAgICAgIGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdLmZvY3VzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50c1swXS5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgICBfaGFuZGxlS2V5ZG93bihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmtleSAhPT0gVEFCX0tFWSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID0gZXZlbnQuc2hpZnRLZXkgPyBUQUJfTkFWX0JBQ0tXQVJEIDogVEFCX05BVl9GT1JXQVJEO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgdXRpbC9zY3JvbGxCYXIuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBTRUxFQ1RPUl9GSVhFRF9DT05URU5UID0gJy5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3AnO1xuICBjb25zdCBTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCA9ICcuc3RpY2t5LXRvcCc7XG4gIGNvbnN0IFBST1BFUlRZX1BBRERJTkcgPSAncGFkZGluZy1yaWdodCc7XG4gIGNvbnN0IFBST1BFUlRZX01BUkdJTiA9ICdtYXJnaW4tcmlnaHQnO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIFNjcm9sbEJhckhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICBnZXRXaWR0aCgpIHtcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvaW5uZXJXaWR0aCN1c2FnZV9ub3Rlc1xuICAgICAgY29uc3QgZG9jdW1lbnRXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50V2lkdGgpO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICB0aGlzLl9kaXNhYmxlT3ZlckZsb3coKTtcbiAgICAgIC8vIGdpdmUgcGFkZGluZyB0byBlbGVtZW50IHRvIGJhbGFuY2UgdGhlIGhpZGRlbiBzY3JvbGxiYXIgd2lkdGhcbiAgICAgIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsIFBST1BFUlRZX1BBRERJTkcsIGNhbGN1bGF0ZWRWYWx1ZSA9PiBjYWxjdWxhdGVkVmFsdWUgKyB3aWR0aCk7XG4gICAgICAvLyB0cmljazogV2UgYWRqdXN0IHBvc2l0aXZlIHBhZGRpbmdSaWdodCBhbmQgbmVnYXRpdmUgbWFyZ2luUmlnaHQgdG8gc3RpY2t5LXRvcCBlbGVtZW50cyB0byBrZWVwIHNob3dpbmcgZnVsbHdpZHRoXG4gICAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9GSVhFRF9DT05URU5ULCBQUk9QRVJUWV9QQURESU5HLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlICsgd2lkdGgpO1xuICAgICAgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQsIFBST1BFUlRZX01BUkdJTiwgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSAtIHdpZHRoKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsICdvdmVyZmxvdycpO1xuICAgICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCBQUk9QRVJUWV9QQURESU5HKTtcbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfRklYRURfQ09OVEVOVCwgUFJPUEVSVFlfUEFERElORyk7XG4gICAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX1NUSUNLWV9DT05URU5ULCBQUk9QRVJUWV9NQVJHSU4pO1xuICAgIH1cbiAgICBpc092ZXJmbG93aW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0V2lkdGgoKSA+IDA7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZVxuICAgIF9kaXNhYmxlT3ZlckZsb3coKSB7XG4gICAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZSh0aGlzLl9lbGVtZW50LCAnb3ZlcmZsb3cnKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB9XG4gICAgX3NldEVsZW1lbnRBdHRyaWJ1dGVzKHNlbGVjdG9yLCBzdHlsZVByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICBjb25zdCBtYW5pcHVsYXRpb25DYWxsQmFjayA9IGVsZW1lbnQgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudCAhPT0gdGhpcy5fZWxlbWVudCAmJiB3aW5kb3cuaW5uZXJXaWR0aCA+IGVsZW1lbnQuY2xpZW50V2lkdGggKyBzY3JvbGxiYXJXaWR0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5KTtcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZFZhbHVlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShzdHlsZVByb3BlcnR5KTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShzdHlsZVByb3BlcnR5LCBgJHtjYWxsYmFjayhOdW1iZXIucGFyc2VGbG9hdChjYWxjdWxhdGVkVmFsdWUpKX1weGApO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2soc2VsZWN0b3IsIG1hbmlwdWxhdGlvbkNhbGxCYWNrKTtcbiAgICB9XG4gICAgX3NhdmVJbml0aWFsQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpIHtcbiAgICAgIGNvbnN0IGFjdHVhbFZhbHVlID0gZWxlbWVudC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlUHJvcGVydHkpO1xuICAgICAgaWYgKGFjdHVhbFZhbHVlKSB7XG4gICAgICAgIE1hbmlwdWxhdG9yLnNldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSwgYWN0dWFsVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBfcmVzZXRFbGVtZW50QXR0cmlidXRlcyhzZWxlY3Rvciwgc3R5bGVQcm9wZXJ0eSkge1xuICAgICAgY29uc3QgbWFuaXB1bGF0aW9uQ2FsbEJhY2sgPSBlbGVtZW50ID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpO1xuICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gcmVtb3ZlIHRoZSBwcm9wZXJ0eSBpZiB0aGUgdmFsdWUgaXMgYG51bGxgOyB0aGUgdmFsdWUgY2FuIGFsc28gYmUgemVyb1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KHN0eWxlUHJvcGVydHkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBNYW5pcHVsYXRvci5yZW1vdmVEYXRhQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHN0eWxlUHJvcGVydHksIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHNlbGVjdG9yLCBtYW5pcHVsYXRpb25DYWxsQmFjayk7XG4gICAgfVxuICAgIF9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHNlbGVjdG9yLCBjYWxsQmFjaykge1xuICAgICAgaWYgKGlzRWxlbWVudCQxKHNlbGVjdG9yKSkge1xuICAgICAgICBjYWxsQmFjayhzZWxlY3Rvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc2VsIG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IsIHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICAgIGNhbGxCYWNrKHNlbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCBtb2RhbC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkNyA9ICdtb2RhbCc7XG4gIGNvbnN0IERBVEFfS0VZJDQgPSAnYnMubW9kYWwnO1xuICBjb25zdCBFVkVOVF9LRVkkNCA9IGAuJHtEQVRBX0tFWSQ0fWA7XG4gIGNvbnN0IERBVEFfQVBJX0tFWSQyID0gJy5kYXRhLWFwaSc7XG4gIGNvbnN0IEVTQ0FQRV9LRVkkMSA9ICdFc2NhcGUnO1xuICBjb25zdCBFVkVOVF9ISURFJDQgPSBgaGlkZSR7RVZFTlRfS0VZJDR9YDtcbiAgY29uc3QgRVZFTlRfSElERV9QUkVWRU5URUQkMSA9IGBoaWRlUHJldmVudGVkJHtFVkVOVF9LRVkkNH1gO1xuICBjb25zdCBFVkVOVF9ISURERU4kNCA9IGBoaWRkZW4ke0VWRU5UX0tFWSQ0fWA7XG4gIGNvbnN0IEVWRU5UX1NIT1ckNCA9IGBzaG93JHtFVkVOVF9LRVkkNH1gO1xuICBjb25zdCBFVkVOVF9TSE9XTiQ0ID0gYHNob3duJHtFVkVOVF9LRVkkNH1gO1xuICBjb25zdCBFVkVOVF9SRVNJWkUkMSA9IGByZXNpemUke0VWRU5UX0tFWSQ0fWA7XG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RJU01JU1MgPSBgY2xpY2suZGlzbWlzcyR7RVZFTlRfS0VZJDR9YDtcbiAgY29uc3QgRVZFTlRfTU9VU0VET1dOX0RJU01JU1MgPSBgbW91c2Vkb3duLmRpc21pc3Mke0VWRU5UX0tFWSQ0fWA7XG4gIGNvbnN0IEVWRU5UX0tFWURPV05fRElTTUlTUyQxID0gYGtleWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZJDR9YDtcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMiA9IGBjbGljayR7RVZFTlRfS0VZJDR9JHtEQVRBX0FQSV9LRVkkMn1gO1xuICBjb25zdCBDTEFTU19OQU1FX09QRU4gPSAnbW9kYWwtb3Blbic7XG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQzID0gJ2ZhZGUnO1xuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckNCA9ICdzaG93JztcbiAgY29uc3QgQ0xBU1NfTkFNRV9TVEFUSUMgPSAnbW9kYWwtc3RhdGljJztcbiAgY29uc3QgT1BFTl9TRUxFQ1RPUiQxID0gJy5tb2RhbC5zaG93JztcbiAgY29uc3QgU0VMRUNUT1JfRElBTE9HID0gJy5tb2RhbC1kaWFsb2cnO1xuICBjb25zdCBTRUxFQ1RPUl9NT0RBTF9CT0RZID0gJy5tb2RhbC1ib2R5JztcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkMiA9ICdbZGF0YS1icy10b2dnbGU9XCJtb2RhbFwiXSc7XG4gIGNvbnN0IERlZmF1bHQkNiA9IHtcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBmb2N1czogdHJ1ZSxcbiAgICBrZXlib2FyZDogdHJ1ZVxuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSQ2ID0ge1xuICAgIGJhY2tkcm9wOiAnKGJvb2xlYW58c3RyaW5nKScsXG4gICAgZm9jdXM6ICdib29sZWFuJyxcbiAgICBrZXlib2FyZDogJ2Jvb2xlYW4nXG4gIH07XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgTW9kYWwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgICB0aGlzLl9kaWFsb2cgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RJQUxPRywgdGhpcy5fZWxlbWVudCk7XG4gICAgICB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpO1xuICAgICAgdGhpcy5fZm9jdXN0cmFwID0gdGhpcy5faW5pdGlhbGl6ZUZvY3VzVHJhcCgpO1xuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9zY3JvbGxCYXIgPSBuZXcgU2Nyb2xsQmFySGVscGVyKCk7XG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCQ2O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDY7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJDc7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgdG9nZ2xlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3cocmVsYXRlZFRhcmdldCk7XG4gICAgfVxuICAgIHNob3cocmVsYXRlZFRhcmdldCkge1xuICAgICAgaWYgKHRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckNCwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0XG4gICAgICB9KTtcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9pc1Nob3duID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgICB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpO1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfT1BFTik7XG4gICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcbiAgICAgIHRoaXMuX2JhY2tkcm9wLnNob3coKCkgPT4gdGhpcy5fc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCkpO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgaWYgKCF0aGlzLl9pc1Nob3duIHx8IHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDQpO1xuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgICB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ0KTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4gdGhpcy5faGlkZU1vZGFsKCksIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHdpbmRvdywgRVZFTlRfS0VZJDQpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9kaWFsb2csIEVWRU5UX0tFWSQ0KTtcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XG4gICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGhhbmRsZVVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgICAgcmV0dXJuIG5ldyBCYWNrZHJvcCh7XG4gICAgICAgIGlzVmlzaWJsZTogQm9vbGVhbih0aGlzLl9jb25maWcuYmFja2Ryb3ApLFxuICAgICAgICAvLyAnc3RhdGljJyBvcHRpb24gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRydWUsIGFuZCBib29sZWFucyB3aWxsIGtlZXAgdGhlaXIgdmFsdWUsXG4gICAgICAgIGlzQW5pbWF0ZWQ6IHRoaXMuX2lzQW5pbWF0ZWQoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xuICAgICAgcmV0dXJuIG5ldyBGb2N1c1RyYXAoe1xuICAgICAgICB0cmFwRWxlbWVudDogdGhpcy5fZWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIF9zaG93RWxlbWVudChyZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAvLyB0cnkgdG8gYXBwZW5kIGR5bmFtaWMgbW9kYWxcbiAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLl9lbGVtZW50KSkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZCh0aGlzLl9lbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSk7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgICAgIGNvbnN0IG1vZGFsQm9keSA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfTU9EQUxfQk9EWSwgdGhpcy5fZGlhbG9nKTtcbiAgICAgIGlmIChtb2RhbEJvZHkpIHtcbiAgICAgICAgbW9kYWxCb2R5LnNjcm9sbFRvcCA9IDA7XG4gICAgICB9XG4gICAgICByZWZsb3codGhpcy5fZWxlbWVudCk7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDQpO1xuICAgICAgY29uc3QgdHJhbnNpdGlvbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmZvY3VzKSB7XG4gICAgICAgICAgdGhpcy5fZm9jdXN0cmFwLmFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDQsIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2sodHJhbnNpdGlvbkNvbXBsZXRlLCB0aGlzLl9kaWFsb2csIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XG4gICAgfVxuICAgIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOX0RJU01JU1MkMSwgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSBFU0NBUEVfS0VZJDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX1JFU0laRSQxLCAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9pc1Nob3duICYmICF0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VET1dOX0RJU01JU1MsIGV2ZW50ID0+IHtcbiAgICAgICAgLy8gYSBiYWQgdHJpY2sgdG8gc2VncmVnYXRlIGNsaWNrcyB0aGF0IG1heSBzdGFydCBpbnNpZGUgZGlhbG9nIGJ1dCBlbmQgb3V0c2lkZSwgYW5kIGF2b2lkIGxpc3RlbiB0byBzY3JvbGxiYXIgY2xpY2tzXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgRVZFTlRfQ0xJQ0tfRElTTUlTUywgZXZlbnQyID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCAhPT0gZXZlbnQudGFyZ2V0IHx8IHRoaXMuX2VsZW1lbnQgIT09IGV2ZW50Mi50YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfaGlkZU1vZGFsKCkge1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fYmFja2Ryb3AuaGlkZSgoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX09QRU4pO1xuICAgICAgICB0aGlzLl9yZXNldEFkanVzdG1lbnRzKCk7XG4gICAgICAgIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpO1xuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kNCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgX2lzQW5pbWF0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDMpO1xuICAgIH1cbiAgICBfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpIHtcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREVfUFJFVkVOVEVEJDEpO1xuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzTW9kYWxPdmVyZmxvd2luZyA9IHRoaXMuX2VsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgIGNvbnN0IGluaXRpYWxPdmVyZmxvd1kgPSB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WTtcbiAgICAgIC8vIHJldHVybiBpZiB0aGUgZm9sbG93aW5nIGJhY2tncm91bmQgdHJhbnNpdGlvbiBoYXNuJ3QgeWV0IGNvbXBsZXRlZFxuICAgICAgaWYgKGluaXRpYWxPdmVyZmxvd1kgPT09ICdoaWRkZW4nIHx8IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU1RBVElDKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9ICdoaWRkZW4nO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU1RBVElDKTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TVEFUSUMpO1xuICAgICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9IGluaXRpYWxPdmVyZmxvd1k7XG4gICAgICAgIH0sIHRoaXMuX2RpYWxvZyk7XG4gICAgICB9LCB0aGlzLl9kaWFsb2cpO1xuICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCB0byBoYW5kbGUgb3ZlcmZsb3dpbmcgbW9kYWxzXG4gICAgICovXG5cbiAgICBfYWRqdXN0RGlhbG9nKCkge1xuICAgICAgY29uc3QgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB0aGlzLl9zY3JvbGxCYXIuZ2V0V2lkdGgoKTtcbiAgICAgIGNvbnN0IGlzQm9keU92ZXJmbG93aW5nID0gc2Nyb2xsYmFyV2lkdGggPiAwO1xuICAgICAgaWYgKGlzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBpc1JUTCgpID8gJ3BhZGRpbmdMZWZ0JyA6ICdwYWRkaW5nUmlnaHQnO1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW3Byb3BlcnR5XSA9IGAke3Njcm9sbGJhcldpZHRofXB4YDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNCb2R5T3ZlcmZsb3dpbmcgJiYgaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5ID0gaXNSVEwoKSA/ICdwYWRkaW5nUmlnaHQnIDogJ3BhZGRpbmdMZWZ0JztcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSBgJHtzY3JvbGxiYXJXaWR0aH1weGA7XG4gICAgICB9XG4gICAgfVxuICAgIF9yZXNldEFkanVzdG1lbnRzKCkge1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9ICcnO1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJztcbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZywgcmVsYXRlZFRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBNb2RhbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXShyZWxhdGVkVGFyZ2V0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICAgKi9cblxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDIsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGNvbnN0IHRhcmdldCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcyk7XG4gICAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX1NIT1ckNCwgc2hvd0V2ZW50ID0+IHtcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAvLyBvbmx5IHJlZ2lzdGVyIGZvY3VzIHJlc3RvcmVyIGlmIG1vZGFsIHdpbGwgYWN0dWFsbHkgZ2V0IHNob3duXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9ISURERU4kNCwgKCkgPT4ge1xuICAgICAgICBpZiAoaXNWaXNpYmxlKHRoaXMpKSB7XG4gICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIGF2b2lkIGNvbmZsaWN0IHdoZW4gY2xpY2tpbmcgbW9kYWwgdG9nZ2xlciB3aGlsZSBhbm90aGVyIG9uZSBpcyBvcGVuXG4gICAgY29uc3QgYWxyZWFkeU9wZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKE9QRU5fU0VMRUNUT1IkMSk7XG4gICAgaWYgKGFscmVhZHlPcGVuKSB7XG4gICAgICBNb2RhbC5nZXRJbnN0YW5jZShhbHJlYWR5T3BlbikuaGlkZSgpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gTW9kYWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpO1xuICAgIGRhdGEudG9nZ2xlKHRoaXMpO1xuICB9KTtcbiAgZW5hYmxlRGlzbWlzc1RyaWdnZXIoTW9kYWwpO1xuXG4gIC8qKlxuICAgKiBqUXVlcnlcbiAgICovXG5cbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKE1vZGFsKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIG9mZmNhbnZhcy5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkNiA9ICdvZmZjYW52YXMnO1xuICBjb25zdCBEQVRBX0tFWSQzID0gJ2JzLm9mZmNhbnZhcyc7XG4gIGNvbnN0IEVWRU5UX0tFWSQzID0gYC4ke0RBVEFfS0VZJDN9YDtcbiAgY29uc3QgREFUQV9BUElfS0VZJDEgPSAnLmRhdGEtYXBpJztcbiAgY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSQyID0gYGxvYWQke0VWRU5UX0tFWSQzfSR7REFUQV9BUElfS0VZJDF9YDtcbiAgY29uc3QgRVNDQVBFX0tFWSA9ICdFc2NhcGUnO1xuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckMyA9ICdzaG93JztcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XSU5HJDEgPSAnc2hvd2luZyc7XG4gIGNvbnN0IENMQVNTX05BTUVfSElESU5HID0gJ2hpZGluZyc7XG4gIGNvbnN0IENMQVNTX05BTUVfQkFDS0RST1AgPSAnb2ZmY2FudmFzLWJhY2tkcm9wJztcbiAgY29uc3QgT1BFTl9TRUxFQ1RPUiA9ICcub2ZmY2FudmFzLnNob3cnO1xuICBjb25zdCBFVkVOVF9TSE9XJDMgPSBgc2hvdyR7RVZFTlRfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfU0hPV04kMyA9IGBzaG93biR7RVZFTlRfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfSElERSQzID0gYGhpZGUke0VWRU5UX0tFWSQzfWA7XG4gIGNvbnN0IEVWRU5UX0hJREVfUFJFVkVOVEVEID0gYGhpZGVQcmV2ZW50ZWQke0VWRU5UX0tFWSQzfWA7XG4gIGNvbnN0IEVWRU5UX0hJRERFTiQzID0gYGhpZGRlbiR7RVZFTlRfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfUkVTSVpFID0gYHJlc2l6ZSR7RVZFTlRfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMSA9IGBjbGljayR7RVZFTlRfS0VZJDN9JHtEQVRBX0FQSV9LRVkkMX1gO1xuICBjb25zdCBFVkVOVF9LRVlET1dOX0RJU01JU1MgPSBga2V5ZG93bi5kaXNtaXNzJHtFVkVOVF9LRVkkM31gO1xuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxID0gJ1tkYXRhLWJzLXRvZ2dsZT1cIm9mZmNhbnZhc1wiXSc7XG4gIGNvbnN0IERlZmF1bHQkNSA9IHtcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICBzY3JvbGw6IGZhbHNlXG4gIH07XG4gIGNvbnN0IERlZmF1bHRUeXBlJDUgPSB7XG4gICAgYmFja2Ryb3A6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAgICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxuICAgIHNjcm9sbDogJ2Jvb2xlYW4nXG4gIH07XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgT2ZmY2FudmFzIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgICAgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKTtcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcCA9IHRoaXMuX2luaXRpYWxpemVGb2N1c1RyYXAoKTtcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0JDU7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkNTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkNjtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICB0b2dnbGUocmVsYXRlZFRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcbiAgICB9XG4gICAgc2hvdyhyZWxhdGVkVGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDMsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldFxuICAgICAgfSk7XG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XG4gICAgICB0aGlzLl9iYWNrZHJvcC5zaG93KCk7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwpIHtcbiAgICAgICAgbmV3IFNjcm9sbEJhckhlbHBlcigpLmhpZGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSk7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1dJTkckMSk7XG4gICAgICBjb25zdCBjb21wbGV0ZUNhbGxCYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgdGhpcy5fY29uZmlnLmJhY2tkcm9wKSB7XG4gICAgICAgICAgdGhpcy5fZm9jdXN0cmFwLmFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQzKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORyQxKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04kMywge1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZUNhbGxCYWNrLCB0aGlzLl9lbGVtZW50LCB0cnVlKTtcbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgIGlmICghdGhpcy5faXNTaG93bikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDMpO1xuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XG4gICAgICB0aGlzLl9lbGVtZW50LmJsdXIoKTtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0hJRElORyk7XG4gICAgICB0aGlzLl9iYWNrZHJvcC5oaWRlKCk7XG4gICAgICBjb25zdCBjb21wbGV0ZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDMsIENMQVNTX05BTUVfSElESU5HKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWcuc2Nyb2xsKSB7XG4gICAgICAgICAgbmV3IFNjcm9sbEJhckhlbHBlcigpLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDMpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsYmFjaywgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpO1xuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgICAgY29uc3QgY2xpY2tDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfTtcblxuICAgICAgLy8gJ3N0YXRpYycgb3B0aW9uIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0cnVlLCBhbmQgYm9vbGVhbnMgd2lsbCBrZWVwIHRoZWlyIHZhbHVlXG4gICAgICBjb25zdCBpc1Zpc2libGUgPSBCb29sZWFuKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCk7XG4gICAgICByZXR1cm4gbmV3IEJhY2tkcm9wKHtcbiAgICAgICAgY2xhc3NOYW1lOiBDTEFTU19OQU1FX0JBQ0tEUk9QLFxuICAgICAgICBpc1Zpc2libGUsXG4gICAgICAgIGlzQW5pbWF0ZWQ6IHRydWUsXG4gICAgICAgIHJvb3RFbGVtZW50OiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICAgIGNsaWNrQ2FsbGJhY2s6IGlzVmlzaWJsZSA/IGNsaWNrQ2FsbGJhY2sgOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgX2luaXRpYWxpemVGb2N1c1RyYXAoKSB7XG4gICAgICByZXR1cm4gbmV3IEZvY3VzVHJhcCh7XG4gICAgICAgIHRyYXBFbGVtZW50OiB0aGlzLl9lbGVtZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUywgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSBFU0NBUEVfS0VZKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcbiAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERV9QUkVWRU5URUQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU3RhdGljXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gICAqL1xuXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMSwgU0VMRUNUT1JfREFUQV9UT0dHTEUkMSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcbiAgICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBFdmVudEhhbmRsZXIub25lKHRhcmdldCwgRVZFTlRfSElEREVOJDMsICgpID0+IHtcbiAgICAgIC8vIGZvY3VzIG9uIHRyaWdnZXIgd2hlbiBpdCBpcyBjbG9zZWRcbiAgICAgIGlmIChpc1Zpc2libGUodGhpcykpIHtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gYXZvaWQgY29uZmxpY3Qgd2hlbiBjbGlja2luZyBhIHRvZ2dsZXIgb2YgYW4gb2ZmY2FudmFzLCB3aGlsZSBhbm90aGVyIGlzIG9wZW5cbiAgICBjb25zdCBhbHJlYWR5T3BlbiA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoT1BFTl9TRUxFQ1RPUik7XG4gICAgaWYgKGFscmVhZHlPcGVuICYmIGFscmVhZHlPcGVuICE9PSB0YXJnZXQpIHtcbiAgICAgIE9mZmNhbnZhcy5nZXRJbnN0YW5jZShhbHJlYWR5T3BlbikuaGlkZSgpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KTtcbiAgICBkYXRhLnRvZ2dsZSh0aGlzKTtcbiAgfSk7XG4gIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEkkMiwgKCkgPT4ge1xuICAgIGZvciAoY29uc3Qgc2VsZWN0b3Igb2YgU2VsZWN0b3JFbmdpbmUuZmluZChPUEVOX1NFTEVDVE9SKSkge1xuICAgICAgT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2Uoc2VsZWN0b3IpLnNob3coKTtcbiAgICB9XG4gIH0pO1xuICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9SRVNJWkUsICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgU2VsZWN0b3JFbmdpbmUuZmluZCgnW2FyaWEtbW9kYWxdW2NsYXNzKj1zaG93XVtjbGFzcyo9b2ZmY2FudmFzLV0nKSkge1xuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gIT09ICdmaXhlZCcpIHtcbiAgICAgICAgT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCkuaGlkZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGVuYWJsZURpc21pc3NUcmlnZ2VyKE9mZmNhbnZhcyk7XG5cbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oT2ZmY2FudmFzKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIHV0aWwvc2FuaXRpemVyLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAvLyBqcy1kb2NzLXN0YXJ0IGFsbG93LWxpc3RcbiAgY29uc3QgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTiA9IC9eYXJpYS1bXFx3LV0qJC9pO1xuICBjb25zdCBEZWZhdWx0QWxsb3dsaXN0ID0ge1xuICAgIC8vIEdsb2JhbCBhdHRyaWJ1dGVzIGFsbG93ZWQgb24gYW55IHN1cHBsaWVkIGVsZW1lbnQgYmVsb3cuXG4gICAgJyonOiBbJ2NsYXNzJywgJ2RpcicsICdpZCcsICdsYW5nJywgJ3JvbGUnLCBBUklBX0FUVFJJQlVURV9QQVRURVJOXSxcbiAgICBhOiBbJ3RhcmdldCcsICdocmVmJywgJ3RpdGxlJywgJ3JlbCddLFxuICAgIGFyZWE6IFtdLFxuICAgIGI6IFtdLFxuICAgIGJyOiBbXSxcbiAgICBjb2w6IFtdLFxuICAgIGNvZGU6IFtdLFxuICAgIGRkOiBbXSxcbiAgICBkaXY6IFtdLFxuICAgIGRsOiBbXSxcbiAgICBkdDogW10sXG4gICAgZW06IFtdLFxuICAgIGhyOiBbXSxcbiAgICBoMTogW10sXG4gICAgaDI6IFtdLFxuICAgIGgzOiBbXSxcbiAgICBoNDogW10sXG4gICAgaDU6IFtdLFxuICAgIGg2OiBbXSxcbiAgICBpOiBbXSxcbiAgICBpbWc6IFsnc3JjJywgJ3NyY3NldCcsICdhbHQnLCAndGl0bGUnLCAnd2lkdGgnLCAnaGVpZ2h0J10sXG4gICAgbGk6IFtdLFxuICAgIG9sOiBbXSxcbiAgICBwOiBbXSxcbiAgICBwcmU6IFtdLFxuICAgIHM6IFtdLFxuICAgIHNtYWxsOiBbXSxcbiAgICBzcGFuOiBbXSxcbiAgICBzdWI6IFtdLFxuICAgIHN1cDogW10sXG4gICAgc3Ryb25nOiBbXSxcbiAgICB1OiBbXSxcbiAgICB1bDogW11cbiAgfTtcbiAgLy8ganMtZG9jcy1lbmQgYWxsb3ctbGlzdFxuXG4gIGNvbnN0IHVyaUF0dHJpYnV0ZXMgPSBuZXcgU2V0KFsnYmFja2dyb3VuZCcsICdjaXRlJywgJ2hyZWYnLCAnaXRlbXR5cGUnLCAnbG9uZ2Rlc2MnLCAncG9zdGVyJywgJ3NyYycsICd4bGluazpocmVmJ10pO1xuXG4gIC8qKlxuICAgKiBBIHBhdHRlcm4gdGhhdCByZWNvZ25pemVzIFVSTHMgdGhhdCBhcmUgc2FmZSB3cnQuIFhTUyBpbiBVUkwgbmF2aWdhdGlvblxuICAgKiBjb250ZXh0cy5cbiAgICpcbiAgICogU2hvdXQtb3V0IHRvIEFuZ3VsYXIgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzE1LjIuOC9wYWNrYWdlcy9jb3JlL3NyYy9zYW5pdGl6YXRpb24vdXJsX3Nhbml0aXplci50cyNMMzhcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL2JldHRlci1yZWdleFxuICBjb25zdCBTQUZFX1VSTF9QQVRURVJOID0gL14oPyFqYXZhc2NyaXB0OikoPzpbYS16MC05Ky4tXSs6fFteJjovPyNdKig/OlsvPyNdfCQpKS9pO1xuICBjb25zdCBhbGxvd2VkQXR0cmlidXRlID0gKGF0dHJpYnV0ZSwgYWxsb3dlZEF0dHJpYnV0ZUxpc3QpID0+IHtcbiAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmluY2x1ZGVzKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICBpZiAodXJpQXR0cmlidXRlcy5oYXMoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oU0FGRV9VUkxfUEFUVEVSTi50ZXN0KGF0dHJpYnV0ZS5ub2RlVmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGEgcmVndWxhciBleHByZXNzaW9uIHZhbGlkYXRlcyB0aGUgYXR0cmlidXRlLlxuICAgIHJldHVybiBhbGxvd2VkQXR0cmlidXRlTGlzdC5maWx0ZXIoYXR0cmlidXRlUmVnZXggPT4gYXR0cmlidXRlUmVnZXggaW5zdGFuY2VvZiBSZWdFeHApLnNvbWUocmVnZXggPT4gcmVnZXgudGVzdChhdHRyaWJ1dGVOYW1lKSk7XG4gIH07XG4gIGZ1bmN0aW9uIHNhbml0aXplSHRtbCh1bnNhZmVIdG1sLCBhbGxvd0xpc3QsIHNhbml0aXplRnVuY3Rpb24pIHtcbiAgICBpZiAoIXVuc2FmZUh0bWwubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdW5zYWZlSHRtbDtcbiAgICB9XG4gICAgaWYgKHNhbml0aXplRnVuY3Rpb24gJiYgdHlwZW9mIHNhbml0aXplRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBzYW5pdGl6ZUZ1bmN0aW9uKHVuc2FmZUh0bWwpO1xuICAgIH1cbiAgICBjb25zdCBkb21QYXJzZXIgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpO1xuICAgIGNvbnN0IGNyZWF0ZWREb2N1bWVudCA9IGRvbVBhcnNlci5wYXJzZUZyb21TdHJpbmcodW5zYWZlSHRtbCwgJ3RleHQvaHRtbCcpO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW10uY29uY2F0KC4uLmNyZWF0ZWREb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSk7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICBjb25zdCBlbGVtZW50TmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghT2JqZWN0LmtleXMoYWxsb3dMaXN0KS5pbmNsdWRlcyhlbGVtZW50TmFtZSkpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBhdHRyaWJ1dGVMaXN0ID0gW10uY29uY2F0KC4uLmVsZW1lbnQuYXR0cmlidXRlcyk7XG4gICAgICBjb25zdCBhbGxvd2VkQXR0cmlidXRlcyA9IFtdLmNvbmNhdChhbGxvd0xpc3RbJyonXSB8fCBbXSwgYWxsb3dMaXN0W2VsZW1lbnROYW1lXSB8fCBbXSk7XG4gICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVMaXN0KSB7XG4gICAgICAgIGlmICghYWxsb3dlZEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGFsbG93ZWRBdHRyaWJ1dGVzKSkge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZS5ub2RlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZWREb2N1bWVudC5ib2R5LmlubmVySFRNTDtcbiAgfVxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgdXRpbC90ZW1wbGF0ZS1mYWN0b3J5LmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgTkFNRSQ1ID0gJ1RlbXBsYXRlRmFjdG9yeSc7XG4gIGNvbnN0IERlZmF1bHQkNCA9IHtcbiAgICBhbGxvd0xpc3Q6IERlZmF1bHRBbGxvd2xpc3QsXG4gICAgY29udGVudDoge30sXG4gICAgLy8geyBzZWxlY3RvciA6IHRleHQgLCAgc2VsZWN0b3IyIDogdGV4dDIgLCB9XG4gICAgZXh0cmFDbGFzczogJycsXG4gICAgaHRtbDogZmFsc2UsXG4gICAgc2FuaXRpemU6IHRydWUsXG4gICAgc2FuaXRpemVGbjogbnVsbCxcbiAgICB0ZW1wbGF0ZTogJzxkaXY+PC9kaXY+J1xuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSQ0ID0ge1xuICAgIGFsbG93TGlzdDogJ29iamVjdCcsXG4gICAgY29udGVudDogJ29iamVjdCcsXG4gICAgZXh0cmFDbGFzczogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgICBodG1sOiAnYm9vbGVhbicsXG4gICAgc2FuaXRpemU6ICdib29sZWFuJyxcbiAgICBzYW5pdGl6ZUZuOiAnKG51bGx8ZnVuY3Rpb24pJyxcbiAgICB0ZW1wbGF0ZTogJ3N0cmluZydcbiAgfTtcbiAgY29uc3QgRGVmYXVsdENvbnRlbnRUeXBlID0ge1xuICAgIGVudHJ5OiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9ufG51bGwpJyxcbiAgICBzZWxlY3RvcjogJyhzdHJpbmd8ZWxlbWVudCknXG4gIH07XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgVGVtcGxhdGVGYWN0b3J5IGV4dGVuZHMgQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHQkNDtcbiAgICB9XG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ0O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gTkFNRSQ1O1xuICAgIH1cblxuICAgIC8vIFB1YmxpY1xuICAgIGdldENvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9jb25maWcuY29udGVudCkubWFwKGNvbmZpZyA9PiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihjb25maWcpKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfVxuICAgIGhhc0NvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDb250ZW50KCkubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgY2hhbmdlQ29udGVudChjb250ZW50KSB7XG4gICAgICB0aGlzLl9jaGVja0NvbnRlbnQoY29udGVudCk7XG4gICAgICB0aGlzLl9jb25maWcuY29udGVudCA9IHtcbiAgICAgICAgLi4udGhpcy5fY29uZmlnLmNvbnRlbnQsXG4gICAgICAgIC4uLmNvbnRlbnRcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9IdG1sKCkge1xuICAgICAgY29uc3QgdGVtcGxhdGVXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0ZW1wbGF0ZVdyYXBwZXIuaW5uZXJIVE1MID0gdGhpcy5fbWF5YmVTYW5pdGl6ZSh0aGlzLl9jb25maWcudGVtcGxhdGUpO1xuICAgICAgZm9yIChjb25zdCBbc2VsZWN0b3IsIHRleHRdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuX2NvbmZpZy5jb250ZW50KSkge1xuICAgICAgICB0aGlzLl9zZXRDb250ZW50KHRlbXBsYXRlV3JhcHBlciwgdGV4dCwgc2VsZWN0b3IpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZVdyYXBwZXIuY2hpbGRyZW5bMF07XG4gICAgICBjb25zdCBleHRyYUNsYXNzID0gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLmV4dHJhQ2xhc3MpO1xuICAgICAgaWYgKGV4dHJhQ2xhc3MpIHtcbiAgICAgICAgdGVtcGxhdGUuY2xhc3NMaXN0LmFkZCguLi5leHRyYUNsYXNzLnNwbGl0KCcgJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfdHlwZUNoZWNrQ29uZmlnKGNvbmZpZykge1xuICAgICAgc3VwZXIuX3R5cGVDaGVja0NvbmZpZyhjb25maWcpO1xuICAgICAgdGhpcy5fY2hlY2tDb250ZW50KGNvbmZpZy5jb250ZW50KTtcbiAgICB9XG4gICAgX2NoZWNrQ29udGVudChhcmcpIHtcbiAgICAgIGZvciAoY29uc3QgW3NlbGVjdG9yLCBjb250ZW50XSBvZiBPYmplY3QuZW50cmllcyhhcmcpKSB7XG4gICAgICAgIHN1cGVyLl90eXBlQ2hlY2tDb25maWcoe1xuICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgIGVudHJ5OiBjb250ZW50XG4gICAgICAgIH0sIERlZmF1bHRDb250ZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9zZXRDb250ZW50KHRlbXBsYXRlLCBjb250ZW50LCBzZWxlY3Rvcikge1xuICAgICAgY29uc3QgdGVtcGxhdGVFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShzZWxlY3RvciwgdGVtcGxhdGUpO1xuICAgICAgaWYgKCF0ZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29udGVudCA9IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGNvbnRlbnQpO1xuICAgICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgIHRlbXBsYXRlRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzRWxlbWVudCQxKGNvbnRlbnQpKSB7XG4gICAgICAgIHRoaXMuX3B1dEVsZW1lbnRJblRlbXBsYXRlKGdldEVsZW1lbnQoY29udGVudCksIHRlbXBsYXRlRWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jb25maWcuaHRtbCkge1xuICAgICAgICB0ZW1wbGF0ZUVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5fbWF5YmVTYW5pdGl6ZShjb250ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGVtcGxhdGVFbGVtZW50LnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICB9XG4gICAgX21heWJlU2FuaXRpemUoYXJnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29uZmlnLnNhbml0aXplID8gc2FuaXRpemVIdG1sKGFyZywgdGhpcy5fY29uZmlnLmFsbG93TGlzdCwgdGhpcy5fY29uZmlnLnNhbml0aXplRm4pIDogYXJnO1xuICAgIH1cbiAgICBfcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZShhcmcsIFt0aGlzXSk7XG4gICAgfVxuICAgIF9wdXRFbGVtZW50SW5UZW1wbGF0ZShlbGVtZW50LCB0ZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLl9jb25maWcuaHRtbCkge1xuICAgICAgICB0ZW1wbGF0ZUVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHRlbXBsYXRlRWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlRWxlbWVudC50ZXh0Q29udGVudCA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCB0b29sdGlwLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgTkFNRSQ0ID0gJ3Rvb2x0aXAnO1xuICBjb25zdCBESVNBTExPV0VEX0FUVFJJQlVURVMgPSBuZXcgU2V0KFsnc2FuaXRpemUnLCAnYWxsb3dMaXN0JywgJ3Nhbml0aXplRm4nXSk7XG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQyID0gJ2ZhZGUnO1xuICBjb25zdCBDTEFTU19OQU1FX01PREFMID0gJ21vZGFsJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDIgPSAnc2hvdyc7XG4gIGNvbnN0IFNFTEVDVE9SX1RPT0xUSVBfSU5ORVIgPSAnLnRvb2x0aXAtaW5uZXInO1xuICBjb25zdCBTRUxFQ1RPUl9NT0RBTCA9IGAuJHtDTEFTU19OQU1FX01PREFMfWA7XG4gIGNvbnN0IEVWRU5UX01PREFMX0hJREUgPSAnaGlkZS5icy5tb2RhbCc7XG4gIGNvbnN0IFRSSUdHRVJfSE9WRVIgPSAnaG92ZXInO1xuICBjb25zdCBUUklHR0VSX0ZPQ1VTID0gJ2ZvY3VzJztcbiAgY29uc3QgVFJJR0dFUl9DTElDSyA9ICdjbGljayc7XG4gIGNvbnN0IFRSSUdHRVJfTUFOVUFMID0gJ21hbnVhbCc7XG4gIGNvbnN0IEVWRU5UX0hJREUkMiA9ICdoaWRlJztcbiAgY29uc3QgRVZFTlRfSElEREVOJDIgPSAnaGlkZGVuJztcbiAgY29uc3QgRVZFTlRfU0hPVyQyID0gJ3Nob3cnO1xuICBjb25zdCBFVkVOVF9TSE9XTiQyID0gJ3Nob3duJztcbiAgY29uc3QgRVZFTlRfSU5TRVJURUQgPSAnaW5zZXJ0ZWQnO1xuICBjb25zdCBFVkVOVF9DTElDSyQxID0gJ2NsaWNrJztcbiAgY29uc3QgRVZFTlRfRk9DVVNJTiQxID0gJ2ZvY3VzaW4nO1xuICBjb25zdCBFVkVOVF9GT0NVU09VVCQxID0gJ2ZvY3Vzb3V0JztcbiAgY29uc3QgRVZFTlRfTU9VU0VFTlRFUiA9ICdtb3VzZWVudGVyJztcbiAgY29uc3QgRVZFTlRfTU9VU0VMRUFWRSA9ICdtb3VzZWxlYXZlJztcbiAgY29uc3QgQXR0YWNobWVudE1hcCA9IHtcbiAgICBBVVRPOiAnYXV0bycsXG4gICAgVE9QOiAndG9wJyxcbiAgICBSSUdIVDogaXNSVEwoKSA/ICdsZWZ0JyA6ICdyaWdodCcsXG4gICAgQk9UVE9NOiAnYm90dG9tJyxcbiAgICBMRUZUOiBpc1JUTCgpID8gJ3JpZ2h0JyA6ICdsZWZ0J1xuICB9O1xuICBjb25zdCBEZWZhdWx0JDMgPSB7XG4gICAgYWxsb3dMaXN0OiBEZWZhdWx0QWxsb3dsaXN0LFxuICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICBib3VuZGFyeTogJ2NsaXBwaW5nUGFyZW50cycsXG4gICAgY29udGFpbmVyOiBmYWxzZSxcbiAgICBjdXN0b21DbGFzczogJycsXG4gICAgZGVsYXk6IDAsXG4gICAgZmFsbGJhY2tQbGFjZW1lbnRzOiBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLFxuICAgIGh0bWw6IGZhbHNlLFxuICAgIG9mZnNldDogWzAsIDZdLFxuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgcG9wcGVyQ29uZmlnOiBudWxsLFxuICAgIHNhbml0aXplOiB0cnVlLFxuICAgIHNhbml0aXplRm46IG51bGwsXG4gICAgc2VsZWN0b3I6IGZhbHNlLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPicgKyAnPGRpdiBjbGFzcz1cInRvb2x0aXAtYXJyb3dcIj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJ0b29sdGlwLWlubmVyXCI+PC9kaXY+JyArICc8L2Rpdj4nLFxuICAgIHRpdGxlOiAnJyxcbiAgICB0cmlnZ2VyOiAnaG92ZXIgZm9jdXMnXG4gIH07XG4gIGNvbnN0IERlZmF1bHRUeXBlJDMgPSB7XG4gICAgYWxsb3dMaXN0OiAnb2JqZWN0JyxcbiAgICBhbmltYXRpb246ICdib29sZWFuJyxcbiAgICBib3VuZGFyeTogJyhzdHJpbmd8ZWxlbWVudCknLFxuICAgIGNvbnRhaW5lcjogJyhzdHJpbmd8ZWxlbWVudHxib29sZWFuKScsXG4gICAgY3VzdG9tQ2xhc3M6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXG4gICAgZGVsYXk6ICcobnVtYmVyfG9iamVjdCknLFxuICAgIGZhbGxiYWNrUGxhY2VtZW50czogJ2FycmF5JyxcbiAgICBodG1sOiAnYm9vbGVhbicsXG4gICAgb2Zmc2V0OiAnKGFycmF5fHN0cmluZ3xmdW5jdGlvbiknLFxuICAgIHBsYWNlbWVudDogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3R8ZnVuY3Rpb24pJyxcbiAgICBzYW5pdGl6ZTogJ2Jvb2xlYW4nLFxuICAgIHNhbml0aXplRm46ICcobnVsbHxmdW5jdGlvbiknLFxuICAgIHNlbGVjdG9yOiAnKHN0cmluZ3xib29sZWFuKScsXG4gICAgdGVtcGxhdGU6ICdzdHJpbmcnLFxuICAgIHRpdGxlOiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKScsXG4gICAgdHJpZ2dlcjogJ3N0cmluZydcbiAgfTtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBUb29sdGlwIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyB0b29sdGlwcyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKScpO1xuICAgICAgfVxuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcblxuICAgICAgLy8gUHJpdmF0ZVxuICAgICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSAwO1xuICAgICAgdGhpcy5faXNIb3ZlcmVkID0gbnVsbDtcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXIgPSB7fTtcbiAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XG4gICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkgPSBudWxsO1xuICAgICAgdGhpcy5fbmV3Q29udGVudCA9IG51bGw7XG5cbiAgICAgIC8vIFByb3RlY3RlZFxuICAgICAgdGhpcy50aXAgPSBudWxsO1xuICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zZWxlY3Rvcikge1xuICAgICAgICB0aGlzLl9maXhUaXRsZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCQzO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDM7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJDQ7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgZW5hYmxlKCkge1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZGlzYWJsZSgpIHtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICB0b2dnbGVFbmFibGVkKCkge1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZDtcbiAgICB9XG4gICAgdG9nZ2xlKCkge1xuICAgICAgaWYgKCF0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICF0aGlzLl9hY3RpdmVUcmlnZ2VyLmNsaWNrO1xuICAgICAgaWYgKHRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgICB0aGlzLl9sZWF2ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9lbnRlcigpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LmNsb3Nlc3QoU0VMRUNUT1JfTU9EQUwpLCBFVkVOVF9NT0RBTF9ISURFLCB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyKTtcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1vcmlnaW5hbC10aXRsZScpKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCd0aXRsZScsIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJykpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBzaG93KCkge1xuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHVzZSBzaG93IG9uIHZpc2libGUgZWxlbWVudHMnKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHRoaXMuX2lzV2l0aENvbnRlbnQoKSAmJiB0aGlzLl9pc0VuYWJsZWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX1NIT1ckMikpO1xuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGZpbmRTaGFkb3dSb290KHRoaXMuX2VsZW1lbnQpO1xuICAgICAgY29uc3QgaXNJblRoZURvbSA9IChzaGFkb3dSb290IHx8IHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpO1xuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFpc0luVGhlRG9tKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogdjYgcmVtb3ZlIHRoaXMgb3IgbWFrZSBpdCBvcHRpb25hbFxuICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xuICAgICAgY29uc3QgdGlwID0gdGhpcy5fZ2V0VGlwRWxlbWVudCgpO1xuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aXAuZ2V0QXR0cmlidXRlKCdpZCcpKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udGFpbmVyXG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xuICAgICAgaWYgKCF0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMudGlwKSkge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kKHRpcCk7XG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0lOU0VSVEVEKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wb3BwZXIgPSB0aGlzLl9jcmVhdGVQb3BwZXIodGlwKTtcbiAgICAgIHRpcC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQyKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB0byB0aGUgYm9keSdzIGltbWVkaWF0ZSBjaGlsZHJlbjtcbiAgICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXG4gICAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xuICAgICAgICAgIEV2ZW50SGFuZGxlci5vbihlbGVtZW50LCAnbW91c2VvdmVyJywgbm9vcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9TSE9XTiQyKSk7XG4gICAgICAgIGlmICh0aGlzLl9pc0hvdmVyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5fbGVhdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0hvdmVyZWQgPSBmYWxzZTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLnRpcCwgdGhpcy5faXNBbmltYXRlZCgpKTtcbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgIGlmICghdGhpcy5faXNTaG93bigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0hJREUkMikpO1xuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRpcCA9IHRoaXMuX2dldFRpcEVsZW1lbnQoKTtcbiAgICAgIHRpcC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQyKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcbiAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XG4gICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcbiAgICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0NMSUNLXSA9IGZhbHNlO1xuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0ZPQ1VTXSA9IGZhbHNlO1xuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0hPVkVSXSA9IGZhbHNlO1xuICAgICAgdGhpcy5faXNIb3ZlcmVkID0gbnVsbDsgLy8gaXQgaXMgYSB0cmljayB0byBzdXBwb3J0IG1hbnVhbCB0cmlnZ2VyaW5nXG5cbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faXNIb3ZlcmVkKSB7XG4gICAgICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jyk7XG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0hJRERFTiQyKSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy50aXAsIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb3RlY3RlZFxuICAgIF9pc1dpdGhDb250ZW50KCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fZ2V0VGl0bGUoKSk7XG4gICAgfVxuICAgIF9nZXRUaXBFbGVtZW50KCkge1xuICAgICAgaWYgKCF0aGlzLnRpcCkge1xuICAgICAgICB0aGlzLnRpcCA9IHRoaXMuX2NyZWF0ZVRpcEVsZW1lbnQodGhpcy5fbmV3Q29udGVudCB8fCB0aGlzLl9nZXRDb250ZW50Rm9yVGVtcGxhdGUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aXA7XG4gICAgfVxuICAgIF9jcmVhdGVUaXBFbGVtZW50KGNvbnRlbnQpIHtcbiAgICAgIGNvbnN0IHRpcCA9IHRoaXMuX2dldFRlbXBsYXRlRmFjdG9yeShjb250ZW50KS50b0h0bWwoKTtcblxuICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgY2hlY2sgaW4gdjZcbiAgICAgIGlmICghdGlwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdGlwLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9GQURFJDIsIENMQVNTX05BTUVfU0hPVyQyKTtcbiAgICAgIC8vIFRPRE86IHY2IHRoZSBmb2xsb3dpbmcgY2FuIGJlIGFjaGlldmVkIHdpdGggQ1NTIG9ubHlcbiAgICAgIHRpcC5jbGFzc0xpc3QuYWRkKGBicy0ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXV0b2ApO1xuICAgICAgY29uc3QgdGlwSWQgPSBnZXRVSUQodGhpcy5jb25zdHJ1Y3Rvci5OQU1FKS50b1N0cmluZygpO1xuICAgICAgdGlwLnNldEF0dHJpYnV0ZSgnaWQnLCB0aXBJZCk7XG4gICAgICBpZiAodGhpcy5faXNBbmltYXRlZCgpKSB7XG4gICAgICAgIHRpcC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSQyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aXA7XG4gICAgfVxuICAgIHNldENvbnRlbnQoY29udGVudCkge1xuICAgICAgdGhpcy5fbmV3Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICBpZiAodGhpcy5faXNTaG93bigpKSB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKTtcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICB9XG4gICAgfVxuICAgIF9nZXRUZW1wbGF0ZUZhY3RvcnkoY29udGVudCkge1xuICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlRmFjdG9yeSkge1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkuY2hhbmdlQ29udGVudChjb250ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlRmFjdG9yeSA9IG5ldyBUZW1wbGF0ZUZhY3Rvcnkoe1xuICAgICAgICAgIC4uLnRoaXMuX2NvbmZpZyxcbiAgICAgICAgICAvLyB0aGUgYGNvbnRlbnRgIHZhciBoYXMgdG8gYmUgYWZ0ZXIgYHRoaXMuX2NvbmZpZ2BcbiAgICAgICAgICAvLyB0byBvdmVycmlkZSBjb25maWcuY29udGVudCBpbiBjYXNlIG9mIHBvcG92ZXJcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIGV4dHJhQ2xhc3M6IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jdXN0b21DbGFzcylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVGYWN0b3J5O1xuICAgIH1cbiAgICBfZ2V0Q29udGVudEZvclRlbXBsYXRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW1NFTEVDVE9SX1RPT0xUSVBfSU5ORVJdOiB0aGlzLl9nZXRUaXRsZSgpXG4gICAgICB9O1xuICAgIH1cbiAgICBfZ2V0VGl0bGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLnRpdGxlKSB8fCB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1vcmlnaW5hbC10aXRsZScpO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfaW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5nZXRPckNyZWF0ZUluc3RhbmNlKGV2ZW50LmRlbGVnYXRlVGFyZ2V0LCB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKTtcbiAgICB9XG4gICAgX2lzQW5pbWF0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29uZmlnLmFuaW1hdGlvbiB8fCB0aGlzLnRpcCAmJiB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDIpO1xuICAgIH1cbiAgICBfaXNTaG93bigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpcCAmJiB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDIpO1xuICAgIH1cbiAgICBfY3JlYXRlUG9wcGVyKHRpcCkge1xuICAgICAgY29uc3QgcGxhY2VtZW50ID0gZXhlY3V0ZSh0aGlzLl9jb25maWcucGxhY2VtZW50LCBbdGhpcywgdGlwLCB0aGlzLl9lbGVtZW50XSk7XG4gICAgICBjb25zdCBhdHRhY2htZW50ID0gQXR0YWNobWVudE1hcFtwbGFjZW1lbnQudG9VcHBlckNhc2UoKV07XG4gICAgICByZXR1cm4gY3JlYXRlUG9wcGVyKHRoaXMuX2VsZW1lbnQsIHRpcCwgdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKGF0dGFjaG1lbnQpKTtcbiAgICB9XG4gICAgX2dldE9mZnNldCgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xuICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBvZmZzZXQuc3BsaXQoJywnKS5tYXAodmFsdWUgPT4gTnVtYmVyLnBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHBvcHBlckRhdGEgPT4gb2Zmc2V0KHBvcHBlckRhdGEsIHRoaXMuX2VsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIGV4ZWN1dGUoYXJnLCBbdGhpcy5fZWxlbWVudF0pO1xuICAgIH1cbiAgICBfZ2V0UG9wcGVyQ29uZmlnKGF0dGFjaG1lbnQpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRCc1BvcHBlckNvbmZpZyA9IHtcbiAgICAgICAgcGxhY2VtZW50OiBhdHRhY2htZW50LFxuICAgICAgICBtb2RpZmllcnM6IFt7XG4gICAgICAgICAgbmFtZTogJ2ZsaXAnLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogdGhpcy5fY29uZmlnLmZhbGxiYWNrUGxhY2VtZW50c1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogJ2Fycm93JyxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBlbGVtZW50OiBgLiR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfS1hcnJvd2BcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiAncHJlU2V0UGxhY2VtZW50JyxcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIHBoYXNlOiAnYmVmb3JlTWFpbicsXG4gICAgICAgICAgZm46IGRhdGEgPT4ge1xuICAgICAgICAgICAgLy8gUHJlLXNldCBQb3BwZXIncyBwbGFjZW1lbnQgYXR0cmlidXRlIGluIG9yZGVyIHRvIHJlYWQgdGhlIGFycm93IHNpemVzIHByb3Blcmx5LlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBQb3BwZXIgbWl4ZXMgdXAgdGhlIHdpZHRoIGFuZCBoZWlnaHQgZGltZW5zaW9ucyBzaW5jZSB0aGUgaW5pdGlhbCBhcnJvdyBzdHlsZSBpcyBmb3IgdG9wIHBsYWNlbWVudFxuICAgICAgICAgICAgdGhpcy5fZ2V0VGlwRWxlbWVudCgpLnNldEF0dHJpYnV0ZSgnZGF0YS1wb3BwZXItcGxhY2VtZW50JywgZGF0YS5zdGF0ZS5wbGFjZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfV1cbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5kZWZhdWx0QnNQb3BwZXJDb25maWcsXG4gICAgICAgIC4uLmV4ZWN1dGUodGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZywgW2RlZmF1bHRCc1BvcHBlckNvbmZpZ10pXG4gICAgICB9O1xuICAgIH1cbiAgICBfc2V0TGlzdGVuZXJzKCkge1xuICAgICAgY29uc3QgdHJpZ2dlcnMgPSB0aGlzLl9jb25maWcudHJpZ2dlci5zcGxpdCgnICcpO1xuICAgICAgZm9yIChjb25zdCB0cmlnZ2VyIG9mIHRyaWdnZXJzKSB7XG4gICAgICAgIGlmICh0cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0NMSUNLJDEpLCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpO1xuICAgICAgICAgICAgY29udGV4dC50b2dnbGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICE9PSBUUklHR0VSX01BTlVBTCkge1xuICAgICAgICAgIGNvbnN0IGV2ZW50SW4gPSB0cmlnZ2VyID09PSBUUklHR0VSX0hPVkVSID8gdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfTU9VU0VFTlRFUikgOiB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9GT0NVU0lOJDEpO1xuICAgICAgICAgIGNvbnN0IGV2ZW50T3V0ID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX01PVVNFTEVBVkUpIDogdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfRk9DVVNPVVQkMSk7XG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIGV2ZW50SW4sIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCk7XG4gICAgICAgICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyW2V2ZW50LnR5cGUgPT09ICdmb2N1c2luJyA/IFRSSUdHRVJfRk9DVVMgOiBUUklHR0VSX0hPVkVSXSA9IHRydWU7XG4gICAgICAgICAgICBjb250ZXh0Ll9lbnRlcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBldmVudE91dCwgdGhpcy5fY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3Vzb3V0JyA/IFRSSUdHRVJfRk9DVVMgOiBUUklHR0VSX0hPVkVSXSA9IGNvbnRleHQuX2VsZW1lbnQuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCk7XG4gICAgICAgICAgICBjb250ZXh0Ll9sZWF2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9NT0RBTCksIEVWRU5UX01PREFMX0hJREUsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpO1xuICAgIH1cbiAgICBfZml4VGl0bGUoKSB7XG4gICAgICBjb25zdCB0aXRsZSA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCd0aXRsZScpO1xuICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJykgJiYgIXRoaXMuX2VsZW1lbnQudGV4dENvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGl0bGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnLCB0aXRsZSk7IC8vIERPIE5PVCBVU0UgSVQuIElzIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGl0bGUnKTtcbiAgICB9XG4gICAgX2VudGVyKCkge1xuICAgICAgaWYgKHRoaXMuX2lzU2hvd24oKSB8fCB0aGlzLl9pc0hvdmVyZWQpIHtcbiAgICAgICAgdGhpcy5faXNIb3ZlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5faXNIb3ZlcmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3NldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5faXNIb3ZlcmVkKSB7XG4gICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheS5zaG93KTtcbiAgICB9XG4gICAgX2xlYXZlKCkge1xuICAgICAgaWYgKHRoaXMuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3NldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX2lzSG92ZXJlZCkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkuaGlkZSk7XG4gICAgfVxuICAgIF9zZXRUaW1lb3V0KGhhbmRsZXIsIHRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGhhbmRsZXIsIHRpbWVvdXQpO1xuICAgIH1cbiAgICBfaXNXaXRoQWN0aXZlVHJpZ2dlcigpIHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2FjdGl2ZVRyaWdnZXIpLmluY2x1ZGVzKHRydWUpO1xuICAgIH1cbiAgICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uc3QgZGF0YUF0dHJpYnV0ZXMgPSBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICAgIGZvciAoY29uc3QgZGF0YUF0dHJpYnV0ZSBvZiBPYmplY3Qua2V5cyhkYXRhQXR0cmlidXRlcykpIHtcbiAgICAgICAgaWYgKERJU0FMTE9XRURfQVRUUklCVVRFUy5oYXMoZGF0YUF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICBkZWxldGUgZGF0YUF0dHJpYnV0ZXNbZGF0YUF0dHJpYnV0ZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgLi4uZGF0YUF0dHJpYnV0ZXMsXG4gICAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSlcbiAgICAgIH07XG4gICAgICBjb25maWcgPSB0aGlzLl9tZXJnZUNvbmZpZ09iaihjb25maWcpO1xuICAgICAgY29uZmlnID0gdGhpcy5fY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpO1xuICAgICAgdGhpcy5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcbiAgICAgIGNvbmZpZy5jb250YWluZXIgPSBjb25maWcuY29udGFpbmVyID09PSBmYWxzZSA/IGRvY3VtZW50LmJvZHkgOiBnZXRFbGVtZW50KGNvbmZpZy5jb250YWluZXIpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbmZpZy5kZWxheSA9IHtcbiAgICAgICAgICBzaG93OiBjb25maWcuZGVsYXksXG4gICAgICAgICAgaGlkZTogY29uZmlnLmRlbGF5XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy50aXRsZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uZmlnLnRpdGxlID0gY29uZmlnLnRpdGxlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5jb250ZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25maWcuY29udGVudCA9IGNvbmZpZy5jb250ZW50LnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgICBfZ2V0RGVsZWdhdGVDb25maWcoKSB7XG4gICAgICBjb25zdCBjb25maWcgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuX2NvbmZpZykpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtrZXldICE9PSB2YWx1ZSkge1xuICAgICAgICAgIGNvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbmZpZy5zZWxlY3RvciA9IGZhbHNlO1xuICAgICAgY29uZmlnLnRyaWdnZXIgPSAnbWFudWFsJztcblxuICAgICAgLy8gSW4gdGhlIGZ1dHVyZSBjYW4gYmUgcmVwbGFjZWQgd2l0aDpcbiAgICAgIC8vIGNvbnN0IGtleXNXaXRoRGlmZmVyZW50VmFsdWVzID0gT2JqZWN0LmVudHJpZXModGhpcy5fY29uZmlnKS5maWx0ZXIoZW50cnkgPT4gdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2VudHJ5WzBdXSAhPT0gdGhpcy5fY29uZmlnW2VudHJ5WzBdXSlcbiAgICAgIC8vIGBPYmplY3QuZnJvbUVudHJpZXMoa2V5c1dpdGhEaWZmZXJlbnRWYWx1ZXMpYFxuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gICAgX2Rpc3Bvc2VQb3BwZXIoKSB7XG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50aXApIHtcbiAgICAgICAgdGhpcy50aXAucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMudGlwID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBUb29sdGlwLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogalF1ZXJ5XG4gICAqL1xuXG4gIGRlZmluZUpRdWVyeVBsdWdpbihUb29sdGlwKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIHBvcG92ZXIuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBOQU1FJDMgPSAncG9wb3Zlcic7XG4gIGNvbnN0IFNFTEVDVE9SX1RJVExFID0gJy5wb3BvdmVyLWhlYWRlcic7XG4gIGNvbnN0IFNFTEVDVE9SX0NPTlRFTlQgPSAnLnBvcG92ZXItYm9keSc7XG4gIGNvbnN0IERlZmF1bHQkMiA9IHtcbiAgICAuLi5Ub29sdGlwLkRlZmF1bHQsXG4gICAgY29udGVudDogJycsXG4gICAgb2Zmc2V0OiBbMCwgOF0sXG4gICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInBvcG92ZXJcIiByb2xlPVwidG9vbHRpcFwiPicgKyAnPGRpdiBjbGFzcz1cInBvcG92ZXItYXJyb3dcIj48L2Rpdj4nICsgJzxoMyBjbGFzcz1cInBvcG92ZXItaGVhZGVyXCI+PC9oMz4nICsgJzxkaXYgY2xhc3M9XCJwb3BvdmVyLWJvZHlcIj48L2Rpdj4nICsgJzwvZGl2PicsXG4gICAgdHJpZ2dlcjogJ2NsaWNrJ1xuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSQyID0ge1xuICAgIC4uLlRvb2x0aXAuRGVmYXVsdFR5cGUsXG4gICAgY29udGVudDogJyhudWxsfHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKSdcbiAgfTtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBQb3BvdmVyIGV4dGVuZHMgVG9vbHRpcCB7XG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0JDI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkMjtcbiAgICB9XG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkMztcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZXNcbiAgICBfaXNXaXRoQ29udGVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRUaXRsZSgpIHx8IHRoaXMuX2dldENvbnRlbnQoKTtcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlXG4gICAgX2dldENvbnRlbnRGb3JUZW1wbGF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtTRUxFQ1RPUl9USVRMRV06IHRoaXMuX2dldFRpdGxlKCksXG4gICAgICAgIFtTRUxFQ1RPUl9DT05URU5UXTogdGhpcy5fZ2V0Q29udGVudCgpXG4gICAgICB9O1xuICAgIH1cbiAgICBfZ2V0Q29udGVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY29udGVudCk7XG4gICAgfVxuXG4gICAgLy8gU3RhdGljXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gUG9wb3Zlci5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oUG9wb3Zlcik7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCBzY3JvbGxzcHkuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBOQU1FJDIgPSAnc2Nyb2xsc3B5JztcbiAgY29uc3QgREFUQV9LRVkkMiA9ICdicy5zY3JvbGxzcHknO1xuICBjb25zdCBFVkVOVF9LRVkkMiA9IGAuJHtEQVRBX0tFWSQyfWA7XG4gIGNvbnN0IERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknO1xuICBjb25zdCBFVkVOVF9BQ1RJVkFURSA9IGBhY3RpdmF0ZSR7RVZFTlRfS0VZJDJ9YDtcbiAgY29uc3QgRVZFTlRfQ0xJQ0sgPSBgY2xpY2ske0VWRU5UX0tFWSQyfWA7XG4gIGNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkkMSA9IGBsb2FkJHtFVkVOVF9LRVkkMn0ke0RBVEFfQVBJX0tFWX1gO1xuICBjb25zdCBDTEFTU19OQU1FX0RST1BET1dOX0lURU0gPSAnZHJvcGRvd24taXRlbSc7XG4gIGNvbnN0IENMQVNTX05BTUVfQUNUSVZFJDEgPSAnYWN0aXZlJztcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9TUFkgPSAnW2RhdGEtYnMtc3B5PVwic2Nyb2xsXCJdJztcbiAgY29uc3QgU0VMRUNUT1JfVEFSR0VUX0xJTktTID0gJ1tocmVmXSc7XG4gIGNvbnN0IFNFTEVDVE9SX05BVl9MSVNUX0dST1VQID0gJy5uYXYsIC5saXN0LWdyb3VwJztcbiAgY29uc3QgU0VMRUNUT1JfTkFWX0xJTktTID0gJy5uYXYtbGluayc7XG4gIGNvbnN0IFNFTEVDVE9SX05BVl9JVEVNUyA9ICcubmF2LWl0ZW0nO1xuICBjb25zdCBTRUxFQ1RPUl9MSVNUX0lURU1TID0gJy5saXN0LWdyb3VwLWl0ZW0nO1xuICBjb25zdCBTRUxFQ1RPUl9MSU5LX0lURU1TID0gYCR7U0VMRUNUT1JfTkFWX0xJTktTfSwgJHtTRUxFQ1RPUl9OQVZfSVRFTVN9ID4gJHtTRUxFQ1RPUl9OQVZfTElOS1N9LCAke1NFTEVDVE9SX0xJU1RfSVRFTVN9YDtcbiAgY29uc3QgU0VMRUNUT1JfRFJPUERPV04gPSAnLmRyb3Bkb3duJztcbiAgY29uc3QgU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFJDEgPSAnLmRyb3Bkb3duLXRvZ2dsZSc7XG4gIGNvbnN0IERlZmF1bHQkMSA9IHtcbiAgICBvZmZzZXQ6IG51bGwsXG4gICAgLy8gVE9ETzogdjYgQGRlcHJlY2F0ZWQsIGtlZXAgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnNcbiAgICByb290TWFyZ2luOiAnMHB4IDBweCAtMjUlJyxcbiAgICBzbW9vdGhTY3JvbGw6IGZhbHNlLFxuICAgIHRhcmdldDogbnVsbCxcbiAgICB0aHJlc2hvbGQ6IFswLjEsIDAuNSwgMV1cbiAgfTtcbiAgY29uc3QgRGVmYXVsdFR5cGUkMSA9IHtcbiAgICBvZmZzZXQ6ICcobnVtYmVyfG51bGwpJyxcbiAgICAvLyBUT0RPIHY2IEBkZXByZWNhdGVkLCBrZWVwIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zXG4gICAgcm9vdE1hcmdpbjogJ3N0cmluZycsXG4gICAgc21vb3RoU2Nyb2xsOiAnYm9vbGVhbicsXG4gICAgdGFyZ2V0OiAnZWxlbWVudCcsXG4gICAgdGhyZXNob2xkOiAnYXJyYXknXG4gIH07XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgU2Nyb2xsU3B5IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuXG4gICAgICAvLyB0aGlzLl9lbGVtZW50IGlzIHRoZSBvYnNlcnZhYmxlc0NvbnRhaW5lciBhbmQgY29uZmlnLnRhcmdldCB0aGUgbWVudSBsaW5rcyB3cmFwcGVyXG4gICAgICB0aGlzLl90YXJnZXRMaW5rcyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuX29ic2VydmFibGVTZWN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50KS5vdmVyZmxvd1kgPT09ICd2aXNpYmxlJyA/IG51bGwgOiB0aGlzLl9lbGVtZW50O1xuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuX29ic2VydmVyID0gbnVsbDtcbiAgICAgIHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YSA9IHtcbiAgICAgICAgdmlzaWJsZUVudHJ5VG9wOiAwLFxuICAgICAgICBwYXJlbnRTY3JvbGxUb3A6IDBcbiAgICAgIH07XG4gICAgICB0aGlzLnJlZnJlc2goKTsgLy8gaW5pdGlhbGl6ZVxuICAgIH1cblxuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCQxO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDE7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJDI7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgcmVmcmVzaCgpIHtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVUYXJnZXRzQW5kT2JzZXJ2YWJsZXMoKTtcbiAgICAgIHRoaXMuX21heWJlRW5hYmxlU21vb3RoU2Nyb2xsKCk7XG4gICAgICBpZiAodGhpcy5fb2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSB0aGlzLl9nZXROZXdPYnNlcnZlcigpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBzZWN0aW9uIG9mIHRoaXMuX29ic2VydmFibGVTZWN0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHNlY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcbiAgICAgIC8vIFRPRE86IG9uIHY2IHRhcmdldCBzaG91bGQgYmUgZ2l2ZW4gZXhwbGljaXRseSAmIHJlbW92ZSB0aGUge3RhcmdldDogJ3NzLXRhcmdldCd9IGNhc2VcbiAgICAgIGNvbmZpZy50YXJnZXQgPSBnZXRFbGVtZW50KGNvbmZpZy50YXJnZXQpIHx8IGRvY3VtZW50LmJvZHk7XG5cbiAgICAgIC8vIFRPRE86IHY2IE9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnMuIFVzZSByb290TWFyZ2luIG9ubHlcbiAgICAgIGNvbmZpZy5yb290TWFyZ2luID0gY29uZmlnLm9mZnNldCA/IGAke2NvbmZpZy5vZmZzZXR9cHggMHB4IC0zMCVgIDogY29uZmlnLnJvb3RNYXJnaW47XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy50aHJlc2hvbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmZpZy50aHJlc2hvbGQgPSBjb25maWcudGhyZXNob2xkLnNwbGl0KCcsJykubWFwKHZhbHVlID0+IE51bWJlci5wYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgICBfbWF5YmVFbmFibGVTbW9vdGhTY3JvbGwoKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zbW9vdGhTY3JvbGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB1bnJlZ2lzdGVyIGFueSBwcmV2aW91cyBsaXN0ZW5lcnNcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fY29uZmlnLnRhcmdldCwgRVZFTlRfQ0xJQ0spO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2NvbmZpZy50YXJnZXQsIEVWRU5UX0NMSUNLLCBTRUxFQ1RPUl9UQVJHRVRfTElOS1MsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZVNlY3Rpb24gPSB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMuZ2V0KGV2ZW50LnRhcmdldC5oYXNoKTtcbiAgICAgICAgaWYgKG9ic2VydmFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBjb25zdCByb290ID0gdGhpcy5fcm9vdEVsZW1lbnQgfHwgd2luZG93O1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IG9ic2VydmFibGVTZWN0aW9uLm9mZnNldFRvcCAtIHRoaXMuX2VsZW1lbnQub2Zmc2V0VG9wO1xuICAgICAgICAgIGlmIChyb290LnNjcm9sbFRvKSB7XG4gICAgICAgICAgICByb290LnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgdG9wOiBoZWlnaHQsXG4gICAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2hyb21lIDYwIGRvZXNuJ3Qgc3VwcG9ydCBgc2Nyb2xsVG9gXG4gICAgICAgICAgcm9vdC5zY3JvbGxUb3AgPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0TmV3T2JzZXJ2ZXIoKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICByb290OiB0aGlzLl9yb290RWxlbWVudCxcbiAgICAgICAgdGhyZXNob2xkOiB0aGlzLl9jb25maWcudGhyZXNob2xkLFxuICAgICAgICByb290TWFyZ2luOiB0aGlzLl9jb25maWcucm9vdE1hcmdpblxuICAgICAgfTtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB0aGlzLl9vYnNlcnZlckNhbGxiYWNrKGVudHJpZXMpLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgbG9naWMgb2Ygc2VsZWN0aW9uXG4gICAgX29ic2VydmVyQ2FsbGJhY2soZW50cmllcykge1xuICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGVudHJ5ID0+IHRoaXMuX3RhcmdldExpbmtzLmdldChgIyR7ZW50cnkudGFyZ2V0LmlkfWApO1xuICAgICAgY29uc3QgYWN0aXZhdGUgPSBlbnRyeSA9PiB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS52aXNpYmxlRW50cnlUb3AgPSBlbnRyeS50YXJnZXQub2Zmc2V0VG9wO1xuICAgICAgICB0aGlzLl9wcm9jZXNzKHRhcmdldEVsZW1lbnQoZW50cnkpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBwYXJlbnRTY3JvbGxUb3AgPSAodGhpcy5fcm9vdEVsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5zY3JvbGxUb3A7XG4gICAgICBjb25zdCB1c2VyU2Nyb2xsc0Rvd24gPSBwYXJlbnRTY3JvbGxUb3AgPj0gdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnBhcmVudFNjcm9sbFRvcDtcbiAgICAgIHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS5wYXJlbnRTY3JvbGxUb3AgPSBwYXJlbnRTY3JvbGxUb3A7XG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgaWYgKCFlbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fY2xlYXJBY3RpdmVDbGFzcyh0YXJnZXRFbGVtZW50KGVudHJ5KSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW50cnlJc0xvd2VyVGhhblByZXZpb3VzID0gZW50cnkudGFyZ2V0Lm9mZnNldFRvcCA+PSB0aGlzLl9wcmV2aW91c1Njcm9sbERhdGEudmlzaWJsZUVudHJ5VG9wO1xuICAgICAgICAvLyBpZiB3ZSBhcmUgc2Nyb2xsaW5nIGRvd24sIHBpY2sgdGhlIGJpZ2dlciBvZmZzZXRUb3BcbiAgICAgICAgaWYgKHVzZXJTY3JvbGxzRG93biAmJiBlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMpIHtcbiAgICAgICAgICBhY3RpdmF0ZShlbnRyeSk7XG4gICAgICAgICAgLy8gaWYgcGFyZW50IGlzbid0IHNjcm9sbGVkLCBsZXQncyBrZWVwIHRoZSBmaXJzdCB2aXNpYmxlIGl0ZW0sIGJyZWFraW5nIHRoZSBpdGVyYXRpb25cbiAgICAgICAgICBpZiAoIXBhcmVudFNjcm9sbFRvcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGFyZSBzY3JvbGxpbmcgdXAsIHBpY2sgdGhlIHNtYWxsZXN0IG9mZnNldFRvcFxuICAgICAgICBpZiAoIXVzZXJTY3JvbGxzRG93biAmJiAhZW50cnlJc0xvd2VyVGhhblByZXZpb3VzKSB7XG4gICAgICAgICAgYWN0aXZhdGUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9pbml0aWFsaXplVGFyZ2V0c0FuZE9ic2VydmFibGVzKCkge1xuICAgICAgdGhpcy5fdGFyZ2V0TGlua3MgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCB0YXJnZXRMaW5rcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfVEFSR0VUX0xJTktTLCB0aGlzLl9jb25maWcudGFyZ2V0KTtcbiAgICAgIGZvciAoY29uc3QgYW5jaG9yIG9mIHRhcmdldExpbmtzKSB7XG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBhbmNob3IgaGFzIGFuIGlkIGFuZCBpcyBub3QgZGlzYWJsZWRcbiAgICAgICAgaWYgKCFhbmNob3IuaGFzaCB8fCBpc0Rpc2FibGVkKGFuY2hvcikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYnNlcnZhYmxlU2VjdGlvbiA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoZGVjb2RlVVJJKGFuY2hvci5oYXNoKSwgdGhpcy5fZWxlbWVudCk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIG9ic2VydmFibGVTZWN0aW9uIGV4aXN0cyAmIGlzIHZpc2libGVcbiAgICAgICAgaWYgKGlzVmlzaWJsZShvYnNlcnZhYmxlU2VjdGlvbikpIHtcbiAgICAgICAgICB0aGlzLl90YXJnZXRMaW5rcy5zZXQoZGVjb2RlVVJJKGFuY2hvci5oYXNoKSwgYW5jaG9yKTtcbiAgICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMuc2V0KGFuY2hvci5oYXNoLCBvYnNlcnZhYmxlU2VjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX3Byb2Nlc3ModGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ID09PSB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2xlYXJBY3RpdmVDbGFzcyh0aGlzLl9jb25maWcudGFyZ2V0KTtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHRhcmdldDtcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuICAgICAgdGhpcy5fYWN0aXZhdGVQYXJlbnRzKHRhcmdldCk7XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9BQ1RJVkFURSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0YXJnZXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfYWN0aXZhdGVQYXJlbnRzKHRhcmdldCkge1xuICAgICAgLy8gQWN0aXZhdGUgZHJvcGRvd24gcGFyZW50c1xuICAgICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNKSkge1xuICAgICAgICBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSQxLCB0YXJnZXQuY2xvc2VzdChTRUxFQ1RPUl9EUk9QRE9XTikpLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgbGlzdEdyb3VwIG9mIFNlbGVjdG9yRW5naW5lLnBhcmVudHModGFyZ2V0LCBTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCkpIHtcbiAgICAgICAgLy8gU2V0IHRyaWdnZXJlZCBsaW5rcyBwYXJlbnRzIGFzIGFjdGl2ZVxuICAgICAgICAvLyBXaXRoIGJvdGggPHVsPiBhbmQgPG5hdj4gbWFya3VwIGEgcGFyZW50IGlzIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIGFueSBuYXYgYW5jZXN0b3JcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIFNlbGVjdG9yRW5naW5lLnByZXYobGlzdEdyb3VwLCBTRUxFQ1RPUl9MSU5LX0lURU1TKSkge1xuICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfY2xlYXJBY3RpdmVDbGFzcyhwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuICAgICAgY29uc3QgYWN0aXZlTm9kZXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKGAke1NFTEVDVE9SX1RBUkdFVF9MSU5LU30uJHtDTEFTU19OQU1FX0FDVElWRSQxfWAsIHBhcmVudCk7XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgYWN0aXZlTm9kZXMpIHtcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0YXRpY1xuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFNjcm9sbFNweS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gICAqL1xuXG4gIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEkkMSwgKCkgPT4ge1xuICAgIGZvciAoY29uc3Qgc3B5IG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9TUFkpKSB7XG4gICAgICBTY3JvbGxTcHkuZ2V0T3JDcmVhdGVJbnN0YW5jZShzcHkpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oU2Nyb2xsU3B5KTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIHRhYi5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkMSA9ICd0YWInO1xuICBjb25zdCBEQVRBX0tFWSQxID0gJ2JzLnRhYic7XG4gIGNvbnN0IEVWRU5UX0tFWSQxID0gYC4ke0RBVEFfS0VZJDF9YDtcbiAgY29uc3QgRVZFTlRfSElERSQxID0gYGhpZGUke0VWRU5UX0tFWSQxfWA7XG4gIGNvbnN0IEVWRU5UX0hJRERFTiQxID0gYGhpZGRlbiR7RVZFTlRfS0VZJDF9YDtcbiAgY29uc3QgRVZFTlRfU0hPVyQxID0gYHNob3cke0VWRU5UX0tFWSQxfWA7XG4gIGNvbnN0IEVWRU5UX1NIT1dOJDEgPSBgc2hvd24ke0VWRU5UX0tFWSQxfWA7XG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVkkMX1gO1xuICBjb25zdCBFVkVOVF9LRVlET1dOID0gYGtleWRvd24ke0VWRU5UX0tFWSQxfWA7XG4gIGNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkgPSBgbG9hZCR7RVZFTlRfS0VZJDF9YDtcbiAgY29uc3QgQVJST1dfTEVGVF9LRVkgPSAnQXJyb3dMZWZ0JztcbiAgY29uc3QgQVJST1dfUklHSFRfS0VZID0gJ0Fycm93UmlnaHQnO1xuICBjb25zdCBBUlJPV19VUF9LRVkgPSAnQXJyb3dVcCc7XG4gIGNvbnN0IEFSUk9XX0RPV05fS0VZID0gJ0Fycm93RG93bic7XG4gIGNvbnN0IEhPTUVfS0VZID0gJ0hvbWUnO1xuICBjb25zdCBFTkRfS0VZID0gJ0VuZCc7XG4gIGNvbnN0IENMQVNTX05BTUVfQUNUSVZFID0gJ2FjdGl2ZSc7XG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQxID0gJ2ZhZGUnO1xuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckMSA9ICdzaG93JztcbiAgY29uc3QgQ0xBU1NfRFJPUERPV04gPSAnZHJvcGRvd24nO1xuICBjb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUgPSAnLmRyb3Bkb3duLXRvZ2dsZSc7XG4gIGNvbnN0IFNFTEVDVE9SX0RST1BET1dOX01FTlUgPSAnLmRyb3Bkb3duLW1lbnUnO1xuICBjb25zdCBOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFID0gYDpub3QoJHtTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEV9KWA7XG4gIGNvbnN0IFNFTEVDVE9SX1RBQl9QQU5FTCA9ICcubGlzdC1ncm91cCwgLm5hdiwgW3JvbGU9XCJ0YWJsaXN0XCJdJztcbiAgY29uc3QgU0VMRUNUT1JfT1VURVIgPSAnLm5hdi1pdGVtLCAubGlzdC1ncm91cC1pdGVtJztcbiAgY29uc3QgU0VMRUNUT1JfSU5ORVIgPSBgLm5hdi1saW5rJHtOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFfSwgLmxpc3QtZ3JvdXAtaXRlbSR7Tk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRX0sIFtyb2xlPVwidGFiXCJdJHtOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFfWA7XG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFID0gJ1tkYXRhLWJzLXRvZ2dsZT1cInRhYlwiXSwgW2RhdGEtYnMtdG9nZ2xlPVwicGlsbFwiXSwgW2RhdGEtYnMtdG9nZ2xlPVwibGlzdFwiXSc7IC8vIFRPRE86IGNvdWxkIG9ubHkgYmUgYHRhYmAgaW4gdjZcbiAgY29uc3QgU0VMRUNUT1JfSU5ORVJfRUxFTSA9IGAke1NFTEVDVE9SX0lOTkVSfSwgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRX1gO1xuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRV9BQ1RJVkUgPSBgLiR7Q0xBU1NfTkFNRV9BQ1RJVkV9W2RhdGEtYnMtdG9nZ2xlPVwidGFiXCJdLCAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XCJwaWxsXCJdLCAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XCJsaXN0XCJdYDtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBUYWIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgICBzdXBlcihlbGVtZW50KTtcbiAgICAgIHRoaXMuX3BhcmVudCA9IHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9UQUJfUEFORUwpO1xuICAgICAgaWYgKCF0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBUT0RPOiBzaG91bGQgdGhyb3cgZXhjZXB0aW9uIGluIHY2XG4gICAgICAgIC8vIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZWxlbWVudC5vdXRlckhUTUx9IGhhcyBub3QgYSB2YWxpZCBwYXJlbnQgJHtTRUxFQ1RPUl9JTk5FUl9FTEVNfWApXG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBpbml0aWFsIGFyaWEgYXR0cmlidXRlc1xuICAgICAgdGhpcy5fc2V0SW5pdGlhbEF0dHJpYnV0ZXModGhpcy5fcGFyZW50LCB0aGlzLl9nZXRDaGlsZHJlbigpKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOLCBldmVudCA9PiB0aGlzLl9rZXlkb3duKGV2ZW50KSk7XG4gICAgfVxuXG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJDE7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgc2hvdygpIHtcbiAgICAgIC8vIFNob3dzIHRoaXMgZWxlbSBhbmQgZGVhY3RpdmF0ZSB0aGUgYWN0aXZlIHNpYmxpbmcgaWYgZXhpc3RzXG4gICAgICBjb25zdCBpbm5lckVsZW0gPSB0aGlzLl9lbGVtZW50O1xuICAgICAgaWYgKHRoaXMuX2VsZW1Jc0FjdGl2ZShpbm5lckVsZW0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU2VhcmNoIGZvciBhY3RpdmUgdGFiIG9uIHNhbWUgcGFyZW50IHRvIGRlYWN0aXZhdGUgaXRcbiAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW0oKTtcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IGFjdGl2ZSA/IEV2ZW50SGFuZGxlci50cmlnZ2VyKGFjdGl2ZSwgRVZFTlRfSElERSQxLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IGlubmVyRWxlbVxuICAgICAgfSkgOiBudWxsO1xuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIoaW5uZXJFbGVtLCBFVkVOVF9TSE9XJDEsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogYWN0aXZlXG4gICAgICB9KTtcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCBoaWRlRXZlbnQgJiYgaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGVhY3RpdmF0ZShhY3RpdmUsIGlubmVyRWxlbSk7XG4gICAgICB0aGlzLl9hY3RpdmF0ZShpbm5lckVsZW0sIGFjdGl2ZSk7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZVxuICAgIF9hY3RpdmF0ZShlbGVtZW50LCByZWxhdGVkRWxlbSkge1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgICB0aGlzLl9hY3RpdmF0ZShTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKGVsZW1lbnQpKTsgLy8gU2VhcmNoIGFuZCBhY3RpdmF0ZS9zaG93IHRoZSBwcm9wZXIgc2VjdGlvblxuXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJykgIT09ICd0YWInKSB7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3RvZ2dsZURyb3BEb3duKGVsZW1lbnQsIHRydWUpO1xuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcihlbGVtZW50LCBFVkVOVF9TSE9XTiQxLCB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZEVsZW1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgZWxlbWVudCwgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDEpKTtcbiAgICB9XG4gICAgX2RlYWN0aXZhdGUoZWxlbWVudCwgcmVsYXRlZEVsZW0pIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUpO1xuICAgICAgZWxlbWVudC5ibHVyKCk7XG4gICAgICB0aGlzLl9kZWFjdGl2YXRlKFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCkpOyAvLyBTZWFyY2ggYW5kIGRlYWN0aXZhdGUgdGhlIHNob3duIHNlY3Rpb24gdG9vXG5cbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJ3RhYicpIHtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgIHRoaXMuX3RvZ2dsZURyb3BEb3duKGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIoZWxlbWVudCwgRVZFTlRfSElEREVOJDEsIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkRWxlbVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCBlbGVtZW50LCBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMSkpO1xuICAgIH1cbiAgICBfa2V5ZG93bihldmVudCkge1xuICAgICAgaWYgKCFbQVJST1dfTEVGVF9LRVksIEFSUk9XX1JJR0hUX0tFWSwgQVJST1dfVVBfS0VZLCBBUlJPV19ET1dOX0tFWSwgSE9NRV9LRVksIEVORF9LRVldLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIHN0b3BQcm9wYWdhdGlvbi9wcmV2ZW50RGVmYXVsdCBib3RoIGFkZGVkIHRvIHN1cHBvcnQgdXAvZG93biBrZXlzIHdpdGhvdXQgc2Nyb2xsaW5nIHRoZSBwYWdlXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9nZXRDaGlsZHJlbigpLmZpbHRlcihlbGVtZW50ID0+ICFpc0Rpc2FibGVkKGVsZW1lbnQpKTtcbiAgICAgIGxldCBuZXh0QWN0aXZlRWxlbWVudDtcbiAgICAgIGlmIChbSE9NRV9LRVksIEVORF9LRVldLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgbmV4dEFjdGl2ZUVsZW1lbnQgPSBjaGlsZHJlbltldmVudC5rZXkgPT09IEhPTUVfS0VZID8gMCA6IGNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaXNOZXh0ID0gW0FSUk9XX1JJR0hUX0tFWSwgQVJST1dfRE9XTl9LRVldLmluY2x1ZGVzKGV2ZW50LmtleSk7XG4gICAgICAgIG5leHRBY3RpdmVFbGVtZW50ID0gZ2V0TmV4dEFjdGl2ZUVsZW1lbnQoY2hpbGRyZW4sIGV2ZW50LnRhcmdldCwgaXNOZXh0LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0QWN0aXZlRWxlbWVudCkge1xuICAgICAgICBuZXh0QWN0aXZlRWxlbWVudC5mb2N1cyh7XG4gICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UobmV4dEFjdGl2ZUVsZW1lbnQpLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX2dldENoaWxkcmVuKCkge1xuICAgICAgLy8gY29sbGVjdGlvbiBvZiBpbm5lciBlbGVtZW50c1xuICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSU5ORVJfRUxFTSwgdGhpcy5fcGFyZW50KTtcbiAgICB9XG4gICAgX2dldEFjdGl2ZUVsZW0oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q2hpbGRyZW4oKS5maW5kKGNoaWxkID0+IHRoaXMuX2VsZW1Jc0FjdGl2ZShjaGlsZCkpIHx8IG51bGw7XG4gICAgfVxuICAgIF9zZXRJbml0aWFsQXR0cmlidXRlcyhwYXJlbnQsIGNoaWxkcmVuKSB7XG4gICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyhwYXJlbnQsICdyb2xlJywgJ3RhYmxpc3QnKTtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5fc2V0SW5pdGlhbEF0dHJpYnV0ZXNPbkNoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3NldEluaXRpYWxBdHRyaWJ1dGVzT25DaGlsZChjaGlsZCkge1xuICAgICAgY2hpbGQgPSB0aGlzLl9nZXRJbm5lckVsZW1lbnQoY2hpbGQpO1xuICAgICAgY29uc3QgaXNBY3RpdmUgPSB0aGlzLl9lbGVtSXNBY3RpdmUoY2hpbGQpO1xuICAgICAgY29uc3Qgb3V0ZXJFbGVtID0gdGhpcy5fZ2V0T3V0ZXJFbGVtZW50KGNoaWxkKTtcbiAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGlzQWN0aXZlKTtcbiAgICAgIGlmIChvdXRlckVsZW0gIT09IGNoaWxkKSB7XG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKG91dGVyRWxlbSwgJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKGNoaWxkLCAncm9sZScsICd0YWInKTtcblxuICAgICAgLy8gc2V0IGF0dHJpYnV0ZXMgdG8gdGhlIHJlbGF0ZWQgcGFuZWwgdG9vXG4gICAgICB0aGlzLl9zZXRJbml0aWFsQXR0cmlidXRlc09uVGFyZ2V0UGFuZWwoY2hpbGQpO1xuICAgIH1cbiAgICBfc2V0SW5pdGlhbEF0dHJpYnV0ZXNPblRhcmdldFBhbmVsKGNoaWxkKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKGNoaWxkKTtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKHRhcmdldCwgJ3JvbGUnLCAndGFicGFuZWwnKTtcbiAgICAgIGlmIChjaGlsZC5pZCkge1xuICAgICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyh0YXJnZXQsICdhcmlhLWxhYmVsbGVkYnknLCBgJHtjaGlsZC5pZH1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3RvZ2dsZURyb3BEb3duKGVsZW1lbnQsIG9wZW4pIHtcbiAgICAgIGNvbnN0IG91dGVyRWxlbSA9IHRoaXMuX2dldE91dGVyRWxlbWVudChlbGVtZW50KTtcbiAgICAgIGlmICghb3V0ZXJFbGVtLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19EUk9QRE9XTikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9nZ2xlID0gKHNlbGVjdG9yLCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoc2VsZWN0b3IsIG91dGVyRWxlbSk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSwgb3Blbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0b2dnbGUoU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFLCBDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgICB0b2dnbGUoU0VMRUNUT1JfRFJPUERPV05fTUVOVSwgQ0xBU1NfTkFNRV9TSE9XJDEpO1xuICAgICAgb3V0ZXJFbGVtLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIG9wZW4pO1xuICAgIH1cbiAgICBfc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBfZWxlbUlzQWN0aXZlKGVsZW0pIHtcbiAgICAgIHJldHVybiBlbGVtLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIGdldCB0aGUgaW5uZXIgZWxlbWVudCAodXN1YWxseSB0aGUgLm5hdi1saW5rKVxuICAgIF9nZXRJbm5lckVsZW1lbnQoZWxlbSkge1xuICAgICAgcmV0dXJuIGVsZW0ubWF0Y2hlcyhTRUxFQ1RPUl9JTk5FUl9FTEVNKSA/IGVsZW0gOiBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0lOTkVSX0VMRU0sIGVsZW0pO1xuICAgIH1cblxuICAgIC8vIFRyeSB0byBnZXQgdGhlIG91dGVyIGVsZW1lbnQgKHVzdWFsbHkgdGhlIC5uYXYtaXRlbSlcbiAgICBfZ2V0T3V0ZXJFbGVtZW50KGVsZW0pIHtcbiAgICAgIHJldHVybiBlbGVtLmNsb3Nlc3QoU0VMRUNUT1JfT1VURVIpIHx8IGVsZW07XG4gICAgfVxuXG4gICAgLy8gU3RhdGljXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gICAqL1xuXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBUYWIuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKS5zaG93KCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIG9uIGZvY3VzXG4gICAqL1xuICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJLCAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9UT0dHTEVfQUNUSVZFKSkge1xuICAgICAgVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oVGFiKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIHRvYXN0LmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgTkFNRSA9ICd0b2FzdCc7XG4gIGNvbnN0IERBVEFfS0VZID0gJ2JzLnRvYXN0JztcbiAgY29uc3QgRVZFTlRfS0VZID0gYC4ke0RBVEFfS0VZfWA7XG4gIGNvbnN0IEVWRU5UX01PVVNFT1ZFUiA9IGBtb3VzZW92ZXIke0VWRU5UX0tFWX1gO1xuICBjb25zdCBFVkVOVF9NT1VTRU9VVCA9IGBtb3VzZW91dCR7RVZFTlRfS0VZfWA7XG4gIGNvbnN0IEVWRU5UX0ZPQ1VTSU4gPSBgZm9jdXNpbiR7RVZFTlRfS0VZfWA7XG4gIGNvbnN0IEVWRU5UX0ZPQ1VTT1VUID0gYGZvY3Vzb3V0JHtFVkVOVF9LRVl9YDtcbiAgY29uc3QgRVZFTlRfSElERSA9IGBoaWRlJHtFVkVOVF9LRVl9YDtcbiAgY29uc3QgRVZFTlRfSElEREVOID0gYGhpZGRlbiR7RVZFTlRfS0VZfWA7XG4gIGNvbnN0IEVWRU5UX1NIT1cgPSBgc2hvdyR7RVZFTlRfS0VZfWA7XG4gIGNvbnN0IEVWRU5UX1NIT1dOID0gYHNob3duJHtFVkVOVF9LRVl9YDtcbiAgY29uc3QgQ0xBU1NfTkFNRV9GQURFID0gJ2ZhZGUnO1xuICBjb25zdCBDTEFTU19OQU1FX0hJREUgPSAnaGlkZSc7IC8vIEBkZXByZWNhdGVkIC0ga2VwdCBoZXJlIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93JztcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XSU5HID0gJ3Nob3dpbmcnO1xuICBjb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgICBhbmltYXRpb246ICdib29sZWFuJyxcbiAgICBhdXRvaGlkZTogJ2Jvb2xlYW4nLFxuICAgIGRlbGF5OiAnbnVtYmVyJ1xuICB9O1xuICBjb25zdCBEZWZhdWx0ID0ge1xuICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICBhdXRvaGlkZTogdHJ1ZSxcbiAgICBkZWxheTogNTAwMFxuICB9O1xuXG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIFRvYXN0IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuICAgICAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gICAgICB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgICB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGU7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FO1xuICAgIH1cblxuICAgIC8vIFB1YmxpY1xuICAgIHNob3coKSB7XG4gICAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XKTtcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgICAgIGlmICh0aGlzLl9jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkcpO1xuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTik7XG4gICAgICAgIHRoaXMuX21heWJlU2NoZWR1bGVIaWRlKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfSElERSk7IC8vIEBkZXByZWNhdGVkXG4gICAgICByZWZsb3codGhpcy5fZWxlbWVudCk7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XLCBDTEFTU19OQU1FX1NIT1dJTkcpO1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbik7XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNTaG93bigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUpO1xuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9ISURFKTsgLy8gQGRlcHJlY2F0ZWRcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORywgQ0xBU1NfTkFNRV9TSE9XKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOKTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XSU5HKTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgICBpZiAodGhpcy5pc1Nob3duKCkpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyk7XG4gICAgICB9XG4gICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGlzU2hvd24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKTtcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlXG5cbiAgICBfbWF5YmVTY2hlZHVsZUhpZGUoKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5hdXRvaGlkZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiB8fCB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkpO1xuICAgIH1cbiAgICBfb25JbnRlcmFjdGlvbihldmVudCwgaXNJbnRlcmFjdGluZykge1xuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ21vdXNlb3Zlcic6XG4gICAgICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gaXNJbnRlcmFjdGluZztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZm9jdXNpbic6XG4gICAgICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uID0gaXNJbnRlcmFjdGluZztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0ludGVyYWN0aW5nKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0RWxlbWVudCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICBpZiAodGhpcy5fZWxlbWVudCA9PT0gbmV4dEVsZW1lbnQgfHwgdGhpcy5fZWxlbWVudC5jb250YWlucyhuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcbiAgICB9XG4gICAgX3NldExpc3RlbmVycygpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRU9WRVIsIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIHRydWUpKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRU9VVCwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgZmFsc2UpKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9GT0NVU0lOLCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCB0cnVlKSk7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfRk9DVVNPVVQsIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIGZhbHNlKSk7XG4gICAgfVxuICAgIF9jbGVhclRpbWVvdXQoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBUb2FzdC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAgICovXG5cbiAgZW5hYmxlRGlzbWlzc1RyaWdnZXIoVG9hc3QpO1xuXG4gIC8qKlxuICAgKiBqUXVlcnlcbiAgICovXG5cbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKFRvYXN0KTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIGluZGV4LnVtZC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgY29uc3QgaW5kZXhfdW1kID0ge1xuICAgIEFsZXJ0LFxuICAgIEJ1dHRvbixcbiAgICBDYXJvdXNlbCxcbiAgICBDb2xsYXBzZSxcbiAgICBEcm9wZG93bixcbiAgICBNb2RhbCxcbiAgICBPZmZjYW52YXMsXG4gICAgUG9wb3ZlcixcbiAgICBTY3JvbGxTcHksXG4gICAgVGFiLFxuICAgIFRvYXN0LFxuICAgIFRvb2x0aXBcbiAgfTtcblxuICByZXR1cm4gaW5kZXhfdW1kO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib290c3RyYXAuYnVuZGxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwiZ2xvYmFsVGhpcyIsInNlbGYiLCJib290c3RyYXAiLCJlbGVtZW50TWFwIiwiTWFwIiwiRGF0YSIsInNldCIsImVsZW1lbnQiLCJrZXkiLCJpbnN0YW5jZSIsImhhcyIsImluc3RhbmNlTWFwIiwiZ2V0Iiwic2l6ZSIsImNvbnNvbGUiLCJlcnJvciIsIkFycmF5IiwiZnJvbSIsImtleXMiLCJyZW1vdmUiLCJkZWxldGUiLCJNQVhfVUlEIiwiTUlMTElTRUNPTkRTX01VTFRJUExJRVIiLCJUUkFOU0lUSU9OX0VORCIsInBhcnNlU2VsZWN0b3IiLCJzZWxlY3RvciIsIndpbmRvdyIsIkNTUyIsImVzY2FwZSIsInJlcGxhY2UiLCJtYXRjaCIsImlkIiwidG9UeXBlIiwib2JqZWN0IiwidW5kZWZpbmVkIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwidG9Mb3dlckNhc2UiLCJnZXRVSUQiLCJwcmVmaXgiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJ0cmFuc2l0aW9uRGVsYXkiLCJnZXRDb21wdXRlZFN0eWxlIiwiZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24iLCJOdW1iZXIiLCJwYXJzZUZsb2F0IiwiZmxvYXRUcmFuc2l0aW9uRGVsYXkiLCJzcGxpdCIsInRyaWdnZXJUcmFuc2l0aW9uRW5kIiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50IiwiaXNFbGVtZW50JDEiLCJqcXVlcnkiLCJub2RlVHlwZSIsImdldEVsZW1lbnQiLCJsZW5ndGgiLCJxdWVyeVNlbGVjdG9yIiwiaXNWaXNpYmxlIiwiZ2V0Q2xpZW50UmVjdHMiLCJlbGVtZW50SXNWaXNpYmxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImNsb3NlZERldGFpbHMiLCJjbG9zZXN0Iiwic3VtbWFyeSIsInBhcmVudE5vZGUiLCJpc0Rpc2FibGVkIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwiZGlzYWJsZWQiLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJmaW5kU2hhZG93Um9vdCIsImRvY3VtZW50RWxlbWVudCIsImF0dGFjaFNoYWRvdyIsImdldFJvb3ROb2RlIiwicm9vdCIsIlNoYWRvd1Jvb3QiLCJub29wIiwicmVmbG93Iiwib2Zmc2V0SGVpZ2h0IiwiZ2V0alF1ZXJ5IiwialF1ZXJ5IiwiYm9keSIsIkRPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MiLCJvbkRPTUNvbnRlbnRMb2FkZWQiLCJjYWxsYmFjayIsInJlYWR5U3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwicHVzaCIsImlzUlRMIiwiZGlyIiwiZGVmaW5lSlF1ZXJ5UGx1Z2luIiwicGx1Z2luIiwiJCIsIm5hbWUiLCJOQU1FIiwiSlFVRVJZX05PX0NPTkZMSUNUIiwiZm4iLCJqUXVlcnlJbnRlcmZhY2UiLCJDb25zdHJ1Y3RvciIsIm5vQ29uZmxpY3QiLCJleGVjdXRlIiwicG9zc2libGVDYWxsYmFjayIsImFyZ3MiLCJkZWZhdWx0VmFsdWUiLCJleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uIiwidHJhbnNpdGlvbkVsZW1lbnQiLCJ3YWl0Rm9yVHJhbnNpdGlvbiIsImR1cmF0aW9uUGFkZGluZyIsImVtdWxhdGVkRHVyYXRpb24iLCJjYWxsZWQiLCJoYW5kbGVyIiwidGFyZ2V0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNldFRpbWVvdXQiLCJnZXROZXh0QWN0aXZlRWxlbWVudCIsImxpc3QiLCJhY3RpdmVFbGVtZW50Iiwic2hvdWxkR2V0TmV4dCIsImlzQ3ljbGVBbGxvd2VkIiwibGlzdExlbmd0aCIsImluZGV4IiwiaW5kZXhPZiIsIm1heCIsIm1pbiIsIm5hbWVzcGFjZVJlZ2V4Iiwic3RyaXBOYW1lUmVnZXgiLCJzdHJpcFVpZFJlZ2V4IiwiZXZlbnRSZWdpc3RyeSIsInVpZEV2ZW50IiwiY3VzdG9tRXZlbnRzIiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJuYXRpdmVFdmVudHMiLCJTZXQiLCJtYWtlRXZlbnRVaWQiLCJ1aWQiLCJnZXRFbGVtZW50RXZlbnRzIiwiYm9vdHN0cmFwSGFuZGxlciIsImV2ZW50IiwiaHlkcmF0ZU9iaiIsImRlbGVnYXRlVGFyZ2V0Iiwib25lT2ZmIiwiRXZlbnRIYW5kbGVyIiwib2ZmIiwidHlwZSIsImFwcGx5IiwiYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIiLCJkb21FbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJkb21FbGVtZW50IiwiZmluZEhhbmRsZXIiLCJldmVudHMiLCJjYWxsYWJsZSIsImRlbGVnYXRpb25TZWxlY3RvciIsInZhbHVlcyIsImZpbmQiLCJub3JtYWxpemVQYXJhbWV0ZXJzIiwib3JpZ2luYWxUeXBlRXZlbnQiLCJkZWxlZ2F0aW9uRnVuY3Rpb24iLCJpc0RlbGVnYXRlZCIsInR5cGVFdmVudCIsImdldFR5cGVFdmVudCIsImFkZEhhbmRsZXIiLCJ3cmFwRnVuY3Rpb24iLCJyZWxhdGVkVGFyZ2V0IiwiaGFuZGxlcnMiLCJwcmV2aW91c0Z1bmN0aW9uIiwicmVtb3ZlSGFuZGxlciIsIkJvb2xlYW4iLCJyZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMiLCJuYW1lc3BhY2UiLCJzdG9yZUVsZW1lbnRFdmVudCIsImhhbmRsZXJLZXkiLCJlbnRyaWVzIiwiaW5jbHVkZXMiLCJvbiIsIm9uZSIsImluTmFtZXNwYWNlIiwiaXNOYW1lc3BhY2UiLCJzdGFydHNXaXRoIiwiZWxlbWVudEV2ZW50Iiwic2xpY2UiLCJrZXlIYW5kbGVycyIsInRyaWdnZXIiLCJqUXVlcnlFdmVudCIsImJ1YmJsZXMiLCJuYXRpdmVEaXNwYXRjaCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiZXZ0IiwiY2FuY2VsYWJsZSIsInByZXZlbnREZWZhdWx0Iiwib2JqIiwibWV0YSIsInZhbHVlIiwiX3VudXNlZCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwibm9ybWFsaXplRGF0YSIsIkpTT04iLCJwYXJzZSIsImRlY29kZVVSSUNvbXBvbmVudCIsIm5vcm1hbGl6ZURhdGFLZXkiLCJjaHIiLCJNYW5pcHVsYXRvciIsInNldERhdGFBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVEYXRhQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiZ2V0RGF0YUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwiYnNLZXlzIiwiZGF0YXNldCIsImZpbHRlciIsInB1cmVLZXkiLCJjaGFyQXQiLCJnZXREYXRhQXR0cmlidXRlIiwiQ29uZmlnIiwiRGVmYXVsdCIsIkRlZmF1bHRUeXBlIiwiRXJyb3IiLCJfZ2V0Q29uZmlnIiwiY29uZmlnIiwiX21lcmdlQ29uZmlnT2JqIiwiX2NvbmZpZ0FmdGVyTWVyZ2UiLCJfdHlwZUNoZWNrQ29uZmlnIiwianNvbkNvbmZpZyIsImNvbnN0cnVjdG9yIiwiY29uZmlnVHlwZXMiLCJwcm9wZXJ0eSIsImV4cGVjdGVkVHlwZXMiLCJ2YWx1ZVR5cGUiLCJSZWdFeHAiLCJ0ZXN0IiwiVHlwZUVycm9yIiwidG9VcHBlckNhc2UiLCJWRVJTSU9OIiwiQmFzZUNvbXBvbmVudCIsImRpc3Bvc2UiLCJfZWxlbWVudCIsIkRBVEFfS0VZIiwiRVZFTlRfS0VZIiwicHJvcGVydHlOYW1lIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIl9xdWV1ZUNhbGxiYWNrIiwiaXNBbmltYXRlZCIsImdldEluc3RhbmNlIiwiZ2V0T3JDcmVhdGVJbnN0YW5jZSIsImV2ZW50TmFtZSIsIl9jb25maWciLCJnZXRTZWxlY3RvciIsImhyZWZBdHRyaWJ1dGUiLCJ0cmltIiwibWFwIiwic2VsIiwiam9pbiIsIlNlbGVjdG9yRW5naW5lIiwiY29uY2F0IiwiRWxlbWVudCIsImZpbmRPbmUiLCJjaGlsZHJlbiIsImNoaWxkIiwibWF0Y2hlcyIsInBhcmVudHMiLCJhbmNlc3RvciIsInByZXYiLCJwcmV2aW91cyIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJuZXh0IiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiZm9jdXNhYmxlQ2hpbGRyZW4iLCJmb2N1c2FibGVzIiwiZWwiLCJnZXRTZWxlY3RvckZyb21FbGVtZW50IiwiZ2V0RWxlbWVudEZyb21TZWxlY3RvciIsImdldE11bHRpcGxlRWxlbWVudHNGcm9tU2VsZWN0b3IiLCJlbmFibGVEaXNtaXNzVHJpZ2dlciIsImNvbXBvbmVudCIsIm1ldGhvZCIsImNsaWNrRXZlbnQiLCJ0YWdOYW1lIiwiTkFNRSRmIiwiREFUQV9LRVkkYSIsIkVWRU5UX0tFWSRiIiwiRVZFTlRfQ0xPU0UiLCJFVkVOVF9DTE9TRUQiLCJDTEFTU19OQU1FX0ZBREUkNSIsIkNMQVNTX05BTUVfU0hPVyQ4IiwiQWxlcnQiLCJjbG9zZSIsImNsb3NlRXZlbnQiLCJfZGVzdHJveUVsZW1lbnQiLCJlYWNoIiwiZGF0YSIsIk5BTUUkZSIsIkRBVEFfS0VZJDkiLCJFVkVOVF9LRVkkYSIsIkRBVEFfQVBJX0tFWSQ2IiwiQ0xBU1NfTkFNRV9BQ1RJVkUkMyIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFJDUiLCJFVkVOVF9DTElDS19EQVRBX0FQSSQ2IiwiQnV0dG9uIiwidG9nZ2xlIiwiYnV0dG9uIiwiTkFNRSRkIiwiRVZFTlRfS0VZJDkiLCJFVkVOVF9UT1VDSFNUQVJUIiwiRVZFTlRfVE9VQ0hNT1ZFIiwiRVZFTlRfVE9VQ0hFTkQiLCJFVkVOVF9QT0lOVEVSRE9XTiIsIkVWRU5UX1BPSU5URVJVUCIsIlBPSU5URVJfVFlQRV9UT1VDSCIsIlBPSU5URVJfVFlQRV9QRU4iLCJDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQiLCJTV0lQRV9USFJFU0hPTEQiLCJEZWZhdWx0JGMiLCJlbmRDYWxsYmFjayIsImxlZnRDYWxsYmFjayIsInJpZ2h0Q2FsbGJhY2siLCJEZWZhdWx0VHlwZSRjIiwiU3dpcGUiLCJfc3RhcnQiLCJfc3VwcG9ydFBvaW50ZXJFdmVudHMiLCJfZGVsdGFYIiwidG91Y2hlcyIsImNsaWVudFgiLCJfZXZlbnRJc1BvaW50ZXJQZW5Ub3VjaCIsIl9lbmQiLCJfaGFuZGxlU3dpcGUiLCJfbW92ZSIsImFic0RlbHRhWCIsImFicyIsImRpcmVjdGlvbiIsIl9pbml0RXZlbnRzIiwiYWRkIiwicG9pbnRlclR5cGUiLCJpc1N1cHBvcnRlZCIsIm5hdmlnYXRvciIsIm1heFRvdWNoUG9pbnRzIiwiUG9pbnRlckV2ZW50IiwiTkFNRSRjIiwiREFUQV9LRVkkOCIsIkVWRU5UX0tFWSQ4IiwiREFUQV9BUElfS0VZJDUiLCJBUlJPV19MRUZUX0tFWSQxIiwiQVJST1dfUklHSFRfS0VZJDEiLCJUT1VDSEVWRU5UX0NPTVBBVF9XQUlUIiwiT1JERVJfTkVYVCIsIk9SREVSX1BSRVYiLCJESVJFQ1RJT05fTEVGVCIsIkRJUkVDVElPTl9SSUdIVCIsIkVWRU5UX1NMSURFIiwiRVZFTlRfU0xJRCIsIkVWRU5UX0tFWURPV04kMSIsIkVWRU5UX01PVVNFRU5URVIkMSIsIkVWRU5UX01PVVNFTEVBVkUkMSIsIkVWRU5UX0RSQUdfU1RBUlQiLCJFVkVOVF9MT0FEX0RBVEFfQVBJJDMiLCJFVkVOVF9DTElDS19EQVRBX0FQSSQ1IiwiQ0xBU1NfTkFNRV9DQVJPVVNFTCIsIkNMQVNTX05BTUVfQUNUSVZFJDIiLCJDTEFTU19OQU1FX1NMSURFIiwiQ0xBU1NfTkFNRV9FTkQiLCJDTEFTU19OQU1FX1NUQVJUIiwiQ0xBU1NfTkFNRV9ORVhUIiwiQ0xBU1NfTkFNRV9QUkVWIiwiU0VMRUNUT1JfQUNUSVZFIiwiU0VMRUNUT1JfSVRFTSIsIlNFTEVDVE9SX0FDVElWRV9JVEVNIiwiU0VMRUNUT1JfSVRFTV9JTUciLCJTRUxFQ1RPUl9JTkRJQ0FUT1JTIiwiU0VMRUNUT1JfREFUQV9TTElERSIsIlNFTEVDVE9SX0RBVEFfUklERSIsIktFWV9UT19ESVJFQ1RJT04iLCJEZWZhdWx0JGIiLCJpbnRlcnZhbCIsImtleWJvYXJkIiwicGF1c2UiLCJyaWRlIiwidG91Y2giLCJ3cmFwIiwiRGVmYXVsdFR5cGUkYiIsIkNhcm91c2VsIiwiX3NsaWRlIiwibmV4dFdoZW5WaXNpYmxlIiwiaGlkZGVuIiwiX2lzU2xpZGluZyIsIl9jbGVhckludGVydmFsIiwiY3ljbGUiLCJfdXBkYXRlSW50ZXJ2YWwiLCJfaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsIl9tYXliZUVuYWJsZUN5Y2xlIiwidG8iLCJpdGVtcyIsIl9nZXRJdGVtcyIsImFjdGl2ZUluZGV4IiwiX2dldEl0ZW1JbmRleCIsIl9nZXRBY3RpdmUiLCJvcmRlciIsIl9zd2lwZUhlbHBlciIsImRlZmF1bHRJbnRlcnZhbCIsIl9hZGRFdmVudExpc3RlbmVycyIsIl9rZXlkb3duIiwiX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMiLCJpbWciLCJlbmRDYWxsQmFjayIsInRvdWNoVGltZW91dCIsImNsZWFyVGltZW91dCIsInN3aXBlQ29uZmlnIiwiX2RpcmVjdGlvblRvT3JkZXIiLCJfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudCIsIl9pbmRpY2F0b3JzRWxlbWVudCIsImFjdGl2ZUluZGljYXRvciIsIm5ld0FjdGl2ZUluZGljYXRvciIsIl9hY3RpdmVFbGVtZW50IiwiZWxlbWVudEludGVydmFsIiwicGFyc2VJbnQiLCJpc05leHQiLCJuZXh0RWxlbWVudCIsIm5leHRFbGVtZW50SW5kZXgiLCJ0cmlnZ2VyRXZlbnQiLCJfb3JkZXJUb0RpcmVjdGlvbiIsInNsaWRlRXZlbnQiLCJpc0N5Y2xpbmciLCJkaXJlY3Rpb25hbENsYXNzTmFtZSIsIm9yZGVyQ2xhc3NOYW1lIiwiY29tcGxldGVDYWxsQmFjayIsIl9pc0FuaW1hdGVkIiwiY2xlYXJJbnRlcnZhbCIsImNhcm91c2VsIiwic2xpZGVJbmRleCIsImNhcm91c2VscyIsIk5BTUUkYiIsIkRBVEFfS0VZJDciLCJFVkVOVF9LRVkkNyIsIkRBVEFfQVBJX0tFWSQ0IiwiRVZFTlRfU0hPVyQ2IiwiRVZFTlRfU0hPV04kNiIsIkVWRU5UX0hJREUkNiIsIkVWRU5UX0hJRERFTiQ2IiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNCIsIkNMQVNTX05BTUVfU0hPVyQ3IiwiQ0xBU1NfTkFNRV9DT0xMQVBTRSIsIkNMQVNTX05BTUVfQ09MTEFQU0lORyIsIkNMQVNTX05BTUVfQ09MTEFQU0VEIiwiQ0xBU1NfTkFNRV9ERUVQRVJfQ0hJTERSRU4iLCJDTEFTU19OQU1FX0hPUklaT05UQUwiLCJXSURUSCIsIkhFSUdIVCIsIlNFTEVDVE9SX0FDVElWRVMiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0IiwiRGVmYXVsdCRhIiwicGFyZW50IiwiRGVmYXVsdFR5cGUkYSIsIkNvbGxhcHNlIiwiX2lzU2hvd24iLCJoaWRlIiwic2hvdyIsIl9pc1RyYW5zaXRpb25pbmciLCJhY3RpdmVDaGlsZHJlbiIsIl9nZXRGaXJzdExldmVsQ2hpbGRyZW4iLCJzdGFydEV2ZW50IiwiYWN0aXZlSW5zdGFuY2UiLCJkaW1lbnNpb24iLCJfZ2V0RGltZW5zaW9uIiwic3R5bGUiLCJfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzIiwiX3RyaWdnZXJBcnJheSIsImNvbXBsZXRlIiwiY2FwaXRhbGl6ZWREaW1lbnNpb24iLCJzY3JvbGxTaXplIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiX2luaXRpYWxpemVDaGlsZHJlbiIsInNlbGVjdGVkIiwidHJpZ2dlckFycmF5IiwiaXNPcGVuIiwidG9nZ2xlTGlzdCIsImVsZW0iLCJmaWx0ZXJFbGVtZW50IiwiZm91bmRFbGVtZW50IiwidG9wIiwiYm90dG9tIiwicmlnaHQiLCJsZWZ0IiwiYXV0byIsImJhc2VQbGFjZW1lbnRzIiwic3RhcnQiLCJlbmQiLCJjbGlwcGluZ1BhcmVudHMiLCJ2aWV3cG9ydCIsInBvcHBlciIsInJlZmVyZW5jZSIsInZhcmlhdGlvblBsYWNlbWVudHMiLCJyZWR1Y2UiLCJhY2MiLCJwbGFjZW1lbnQiLCJwbGFjZW1lbnRzIiwiYmVmb3JlUmVhZCIsInJlYWQiLCJhZnRlclJlYWQiLCJiZWZvcmVNYWluIiwibWFpbiIsImFmdGVyTWFpbiIsImJlZm9yZVdyaXRlIiwid3JpdGUiLCJhZnRlcldyaXRlIiwibW9kaWZpZXJQaGFzZXMiLCJnZXROb2RlTmFtZSIsIm5vZGVOYW1lIiwiZ2V0V2luZG93Iiwibm9kZSIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImlzRWxlbWVudCIsIk93bkVsZW1lbnQiLCJpc0hUTUxFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc1NoYWRvd1Jvb3QiLCJhcHBseVN0eWxlcyIsIl9yZWYiLCJzdGF0ZSIsImVsZW1lbnRzIiwiZm9yRWFjaCIsInN0eWxlcyIsImFzc2lnbiIsImVmZmVjdCQyIiwiX3JlZjIiLCJpbml0aWFsU3R5bGVzIiwicG9zaXRpb24iLCJvcHRpb25zIiwic3RyYXRlZ3kiLCJtYXJnaW4iLCJhcnJvdyIsInN0eWxlUHJvcGVydGllcyIsImhhc093blByb3BlcnR5IiwiYXR0cmlidXRlIiwiYXBwbHlTdHlsZXMkMSIsImVuYWJsZWQiLCJwaGFzZSIsImVmZmVjdCIsInJlcXVpcmVzIiwiZ2V0QmFzZVBsYWNlbWVudCIsInJvdW5kIiwiZ2V0VUFTdHJpbmciLCJ1YURhdGEiLCJ1c2VyQWdlbnREYXRhIiwiYnJhbmRzIiwiaXNBcnJheSIsIml0ZW0iLCJicmFuZCIsInZlcnNpb24iLCJ1c2VyQWdlbnQiLCJpc0xheW91dFZpZXdwb3J0IiwiaW5jbHVkZVNjYWxlIiwiaXNGaXhlZFN0cmF0ZWd5IiwiY2xpZW50UmVjdCIsInNjYWxlWCIsInNjYWxlWSIsIm9mZnNldFdpZHRoIiwid2lkdGgiLCJoZWlnaHQiLCJ2aXN1YWxWaWV3cG9ydCIsImFkZFZpc3VhbE9mZnNldHMiLCJ4Iiwib2Zmc2V0TGVmdCIsInkiLCJvZmZzZXRUb3AiLCJnZXRMYXlvdXRSZWN0Iiwicm9vdE5vZGUiLCJpc1NhbWVOb2RlIiwiaG9zdCIsImdldENvbXB1dGVkU3R5bGUkMSIsImlzVGFibGVFbGVtZW50IiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiZ2V0UGFyZW50Tm9kZSIsImFzc2lnbmVkU2xvdCIsImdldFRydWVPZmZzZXRQYXJlbnQiLCJvZmZzZXRQYXJlbnQiLCJnZXRDb250YWluaW5nQmxvY2siLCJpc0ZpcmVmb3giLCJpc0lFIiwiZWxlbWVudENzcyIsImN1cnJlbnROb2RlIiwiY3NzIiwidHJhbnNmb3JtIiwicGVyc3BlY3RpdmUiLCJjb250YWluIiwid2lsbENoYW5nZSIsImdldE9mZnNldFBhcmVudCIsImdldE1haW5BeGlzRnJvbVBsYWNlbWVudCIsIndpdGhpbiIsIm1pbiQxIiwibWF4JDEiLCJ3aXRoaW5NYXhDbGFtcCIsInYiLCJnZXRGcmVzaFNpZGVPYmplY3QiLCJtZXJnZVBhZGRpbmdPYmplY3QiLCJwYWRkaW5nT2JqZWN0IiwiZXhwYW5kVG9IYXNoTWFwIiwiaGFzaE1hcCIsInRvUGFkZGluZ09iamVjdCIsInBhZGRpbmciLCJyZWN0cyIsIl9zdGF0ZSRtb2RpZmllcnNEYXRhJCIsImFycm93RWxlbWVudCIsInBvcHBlck9mZnNldHMiLCJtb2RpZmllcnNEYXRhIiwiYmFzZVBsYWNlbWVudCIsImF4aXMiLCJpc1ZlcnRpY2FsIiwibGVuIiwiYXJyb3dSZWN0IiwibWluUHJvcCIsIm1heFByb3AiLCJlbmREaWZmIiwic3RhcnREaWZmIiwiYXJyb3dPZmZzZXRQYXJlbnQiLCJjbGllbnRTaXplIiwiY2xpZW50SGVpZ2h0IiwiY2xpZW50V2lkdGgiLCJjZW50ZXJUb1JlZmVyZW5jZSIsImNlbnRlciIsIm9mZnNldCIsImF4aXNQcm9wIiwiY2VudGVyT2Zmc2V0IiwiZWZmZWN0JDEiLCJfb3B0aW9ucyRlbGVtZW50IiwiYXJyb3ckMSIsInJlcXVpcmVzSWZFeGlzdHMiLCJnZXRWYXJpYXRpb24iLCJ1bnNldFNpZGVzIiwicm91bmRPZmZzZXRzQnlEUFIiLCJ3aW4iLCJkcHIiLCJkZXZpY2VQaXhlbFJhdGlvIiwibWFwVG9TdHlsZXMiLCJfT2JqZWN0JGFzc2lnbjIiLCJwb3BwZXJSZWN0IiwidmFyaWF0aW9uIiwib2Zmc2V0cyIsImdwdUFjY2VsZXJhdGlvbiIsImFkYXB0aXZlIiwicm91bmRPZmZzZXRzIiwiaXNGaXhlZCIsIl9vZmZzZXRzJHgiLCJfb2Zmc2V0cyR5IiwiX3JlZjMiLCJoYXNYIiwiaGFzWSIsInNpZGVYIiwic2lkZVkiLCJoZWlnaHRQcm9wIiwid2lkdGhQcm9wIiwib2Zmc2V0WSIsIm9mZnNldFgiLCJjb21tb25TdHlsZXMiLCJfcmVmNCIsIl9PYmplY3QkYXNzaWduIiwiY29tcHV0ZVN0eWxlcyIsIl9yZWY1IiwiX29wdGlvbnMkZ3B1QWNjZWxlcmF0IiwiX29wdGlvbnMkYWRhcHRpdmUiLCJfb3B0aW9ucyRyb3VuZE9mZnNldHMiLCJjb21wdXRlU3R5bGVzJDEiLCJwYXNzaXZlIiwiX29wdGlvbnMkc2Nyb2xsIiwic2Nyb2xsIiwiX29wdGlvbnMkcmVzaXplIiwicmVzaXplIiwic2Nyb2xsUGFyZW50cyIsInNjcm9sbFBhcmVudCIsInVwZGF0ZSIsImV2ZW50TGlzdGVuZXJzIiwiaGFzaCQxIiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJtYXRjaGVkIiwiaGFzaCIsImdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IiwiZ2V0V2luZG93U2Nyb2xsIiwic2Nyb2xsTGVmdCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsVG9wIiwicGFnZVlPZmZzZXQiLCJnZXRXaW5kb3dTY3JvbGxCYXJYIiwiZ2V0Vmlld3BvcnRSZWN0IiwiaHRtbCIsImxheW91dFZpZXdwb3J0IiwiZ2V0RG9jdW1lbnRSZWN0IiwiX2VsZW1lbnQkb3duZXJEb2N1bWVuIiwid2luU2Nyb2xsIiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJpc1Njcm9sbFBhcmVudCIsIl9nZXRDb21wdXRlZFN0eWxlIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJnZXRTY3JvbGxQYXJlbnQiLCJsaXN0U2Nyb2xsUGFyZW50cyIsImlzQm9keSIsInVwZGF0ZWRMaXN0IiwicmVjdFRvQ2xpZW50UmVjdCIsInJlY3QiLCJnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFRvcCIsImNsaWVudExlZnQiLCJnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZSIsImNsaXBwaW5nUGFyZW50IiwiZ2V0Q2xpcHBpbmdQYXJlbnRzIiwiY2FuRXNjYXBlQ2xpcHBpbmciLCJjbGlwcGVyRWxlbWVudCIsImdldENsaXBwaW5nUmVjdCIsImJvdW5kYXJ5Iiwicm9vdEJvdW5kYXJ5IiwibWFpbkNsaXBwaW5nUGFyZW50cyIsImZpcnN0Q2xpcHBpbmdQYXJlbnQiLCJjbGlwcGluZ1JlY3QiLCJhY2NSZWN0IiwiY29tcHV0ZU9mZnNldHMiLCJjb21tb25YIiwiY29tbW9uWSIsIm1haW5BeGlzIiwiZGV0ZWN0T3ZlcmZsb3ciLCJfb3B0aW9ucyIsIl9vcHRpb25zJHBsYWNlbWVudCIsIl9vcHRpb25zJHN0cmF0ZWd5IiwiX29wdGlvbnMkYm91bmRhcnkiLCJfb3B0aW9ucyRyb290Qm91bmRhcnkiLCJfb3B0aW9ucyRlbGVtZW50Q29udGUiLCJlbGVtZW50Q29udGV4dCIsIl9vcHRpb25zJGFsdEJvdW5kYXJ5IiwiYWx0Qm91bmRhcnkiLCJfb3B0aW9ucyRwYWRkaW5nIiwiYWx0Q29udGV4dCIsImNsaXBwaW5nQ2xpZW50UmVjdCIsImNvbnRleHRFbGVtZW50IiwicmVmZXJlbmNlQ2xpZW50UmVjdCIsInBvcHBlckNsaWVudFJlY3QiLCJlbGVtZW50Q2xpZW50UmVjdCIsIm92ZXJmbG93T2Zmc2V0cyIsIm9mZnNldERhdGEiLCJtdWx0aXBseSIsImNvbXB1dGVBdXRvUGxhY2VtZW50IiwiZmxpcFZhcmlhdGlvbnMiLCJfb3B0aW9ucyRhbGxvd2VkQXV0b1AiLCJhbGxvd2VkQXV0b1BsYWNlbWVudHMiLCJwbGFjZW1lbnRzJDEiLCJhbGxvd2VkUGxhY2VtZW50cyIsIm92ZXJmbG93cyIsInNvcnQiLCJhIiwiYiIsImdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzIiwib3Bwb3NpdGVQbGFjZW1lbnQiLCJmbGlwIiwiX3NraXAiLCJfb3B0aW9ucyRtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJfb3B0aW9ucyRhbHRBeGlzIiwiYWx0QXhpcyIsImNoZWNrQWx0QXhpcyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrUGxhY2VtZW50cyIsIl9vcHRpb25zJGZsaXBWYXJpYXRpbyIsInByZWZlcnJlZFBsYWNlbWVudCIsImlzQmFzZVBsYWNlbWVudCIsInJlZmVyZW5jZVJlY3QiLCJjaGVja3NNYXAiLCJtYWtlRmFsbGJhY2tDaGVja3MiLCJmaXJzdEZpdHRpbmdQbGFjZW1lbnQiLCJpIiwiX2Jhc2VQbGFjZW1lbnQiLCJpc1N0YXJ0VmFyaWF0aW9uIiwibWFpblZhcmlhdGlvblNpZGUiLCJhbHRWYXJpYXRpb25TaWRlIiwiY2hlY2tzIiwiZXZlcnkiLCJjaGVjayIsIm51bWJlck9mQ2hlY2tzIiwiX2xvb3AiLCJfaSIsImZpdHRpbmdQbGFjZW1lbnQiLCJfcmV0IiwicmVzZXQiLCJmbGlwJDEiLCJnZXRTaWRlT2Zmc2V0cyIsInByZXZlbnRlZE9mZnNldHMiLCJpc0FueVNpZGVGdWxseUNsaXBwZWQiLCJzb21lIiwic2lkZSIsInByZXZlbnRPdmVyZmxvdyIsInJlZmVyZW5jZU92ZXJmbG93IiwicG9wcGVyQWx0T3ZlcmZsb3ciLCJyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMiLCJwb3BwZXJFc2NhcGVPZmZzZXRzIiwiaXNSZWZlcmVuY2VIaWRkZW4iLCJoYXNQb3BwZXJFc2NhcGVkIiwiaGlkZSQxIiwiZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkiLCJpbnZlcnREaXN0YW5jZSIsInNraWRkaW5nIiwiZGlzdGFuY2UiLCJfb3B0aW9ucyRvZmZzZXQiLCJfZGF0YSRzdGF0ZSRwbGFjZW1lbnQiLCJvZmZzZXQkMSIsInBvcHBlck9mZnNldHMkMSIsImdldEFsdEF4aXMiLCJfb3B0aW9ucyR0ZXRoZXIiLCJ0ZXRoZXIiLCJfb3B0aW9ucyR0ZXRoZXJPZmZzZXQiLCJ0ZXRoZXJPZmZzZXQiLCJ0ZXRoZXJPZmZzZXRWYWx1ZSIsIm5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSIsIm9mZnNldE1vZGlmaWVyU3RhdGUiLCJfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQiLCJtYWluU2lkZSIsImFsdFNpZGUiLCJhZGRpdGl2ZSIsIm1pbkxlbiIsIm1heExlbiIsImFycm93UGFkZGluZ09iamVjdCIsImFycm93UGFkZGluZ01pbiIsImFycm93UGFkZGluZ01heCIsImFycm93TGVuIiwibWluT2Zmc2V0IiwibWF4T2Zmc2V0IiwiY2xpZW50T2Zmc2V0Iiwib2Zmc2V0TW9kaWZpZXJWYWx1ZSIsInRldGhlck1pbiIsInRldGhlck1heCIsInByZXZlbnRlZE9mZnNldCIsIl9vZmZzZXRNb2RpZmllclN0YXRlJDIiLCJfbWFpblNpZGUiLCJfYWx0U2lkZSIsIl9vZmZzZXQiLCJfbGVuIiwiX21pbiIsIl9tYXgiLCJpc09yaWdpblNpZGUiLCJfb2Zmc2V0TW9kaWZpZXJWYWx1ZSIsIl90ZXRoZXJNaW4iLCJfdGV0aGVyTWF4IiwiX3ByZXZlbnRlZE9mZnNldCIsInByZXZlbnRPdmVyZmxvdyQxIiwiZ2V0SFRNTEVsZW1lbnRTY3JvbGwiLCJnZXROb2RlU2Nyb2xsIiwiaXNFbGVtZW50U2NhbGVkIiwiZ2V0Q29tcG9zaXRlUmVjdCIsImVsZW1lbnRPclZpcnR1YWxFbGVtZW50IiwiaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQiLCJvZmZzZXRQYXJlbnRJc1NjYWxlZCIsIm1vZGlmaWVycyIsInZpc2l0ZWQiLCJyZXN1bHQiLCJtb2RpZmllciIsImRlcCIsImRlcE1vZGlmaWVyIiwib3JkZXJNb2RpZmllcnMiLCJvcmRlcmVkTW9kaWZpZXJzIiwiZGVib3VuY2UiLCJwZW5kaW5nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwibWVyZ2VCeU5hbWUiLCJtZXJnZWQiLCJjdXJyZW50IiwiZXhpc3RpbmciLCJERUZBVUxUX09QVElPTlMiLCJhcmVWYWxpZEVsZW1lbnRzIiwiYXJndW1lbnRzIiwiX2tleSIsInBvcHBlckdlbmVyYXRvciIsImdlbmVyYXRvck9wdGlvbnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZiIsImRlZmF1bHRNb2RpZmllcnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyIiwiZGVmYXVsdE9wdGlvbnMiLCJjcmVhdGVQb3BwZXIiLCJlZmZlY3RDbGVhbnVwRm5zIiwiaXNEZXN0cm95ZWQiLCJzZXRPcHRpb25zIiwic2V0T3B0aW9uc0FjdGlvbiIsImNsZWFudXBNb2RpZmllckVmZmVjdHMiLCJtIiwicnVuTW9kaWZpZXJFZmZlY3RzIiwiZm9yY2VVcGRhdGUiLCJfc3RhdGUkZWxlbWVudHMiLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUiLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUyIiwiZGVzdHJveSIsIm9uRmlyc3RVcGRhdGUiLCJfcmVmJG9wdGlvbnMiLCJjbGVhbnVwRm4iLCJub29wRm4iLCJjcmVhdGVQb3BwZXIkMiIsImRlZmF1bHRNb2RpZmllcnMkMSIsImNyZWF0ZVBvcHBlciQxIiwiUG9wcGVyIiwiZnJlZXplIiwiX19wcm90b19fIiwiY3JlYXRlUG9wcGVyQmFzZSIsImNyZWF0ZVBvcHBlckxpdGUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIk5BTUUkYSIsIkRBVEFfS0VZJDYiLCJFVkVOVF9LRVkkNiIsIkRBVEFfQVBJX0tFWSQzIiwiRVNDQVBFX0tFWSQyIiwiVEFCX0tFWSQxIiwiQVJST1dfVVBfS0VZJDEiLCJBUlJPV19ET1dOX0tFWSQxIiwiUklHSFRfTU9VU0VfQlVUVE9OIiwiRVZFTlRfSElERSQ1IiwiRVZFTlRfSElEREVOJDUiLCJFVkVOVF9TSE9XJDUiLCJFVkVOVF9TSE9XTiQ1IiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMyIsIkVWRU5UX0tFWURPV05fREFUQV9BUEkiLCJFVkVOVF9LRVlVUF9EQVRBX0FQSSIsIkNMQVNTX05BTUVfU0hPVyQ2IiwiQ0xBU1NfTkFNRV9EUk9QVVAiLCJDTEFTU19OQU1FX0RST1BFTkQiLCJDTEFTU19OQU1FX0RST1BTVEFSVCIsIkNMQVNTX05BTUVfRFJPUFVQX0NFTlRFUiIsIkNMQVNTX05BTUVfRFJPUERPV05fQ0VOVEVSIiwiU0VMRUNUT1JfREFUQV9UT0dHTEUkMyIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFX1NIT1dOIiwiU0VMRUNUT1JfTUVOVSIsIlNFTEVDVE9SX05BVkJBUiIsIlNFTEVDVE9SX05BVkJBUl9OQVYiLCJTRUxFQ1RPUl9WSVNJQkxFX0lURU1TIiwiUExBQ0VNRU5UX1RPUCIsIlBMQUNFTUVOVF9UT1BFTkQiLCJQTEFDRU1FTlRfQk9UVE9NIiwiUExBQ0VNRU5UX0JPVFRPTUVORCIsIlBMQUNFTUVOVF9SSUdIVCIsIlBMQUNFTUVOVF9MRUZUIiwiUExBQ0VNRU5UX1RPUENFTlRFUiIsIlBMQUNFTUVOVF9CT1RUT01DRU5URVIiLCJEZWZhdWx0JDkiLCJhdXRvQ2xvc2UiLCJkaXNwbGF5IiwicG9wcGVyQ29uZmlnIiwiRGVmYXVsdFR5cGUkOSIsIkRyb3Bkb3duIiwic2hvd0V2ZW50IiwiX2NyZWF0ZVBvcHBlciIsIl9wYXJlbnQiLCJmb2N1cyIsIl9tZW51IiwiX2NvbXBsZXRlSGlkZSIsIl9wb3BwZXIiLCJfaW5OYXZiYXIiLCJfZGV0ZWN0TmF2YmFyIiwiaGlkZUV2ZW50IiwicmVmZXJlbmNlRWxlbWVudCIsIl9nZXRQb3BwZXJDb25maWciLCJfZ2V0UGxhY2VtZW50IiwicGFyZW50RHJvcGRvd24iLCJpc0VuZCIsIl9nZXRPZmZzZXQiLCJwb3BwZXJEYXRhIiwiZGVmYXVsdEJzUG9wcGVyQ29uZmlnIiwiX3NlbGVjdE1lbnVJdGVtIiwiY2xlYXJNZW51cyIsIm9wZW5Ub2dnbGVzIiwiY29udGV4dCIsImNvbXBvc2VkUGF0aCIsImlzTWVudVRhcmdldCIsImRhdGFBcGlLZXlkb3duSGFuZGxlciIsImlzSW5wdXQiLCJpc0VzY2FwZUV2ZW50IiwiaXNVcE9yRG93bkV2ZW50IiwiZ2V0VG9nZ2xlQnV0dG9uIiwic3RvcFByb3BhZ2F0aW9uIiwiTkFNRSQ5IiwiQ0xBU1NfTkFNRV9GQURFJDQiLCJDTEFTU19OQU1FX1NIT1ckNSIsIkVWRU5UX01PVVNFRE9XTiIsIkRlZmF1bHQkOCIsImNsYXNzTmFtZSIsImNsaWNrQ2FsbGJhY2siLCJyb290RWxlbWVudCIsIkRlZmF1bHRUeXBlJDgiLCJCYWNrZHJvcCIsIl9hcHBlbmQiLCJfZ2V0RWxlbWVudCIsIl9lbXVsYXRlQW5pbWF0aW9uIiwiX2lzQXBwZW5kZWQiLCJiYWNrZHJvcCIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmQiLCJOQU1FJDgiLCJEQVRBX0tFWSQ1IiwiRVZFTlRfS0VZJDUiLCJFVkVOVF9GT0NVU0lOJDIiLCJFVkVOVF9LRVlET1dOX1RBQiIsIlRBQl9LRVkiLCJUQUJfTkFWX0ZPUldBUkQiLCJUQUJfTkFWX0JBQ0tXQVJEIiwiRGVmYXVsdCQ3IiwiYXV0b2ZvY3VzIiwidHJhcEVsZW1lbnQiLCJEZWZhdWx0VHlwZSQ3IiwiRm9jdXNUcmFwIiwiYWN0aXZhdGUiLCJfaXNBY3RpdmUiLCJfaGFuZGxlRm9jdXNpbiIsIl9oYW5kbGVLZXlkb3duIiwiZGVhY3RpdmF0ZSIsIl9sYXN0VGFiTmF2RGlyZWN0aW9uIiwic2hpZnRLZXkiLCJTRUxFQ1RPUl9GSVhFRF9DT05URU5UIiwiU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQiLCJQUk9QRVJUWV9QQURESU5HIiwiUFJPUEVSVFlfTUFSR0lOIiwiU2Nyb2xsQmFySGVscGVyIiwiZ2V0V2lkdGgiLCJkb2N1bWVudFdpZHRoIiwiaW5uZXJXaWR0aCIsIl9kaXNhYmxlT3ZlckZsb3ciLCJfc2V0RWxlbWVudEF0dHJpYnV0ZXMiLCJjYWxjdWxhdGVkVmFsdWUiLCJfcmVzZXRFbGVtZW50QXR0cmlidXRlcyIsImlzT3ZlcmZsb3dpbmciLCJfc2F2ZUluaXRpYWxBdHRyaWJ1dGUiLCJzdHlsZVByb3BlcnR5Iiwic2Nyb2xsYmFyV2lkdGgiLCJtYW5pcHVsYXRpb25DYWxsQmFjayIsInNldFByb3BlcnR5IiwiX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2siLCJhY3R1YWxWYWx1ZSIsInJlbW92ZVByb3BlcnR5IiwiY2FsbEJhY2siLCJOQU1FJDciLCJEQVRBX0tFWSQ0IiwiRVZFTlRfS0VZJDQiLCJEQVRBX0FQSV9LRVkkMiIsIkVTQ0FQRV9LRVkkMSIsIkVWRU5UX0hJREUkNCIsIkVWRU5UX0hJREVfUFJFVkVOVEVEJDEiLCJFVkVOVF9ISURERU4kNCIsIkVWRU5UX1NIT1ckNCIsIkVWRU5UX1NIT1dOJDQiLCJFVkVOVF9SRVNJWkUkMSIsIkVWRU5UX0NMSUNLX0RJU01JU1MiLCJFVkVOVF9NT1VTRURPV05fRElTTUlTUyIsIkVWRU5UX0tFWURPV05fRElTTUlTUyQxIiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMiIsIkNMQVNTX05BTUVfT1BFTiIsIkNMQVNTX05BTUVfRkFERSQzIiwiQ0xBU1NfTkFNRV9TSE9XJDQiLCJDTEFTU19OQU1FX1NUQVRJQyIsIk9QRU5fU0VMRUNUT1IkMSIsIlNFTEVDVE9SX0RJQUxPRyIsIlNFTEVDVE9SX01PREFMX0JPRFkiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQyIiwiRGVmYXVsdCQ2IiwiRGVmYXVsdFR5cGUkNiIsIk1vZGFsIiwiX3Njcm9sbEJhciIsIl9hZGp1c3REaWFsb2ciLCJfYmFja2Ryb3AiLCJfc2hvd0VsZW1lbnQiLCJfZm9jdXN0cmFwIiwiX2hpZGVNb2RhbCIsIl9kaWFsb2ciLCJoYW5kbGVVcGRhdGUiLCJfaW5pdGlhbGl6ZUJhY2tEcm9wIiwiX2luaXRpYWxpemVGb2N1c1RyYXAiLCJtb2RhbEJvZHkiLCJ0cmFuc2l0aW9uQ29tcGxldGUiLCJfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbiIsImV2ZW50MiIsIl9yZXNldEFkanVzdG1lbnRzIiwiaXNNb2RhbE92ZXJmbG93aW5nIiwiaW5pdGlhbE92ZXJmbG93WSIsImlzQm9keU92ZXJmbG93aW5nIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJhbHJlYWR5T3BlbiIsIk5BTUUkNiIsIkRBVEFfS0VZJDMiLCJFVkVOVF9LRVkkMyIsIkRBVEFfQVBJX0tFWSQxIiwiRVZFTlRfTE9BRF9EQVRBX0FQSSQyIiwiRVNDQVBFX0tFWSIsIkNMQVNTX05BTUVfU0hPVyQzIiwiQ0xBU1NfTkFNRV9TSE9XSU5HJDEiLCJDTEFTU19OQU1FX0hJRElORyIsIkNMQVNTX05BTUVfQkFDS0RST1AiLCJPUEVOX1NFTEVDVE9SIiwiRVZFTlRfU0hPVyQzIiwiRVZFTlRfU0hPV04kMyIsIkVWRU5UX0hJREUkMyIsIkVWRU5UX0hJREVfUFJFVkVOVEVEIiwiRVZFTlRfSElEREVOJDMiLCJFVkVOVF9SRVNJWkUiLCJFVkVOVF9DTElDS19EQVRBX0FQSSQxIiwiRVZFTlRfS0VZRE9XTl9ESVNNSVNTIiwiU0VMRUNUT1JfREFUQV9UT0dHTEUkMSIsIkRlZmF1bHQkNSIsIkRlZmF1bHRUeXBlJDUiLCJPZmZjYW52YXMiLCJibHVyIiwiY29tcGxldGVDYWxsYmFjayIsIkFSSUFfQVRUUklCVVRFX1BBVFRFUk4iLCJEZWZhdWx0QWxsb3dsaXN0IiwiYXJlYSIsImJyIiwiY29sIiwiY29kZSIsImRkIiwiZGl2IiwiZGwiLCJkdCIsImVtIiwiaHIiLCJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiLCJsaSIsIm9sIiwicCIsInByZSIsInMiLCJzbWFsbCIsInNwYW4iLCJzdWIiLCJzdXAiLCJzdHJvbmciLCJ1IiwidWwiLCJ1cmlBdHRyaWJ1dGVzIiwiU0FGRV9VUkxfUEFUVEVSTiIsImFsbG93ZWRBdHRyaWJ1dGUiLCJhbGxvd2VkQXR0cmlidXRlTGlzdCIsImF0dHJpYnV0ZU5hbWUiLCJub2RlVmFsdWUiLCJhdHRyaWJ1dGVSZWdleCIsInJlZ2V4Iiwic2FuaXRpemVIdG1sIiwidW5zYWZlSHRtbCIsImFsbG93TGlzdCIsInNhbml0aXplRnVuY3Rpb24iLCJkb21QYXJzZXIiLCJET01QYXJzZXIiLCJjcmVhdGVkRG9jdW1lbnQiLCJwYXJzZUZyb21TdHJpbmciLCJlbGVtZW50TmFtZSIsImF0dHJpYnV0ZUxpc3QiLCJhbGxvd2VkQXR0cmlidXRlcyIsImlubmVySFRNTCIsIk5BTUUkNSIsIkRlZmF1bHQkNCIsImNvbnRlbnQiLCJleHRyYUNsYXNzIiwic2FuaXRpemUiLCJzYW5pdGl6ZUZuIiwidGVtcGxhdGUiLCJEZWZhdWx0VHlwZSQ0IiwiRGVmYXVsdENvbnRlbnRUeXBlIiwiZW50cnkiLCJUZW1wbGF0ZUZhY3RvcnkiLCJnZXRDb250ZW50IiwiX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uIiwiaGFzQ29udGVudCIsImNoYW5nZUNvbnRlbnQiLCJfY2hlY2tDb250ZW50IiwidG9IdG1sIiwidGVtcGxhdGVXcmFwcGVyIiwiX21heWJlU2FuaXRpemUiLCJ0ZXh0IiwiX3NldENvbnRlbnQiLCJhcmciLCJ0ZW1wbGF0ZUVsZW1lbnQiLCJfcHV0RWxlbWVudEluVGVtcGxhdGUiLCJ0ZXh0Q29udGVudCIsIk5BTUUkNCIsIkRJU0FMTE9XRURfQVRUUklCVVRFUyIsIkNMQVNTX05BTUVfRkFERSQyIiwiQ0xBU1NfTkFNRV9NT0RBTCIsIkNMQVNTX05BTUVfU0hPVyQyIiwiU0VMRUNUT1JfVE9PTFRJUF9JTk5FUiIsIlNFTEVDVE9SX01PREFMIiwiRVZFTlRfTU9EQUxfSElERSIsIlRSSUdHRVJfSE9WRVIiLCJUUklHR0VSX0ZPQ1VTIiwiVFJJR0dFUl9DTElDSyIsIlRSSUdHRVJfTUFOVUFMIiwiRVZFTlRfSElERSQyIiwiRVZFTlRfSElEREVOJDIiLCJFVkVOVF9TSE9XJDIiLCJFVkVOVF9TSE9XTiQyIiwiRVZFTlRfSU5TRVJURUQiLCJFVkVOVF9DTElDSyQxIiwiRVZFTlRfRk9DVVNJTiQxIiwiRVZFTlRfRk9DVVNPVVQkMSIsIkVWRU5UX01PVVNFRU5URVIiLCJFVkVOVF9NT1VTRUxFQVZFIiwiQXR0YWNobWVudE1hcCIsIkFVVE8iLCJUT1AiLCJSSUdIVCIsIkJPVFRPTSIsIkxFRlQiLCJEZWZhdWx0JDMiLCJhbmltYXRpb24iLCJjb250YWluZXIiLCJjdXN0b21DbGFzcyIsImRlbGF5IiwidGl0bGUiLCJEZWZhdWx0VHlwZSQzIiwiVG9vbHRpcCIsImVuYWJsZSIsIl9pc0VuYWJsZWQiLCJkaXNhYmxlIiwidG9nZ2xlRW5hYmxlZCIsIl9hY3RpdmVUcmlnZ2VyIiwiY2xpY2siLCJfbGVhdmUiLCJfZW50ZXIiLCJfdGltZW91dCIsIl9oaWRlTW9kYWxIYW5kbGVyIiwiX2Rpc3Bvc2VQb3BwZXIiLCJfaXNXaXRoQ29udGVudCIsInNoYWRvd1Jvb3QiLCJpc0luVGhlRG9tIiwidGlwIiwiX2dldFRpcEVsZW1lbnQiLCJfaXNIb3ZlcmVkIiwiX2lzV2l0aEFjdGl2ZVRyaWdnZXIiLCJfZ2V0VGl0bGUiLCJfY3JlYXRlVGlwRWxlbWVudCIsIl9uZXdDb250ZW50IiwiX2dldENvbnRlbnRGb3JUZW1wbGF0ZSIsIl9nZXRUZW1wbGF0ZUZhY3RvcnkiLCJ0aXBJZCIsInNldENvbnRlbnQiLCJfdGVtcGxhdGVGYWN0b3J5IiwiX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCIsIl9nZXREZWxlZ2F0ZUNvbmZpZyIsImF0dGFjaG1lbnQiLCJfc2V0TGlzdGVuZXJzIiwidHJpZ2dlcnMiLCJldmVudEluIiwiZXZlbnRPdXQiLCJfZml4VGl0bGUiLCJfc2V0VGltZW91dCIsInRpbWVvdXQiLCJkYXRhQXR0cmlidXRlcyIsImRhdGFBdHRyaWJ1dGUiLCJOQU1FJDMiLCJTRUxFQ1RPUl9USVRMRSIsIlNFTEVDVE9SX0NPTlRFTlQiLCJEZWZhdWx0JDIiLCJEZWZhdWx0VHlwZSQyIiwiUG9wb3ZlciIsIl9nZXRDb250ZW50IiwiTkFNRSQyIiwiREFUQV9LRVkkMiIsIkVWRU5UX0tFWSQyIiwiREFUQV9BUElfS0VZIiwiRVZFTlRfQUNUSVZBVEUiLCJFVkVOVF9DTElDSyIsIkVWRU5UX0xPQURfREFUQV9BUEkkMSIsIkNMQVNTX05BTUVfRFJPUERPV05fSVRFTSIsIkNMQVNTX05BTUVfQUNUSVZFJDEiLCJTRUxFQ1RPUl9EQVRBX1NQWSIsIlNFTEVDVE9SX1RBUkdFVF9MSU5LUyIsIlNFTEVDVE9SX05BVl9MSVNUX0dST1VQIiwiU0VMRUNUT1JfTkFWX0xJTktTIiwiU0VMRUNUT1JfTkFWX0lURU1TIiwiU0VMRUNUT1JfTElTVF9JVEVNUyIsIlNFTEVDVE9SX0xJTktfSVRFTVMiLCJTRUxFQ1RPUl9EUk9QRE9XTiIsIlNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSQxIiwiRGVmYXVsdCQxIiwicm9vdE1hcmdpbiIsInNtb290aFNjcm9sbCIsInRocmVzaG9sZCIsIkRlZmF1bHRUeXBlJDEiLCJTY3JvbGxTcHkiLCJyZWZyZXNoIiwiX2luaXRpYWxpemVUYXJnZXRzQW5kT2JzZXJ2YWJsZXMiLCJfbWF5YmVFbmFibGVTbW9vdGhTY3JvbGwiLCJfb2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwiX2dldE5ld09ic2VydmVyIiwic2VjdGlvbiIsIl9vYnNlcnZhYmxlU2VjdGlvbnMiLCJvYnNlcnZlIiwib2JzZXJ2YWJsZVNlY3Rpb24iLCJfcm9vdEVsZW1lbnQiLCJzY3JvbGxUbyIsImJlaGF2aW9yIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJfb2JzZXJ2ZXJDYWxsYmFjayIsInRhcmdldEVsZW1lbnQiLCJfdGFyZ2V0TGlua3MiLCJfcHJldmlvdXNTY3JvbGxEYXRhIiwidmlzaWJsZUVudHJ5VG9wIiwiX3Byb2Nlc3MiLCJwYXJlbnRTY3JvbGxUb3AiLCJ1c2VyU2Nyb2xsc0Rvd24iLCJpc0ludGVyc2VjdGluZyIsIl9hY3RpdmVUYXJnZXQiLCJfY2xlYXJBY3RpdmVDbGFzcyIsImVudHJ5SXNMb3dlclRoYW5QcmV2aW91cyIsInRhcmdldExpbmtzIiwiYW5jaG9yIiwiZGVjb2RlVVJJIiwiX2FjdGl2YXRlUGFyZW50cyIsImxpc3RHcm91cCIsImFjdGl2ZU5vZGVzIiwic3B5IiwiTkFNRSQxIiwiREFUQV9LRVkkMSIsIkVWRU5UX0tFWSQxIiwiRVZFTlRfSElERSQxIiwiRVZFTlRfSElEREVOJDEiLCJFVkVOVF9TSE9XJDEiLCJFVkVOVF9TSE9XTiQxIiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkiLCJFVkVOVF9LRVlET1dOIiwiRVZFTlRfTE9BRF9EQVRBX0FQSSIsIkFSUk9XX0xFRlRfS0VZIiwiQVJST1dfUklHSFRfS0VZIiwiQVJST1dfVVBfS0VZIiwiQVJST1dfRE9XTl9LRVkiLCJIT01FX0tFWSIsIkVORF9LRVkiLCJDTEFTU19OQU1FX0FDVElWRSIsIkNMQVNTX05BTUVfRkFERSQxIiwiQ0xBU1NfTkFNRV9TSE9XJDEiLCJDTEFTU19EUk9QRE9XTiIsIlNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSIsIlNFTEVDVE9SX0RST1BET1dOX01FTlUiLCJOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFIiwiU0VMRUNUT1JfVEFCX1BBTkVMIiwiU0VMRUNUT1JfT1VURVIiLCJTRUxFQ1RPUl9JTk5FUiIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFIiwiU0VMRUNUT1JfSU5ORVJfRUxFTSIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFX0FDVElWRSIsIlRhYiIsImlubmVyRWxlbSIsIl9lbGVtSXNBY3RpdmUiLCJhY3RpdmUiLCJfZ2V0QWN0aXZlRWxlbSIsIl9kZWFjdGl2YXRlIiwiX2FjdGl2YXRlIiwicmVsYXRlZEVsZW0iLCJfdG9nZ2xlRHJvcERvd24iLCJfZ2V0Q2hpbGRyZW4iLCJuZXh0QWN0aXZlRWxlbWVudCIsInByZXZlbnRTY3JvbGwiLCJfc2V0SW5pdGlhbEF0dHJpYnV0ZXMiLCJfc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMiLCJfc2V0SW5pdGlhbEF0dHJpYnV0ZXNPbkNoaWxkIiwiX2dldElubmVyRWxlbWVudCIsImlzQWN0aXZlIiwib3V0ZXJFbGVtIiwiX2dldE91dGVyRWxlbWVudCIsIl9zZXRJbml0aWFsQXR0cmlidXRlc09uVGFyZ2V0UGFuZWwiLCJvcGVuIiwiRVZFTlRfTU9VU0VPVkVSIiwiRVZFTlRfTU9VU0VPVVQiLCJFVkVOVF9GT0NVU0lOIiwiRVZFTlRfRk9DVVNPVVQiLCJFVkVOVF9ISURFIiwiRVZFTlRfSElEREVOIiwiRVZFTlRfU0hPVyIsIkVWRU5UX1NIT1dOIiwiQ0xBU1NfTkFNRV9GQURFIiwiQ0xBU1NfTkFNRV9ISURFIiwiQ0xBU1NfTkFNRV9TSE9XIiwiQ0xBU1NfTkFNRV9TSE9XSU5HIiwiYXV0b2hpZGUiLCJUb2FzdCIsIl9jbGVhclRpbWVvdXQiLCJfbWF5YmVTY2hlZHVsZUhpZGUiLCJpc1Nob3duIiwiX2hhc01vdXNlSW50ZXJhY3Rpb24iLCJfaGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiIsIl9vbkludGVyYWN0aW9uIiwiaXNJbnRlcmFjdGluZyIsImluZGV4X3VtZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/bootstrap@5.3.3_@popperjs+core@2.11.8/node_modules/bootstrap/dist/js/bootstrap.bundle.js\n"));

/***/ })

}]);